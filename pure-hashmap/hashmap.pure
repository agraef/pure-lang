
/* hashmap.pure: mutable maps and sets for arbitrary key and value types,
   implemented as STL hashes */

/* NOTE: This module requires Pure 0.49 or later. It also needs a recent
   (C++0x) STL implementation. The module is still experimental and the API is
   subject to change, so beware. */

/* Copyright (c) 2011 by Albert Graef <Dr.Graef@t-online.de>.

   This file is part of the Pure standard library.

   The Pure standard library is free software: you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
   more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */

/* Native interface. You can freely use most of these in addition to the
   "standard" container API provided below. NOTE: hashmap_free is reserved for
   internal use as a sentry on hashmap objects. It should never be called
   directly. */

using "lib:hashmap";

extern int hashmap_tag();
extern expr* hashmap(expr*);
extern hashmap* hashmap_copy(hashmap*);
extern void hashmap_clear(hashmap*);
extern void hashmap_free(hashmap*); // internal use only
extern void hashmap_add(hashmap*, expr*);
extern void hashmap_add2(hashmap*, expr*, expr*);
extern void hashmap_del(hashmap*, expr*);
extern expr* hashmap_get(hashmap*, expr*);
extern bool hashmap_member(hashmap*, expr*);
extern bool hashmap_empty(hashmap*);
extern int hashmap_size(hashmap*);
extern expr* hashmap_list(hashmap*);
extern expr* hashmap_keys(hashmap*);
extern expr* hashmap_vals(hashmap*);

/* The hashmap type. Hashmaps are simply pointers to STL hashed maps
   (unordered_map) which hold key-value associations where both keys and
   values may be arbitrary Pure expressions. Memory management is automatic.

   NOTES:

   - Keys in a hashmap may be stored in an apparently random order (not
     necessarily the order in which they were inserted).

   - Values can be omitted, so that hashmaps can also be used as a hashed set
     data structure. In this case, m!x will return the key x itself if it is
     in the hashmap. Likewise, vals m will return the keys for members which
     have no associated value. (The only downside of this approach is that you
     can't have a hash pair x=>y as a member of a set, since it always denotes
     a key-value association. Use ordinary pairs (x,y) instead.)

   - Hashmaps are *mutable*. Inserting a key into a hashmap or deleting it
     modifies the underlying STL data structure as a side effect of the
     operation. If you need value semantics, you should use one of the dict or
     set data structures from the standard library instead. (Another
     possibility is to take a copy of a hashmap if you need to preserve the
     original value, but note that this operation takes O(n) time.)

   - Since hashmaps are pointers, two hashmaps are syntactically equal iff
     they are exactly the same object (identical pointer values). This test
     can be done in constant time. Use the semantic equality tests below if
     you need to test whether two hashmaps contain the same elements. */

let hashmap_t = hashmap_tag;
type hashmap x::pointer = check_ptrtag hashmap_t x;
hashmapp x = pointerp x && check_ptrtag hashmap_t x;

// Hashmap constructor. If you change this, you'll have to change the
// pretty-printing function in hashmap.cc accordingly.

nonfix {$$};
outfix {$ $};

// NOTE: This needs the new built-in __list__ macro from Pure 0.49 or
// later. If you don't have this, you can substitute the list function for
// __list__, but then sets with tuple elements won't be parsed correctly.

def {$$} = hashmap [];
def {$ xs@(_,_) $} = hashmap (__list__ xs);
def {$ x $} = hashmap [x];

// Minimal container API for hashmaps.

# m::hashmap = hashmap_size m;
m::hashmap ! x = if hashmap_member m x then hashmap_get m x
		 else throw out_of_bounds;

// FIXME: null doesn't work here because there's a generic definition for
// pointers in the prelude. For the time being, use empty instead.
empty m::hashmap = hashmap_empty m;
member m::hashmap x = hashmap_member m x;
update m::hashmap x y = hashmap_add2 m x y $$ m;
insert m::hashmap (x=>y) = hashmap_add2 m x y $$ m;
insert m::hashmap x = hashmap_add m x $$ m;
delete m::hashmap x = hashmap_del m x $$ m;

list m::hashmap = hashmap_list m;
keys m::hashmap = hashmap_keys m;
vals m::hashmap = hashmap_vals m;

/* Semantic equality and comparisons of hashmaps. These compare keys and
   values for syntactic equality. Equality holds iff two hashmaps contain the
   same key=>val pairs, irrespective of their ordering. Besides equality and
   inequality we also provide submap comparisons. A hashmap x is considered a
   submap of a hashmap y iff all key=>val pairs of x are also contained in y.
   All comparisons should work in O(n log n) time. */

x::hashmap == y::hashmap = x<=y && y<=x;
x::hashmap ~= y::hashmap = ~(x==y);
x::hashmap <= y::hashmap = x===y ||
  (all (member y) xks && vals x === [y!k | k = xks] when xks = keys x end);
x::hashmap >= y::hashmap = x===y ||
  (all (member x) yks && vals y === [x!k | k = yks] when yks = keys y end);
x::hashmap <  y::hashmap = x<=y && #x<#y;
x::hashmap >  y::hashmap = x>=y && #x>#y;

// Basic list-like operations and support for list and matrix comprehensions.

do f m::hashmap = do f (list m);
map f m::hashmap = map f (list m);
catmap f m::hashmap = catmap f (list m);
listmap f m::hashmap = map f (list m);
listcatmap f m::hashmap = catmap f (list m);
rowmap f m::hashmap = rowcat (map f m);
rowcatmap f m::hashmap = rowcat (map f m);
colmap f m::hashmap = colcat (map f m);
colcatmap f m::hashmap = colcat (map f m);
