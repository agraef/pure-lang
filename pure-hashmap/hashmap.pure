
/* hashmap.pure: mutable maps and sets for arbitrary key and value types,
   implemented as STL hashes */

/* NOTE: This module requires Pure 0.49 or later. It also needs a recent
   (C++11) STL implementation. The module is still experimental and the API is
   subject to change, so beware. */

/* Copyright (c) 2011 by Albert Graef <Dr.Graef@t-online.de>.

   This file is part of the Pure standard library.

   The Pure standard library is free software: you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
   more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */

/* Native interface. You can freely use most of these in addition to the
   "standard" container API provided below. But note that hashmap_free and
   hashmmap_free are reserved for internal use as a sentry on hashmap and
   hashmmap objects and should never be called directly. */

using "lib:hashmap";

extern int hashmap_tag();
extern void hashmap_symbol(expr*);
extern expr* hashmap(expr*);
extern hashmap* hashmap_copy(hashmap*);
extern void hashmap_clear(hashmap*);
extern void hashmap_free(hashmap*); // internal use only
extern void hashmap_add(hashmap*, expr*);
extern void hashmap_add2(hashmap*, expr*, expr*);
extern void hashmap_del(hashmap*, expr*);
extern void hashmap_del2(hashmap*, expr*, expr*);
extern expr* hashmap_get(hashmap*, expr*);
extern bool hashmap_member(hashmap*, expr*);
extern bool hashmap_member2(hashmap*, expr*, expr*);
extern bool hashmap_empty(hashmap*);
extern bool hashmap_equal(hashmap*, hashmap*);
extern int hashmap_size(hashmap*);
extern expr* hashmap_list(hashmap*);
extern expr* hashmap_tuple(hashmap*);
extern expr* hashmap_vector(hashmap*);
extern expr* hashmap_keys(hashmap*);
extern expr* hashmap_vals(hashmap*);

extern int hashmmap_tag();
extern void hashmmap_symbol(expr*);
extern expr* hashmmap(expr*);
extern hashmmap* hashmmap_copy(hashmmap*);
extern void hashmmap_clear(hashmmap*);
extern void hashmmap_free(hashmmap*); // internal use only
extern void hashmmap_add(hashmmap*, expr*);
extern void hashmmap_add2(hashmmap*, expr*, expr*);
extern void hashmmap_del(hashmmap*, expr*);
extern void hashmmap_del2(hashmmap*, expr*, expr*);
extern expr* hashmmap_get(hashmmap*, expr*);
extern bool hashmmap_member(hashmmap*, expr*);
extern bool hashmmap_member2(hashmmap*, expr*, expr*);
extern bool hashmmap_empty(hashmmap*);
extern bool hashmmap_equal(hashmmap*, hashmmap*);
extern int hashmmap_size(hashmmap*);
extern expr* hashmmap_list(hashmmap*);
extern expr* hashmmap_tuple(hashmmap*);
extern expr* hashmmap_vector(hashmmap*);
extern expr* hashmmap_keys(hashmmap*);
extern expr* hashmmap_vals(hashmmap*);

/* The hashmap type. Hashmaps are simply pointers to STL unordered_map objects
   which hold key-value associations where both keys and values may be
   arbitrary Pure expressions. They can be created from lists, tuples and
   vectors using the hashmap function. Memory management is automatic. Please
   also note the following:

   - Keys in a hashmap may be stored in an apparently random order (not
     necessarily in the order in which they were inserted).

   - Values can be omitted, so that hashmaps can be used as a hashed set data
     structure. This obviates the need for a separate set data structure at
     the cost of some (small) increase in memory usage. Also note that you
     can't really have a hash pair x=>y as a member of a set, since it always
     denotes a key-value association. Use ordinary pairs (x,y) instead.

   - Hashmaps are *mutable*. Inserting a key into a hashmap or deleting it
     modifies the underlying STL data structure as a side effect of the
     operation. If you need value semantics, you should use one of the dict or
     set data structures from the standard library instead. (Another
     possibility is to take a copy of a hashmap using the hashmap_copy
     operation if you need to preserve the original value, but note that this
     operation takes O(n) time.)

   - Since hashmaps are pointers, two hashmaps are syntactically equal iff
     they are exactly the same object (identical pointer values). This test
     can be done in constant time. Use the semantic equality tests below if
     you need to test whether two hashmaps contain the same elements.

   - Hashmaps are pretty-printed in the format 'hashmap [...]' by default,
     which will reconstruct the expression when reentered as Pure code. With
     the hashmap_symbol function it is also possible to define your own custom
     pretty-printing; see examples/hashmap_examp.pure for an example. */

let hashmap_t = hashmap_tag;
type hashmap x::pointer = check_ptrtag hashmap_t x;
hashmapp x = pointerp x && check_ptrtag hashmap_t x;

// Make hashmap work with numeric vectors.
hashmap x::nmatrix = hashmap (smatrix x);

/* Semantic equality of hashmaps. These compare both keys and values for
   syntactic equality. Equality holds iff two hashmaps contain the same
   key=>val pairs, irrespective of their ordering. This check should always
   work in O(n log n) time. Note that no submap comparisons (<, <=, etc.) are
   provided, as the STL doesn't have them either, but see hashmap_examp.pure
   for a possible Pure implementation of these. */

x::hashmap == y::hashmap = hashmap_equal x y;
x::hashmap ~= y::hashmap = ~hashmap_equal x y;

// Minimal container API for hashmaps.

/* Note that if the key x is in the map but doesn't have an associated value
   (as in a set data structure), then m!x will return just x itself as the
   associated value. In any case, m!x raises an out_of_bound exception if x is
   not in the map. */

# m::hashmap = hashmap_size m;
m::hashmap ! x =
  if hashmap_member m x then hashmap_get m x else throw out_of_bounds;

// FIXME: null doesn't work here because there's a generic definition for
// pointers in the prelude. For the time being, use empty instead.
empty m::hashmap = hashmap_empty m;

/* Note that in addition to the usual container ops we also support membership
   tests (member) and deletions (delete) of specific key=>val pairs. */

member m::hashmap (x=>y) = hashmap_member2 m x y;
member m::hashmap x = hashmap_member m x;
update m::hashmap x y = hashmap_add2 m x y $$ m;
insert m::hashmap (x=>y) = hashmap_add2 m x y $$ m;
insert m::hashmap x = hashmap_add m x $$ m;
delete m::hashmap (x=>y) = hashmap_del2 m x y $$ m;
delete m::hashmap x = hashmap_del m x $$ m;

/* Note that vals m will return the keys for members which have no associated
   value. */

keys m::hashmap = hashmap_keys m;
vals m::hashmap = hashmap_vals m;

list m::hashmap = hashmap_list m;
tuple m::hashmap = hashmap_tuple m;
vector m::hashmap = hashmap_vector m;

// Basic list-like operations and support for list and matrix comprehensions.
// NOTE: The most important of these should maybe implemented in C, to avoid
// the construction of intermediate list values.

do f m::hashmap = do f (list m);
map f m::hashmap = map f (list m);
catmap f m::hashmap = catmap f (list m);
listmap f m::hashmap = map f (list m);
listcatmap f m::hashmap = catmap f (list m);
rowmap f m::hashmap = rowcat (map f m);
rowcatmap f m::hashmap = rowcat (map f m);
colmap f m::hashmap = colcat (map f m);
colcatmap f m::hashmap = colcat (map f m);

all p m::hashmap = all p (list m);
any p m::hashmap = any p (list m);
filter p m::hashmap = filter p (list m);
foldl f a m::hashmap = foldl f a (list m);
foldl1 f m::hashmap = foldl1 f (list m) if ~empty m;
foldr f a m::hashmap = foldr f a (list m);
foldr1 f m::hashmap = foldr1 f (list m) if ~empty m;
scanl f a m::hashmap = scanl f a (list m);
scanl1 f m::hashmap = scanl1 f (list m) if ~empty m;
scanr f a m::hashmap = scanr f a (list m);
scanr1 f m::hashmap = scanr1 f (list m) if ~empty m;
sort p m::hashmap = sort p (list m);

/***************************************************************************/

/* Hashed multimaps (STL unordered_multimap). These are represented using the
   hashmmap type which works like a hashmap but allows multiple instances of
   the same key in a container. */

let hashmmap_t = hashmmap_tag;
type hashmmap x::pointer = check_ptrtag hashmmap_t x;
hashmmapp x = pointerp x && check_ptrtag hashmmap_t x;

hashmmap x::nmatrix = hashmmap (smatrix x);

/* Note that in contrast to ordinary hashmaps, the complexity of the multimap
   equality check depends on the frequencies of keys and may thus require
   O(n^2) time in degenerate cases. */

x::hashmmap == y::hashmmap = hashmmap_equal x y;
x::hashmmap ~= y::hashmmap = ~hashmmap_equal x y;

/* Note that m!x returns the list of *all* values associated with the key x
   here (which may be empty if the key is not in the map, rather than raising
   an out_of_bounds exception). */

# m::hashmmap = hashmmap_size m;
m::hashmmap ! x = hashmmap_get m x;

/* Note that update and insert will never override an existing member of the
   map here, they will always insert a new member. Also, delete will delete an
   arbitrary member with the given key (or key=>val); there are no guarantees
   that members with the same key (or key=>val) will be deleted in any
   particular order. */

empty m::hashmmap = hashmmap_empty m;
member m::hashmmap (x=>y) = hashmmap_member2 m x y;
member m::hashmmap x = hashmmap_member m x;
update m::hashmmap x y = hashmmap_add2 m x y $$ m;
insert m::hashmmap (x=>y) = hashmmap_add2 m x y $$ m;
insert m::hashmmap x = hashmmap_add m x $$ m;
delete m::hashmmap (x=>y) = hashmmap_del2 m x y $$ m;
delete m::hashmmap x = hashmmap_del m x $$ m;

keys m::hashmmap = hashmmap_keys m;
vals m::hashmmap = hashmmap_vals m;

list m::hashmmap = hashmmap_list m;
tuple m::hashmmap = hashmmap_tuple m;
vector m::hashmmap = hashmmap_vector m;

do f m::hashmmap = do f (list m);
map f m::hashmmap = map f (list m);
catmap f m::hashmmap = catmap f (list m);
listmap f m::hashmmap = map f (list m);
listcatmap f m::hashmmap = catmap f (list m);
rowmap f m::hashmmap = rowcat (map f m);
rowcatmap f m::hashmmap = rowcat (map f m);
colmap f m::hashmmap = colcat (map f m);
colcatmap f m::hashmmap = colcat (map f m);

all p m::hashmmap = all p (list m);
any p m::hashmmap = any p (list m);
filter p m::hashmmap = filter p (list m);
foldl f a m::hashmmap = foldl f a (list m);
foldl1 f m::hashmmap = foldl1 f (list m) if ~empty m;
foldr f a m::hashmmap = foldr f a (list m);
foldr1 f m::hashmmap = foldr1 f (list m) if ~empty m;
scanl f a m::hashmmap = scanl f a (list m);
scanl1 f m::hashmmap = scanl1 f (list m) if ~empty m;
scanr f a m::hashmmap = scanr f a (list m);
scanr1 f m::hashmmap = scanr1 f (list m) if ~empty m;
sort p m::hashmmap = sort p (list m);
