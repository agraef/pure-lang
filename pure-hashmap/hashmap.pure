
/* hashmap.pure: mutable maps and sets for arbitrary key and value types,
   implemented as STL hashes */

/* NOTE: This module requires Pure 0.49 or later. It also needs a recent
   (C++11) STL implementation. The module is still experimental and the API is
   subject to change, so beware. */

/* Copyright (c) 2011 by Albert Graef <Dr.Graef@t-online.de>.

   This file is part of the Pure standard library.

   The Pure standard library is free software: you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
   more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */

/* Native interface. You can freely use most of these in addition to the
   "standard" container API provided below. But note that hashmap_free is
   reserved for internal use as a sentry on hashmap objects and should never
   be called directly. */

using "lib:hashmap";

extern int hashmap_tag();
extern void hashmap_symbol(expr*);
extern expr* hashmap(expr*);
extern hashmap* hashmap_copy(hashmap*);
extern void hashmap_clear(hashmap*);
extern void hashmap_free(hashmap*); // internal use only
extern void hashmap_add(hashmap*, expr*);
extern void hashmap_add2(hashmap*, expr*, expr*);
extern void hashmap_del(hashmap*, expr*);
extern expr* hashmap_get(hashmap*, expr*);
extern bool hashmap_member(hashmap*, expr*);
extern bool hashmap_empty(hashmap*);
extern bool hashmap_equal(hashmap*, hashmap*);
extern int hashmap_size(hashmap*);
extern expr* hashmap_list(hashmap*);
extern expr* hashmap_tuple(hashmap*);
extern expr* hashmap_vector(hashmap*);
extern expr* hashmap_keys(hashmap*);
extern expr* hashmap_vals(hashmap*);

/* The hashmap type. Hashmaps are simply pointers to STL hashed maps
   (unordered_map) which hold key-value associations where both keys and
   values may be arbitrary Pure expressions. They can be created from lists,
   tuples and vectors using the hashmap function. Memory management is
   automatic. Please also note the following:

   - Keys in a hashmap may be stored in an apparently random order (not
     necessarily in the order in which they were inserted).

   - Values can be omitted, so that hashmaps can also be used as a hashed set
     data structure. In this case, m!x will return the key x itself if it is
     in the hashmap. Likewise, vals m will return the keys for members which
     have no associated value. (The only downside of this approach is that you
     can't have a hash pair x=>y as a member of a set, since it always denotes
     a key-value association. Use ordinary pairs (x,y) instead.)

   - Hashmaps are *mutable*. Inserting a key into a hashmap or deleting it
     modifies the underlying STL data structure as a side effect of the
     operation. If you need value semantics, you should use one of the dict or
     set data structures from the standard library instead. (Another
     possibility is to take a copy of a hashmap using the hashmap_copy
     operation if you need to preserve the original value, but note that this
     operation takes O(n) time.)

   - Since hashmaps are pointers, two hashmaps are syntactically equal iff
     they are exactly the same object (identical pointer values). This test
     can be done in constant time. Use the semantic equality tests below if
     you need to test whether two hashmaps contain the same elements.

   - Hashmaps are pretty-printed in the format 'hashmap [...]' by default,
     which will reconstruct the expression when reentered as Pure code. With
     the hashmap_symbol function it is also possible to define a custom
     pretty-printing using a symbol of your choice (which should then be
     defined as appropriate). See examples/hashmap_examp.pure for an
     example. */

let hashmap_t = hashmap_tag;
type hashmap x::pointer = check_ptrtag hashmap_t x;
hashmapp x = pointerp x && check_ptrtag hashmap_t x;

// Make hashmap work with numeric vectors.
hashmap x::nmatrix = hashmap (smatrix x);

// Minimal container API for hashmaps.

# m::hashmap = hashmap_size m;
m::hashmap ! x =
  if hashmap_member m x then hashmap_get m x else throw out_of_bounds;

// FIXME: null doesn't work here because there's a generic definition for
// pointers in the prelude. For the time being, use empty instead.
empty m::hashmap = hashmap_empty m;
member m::hashmap x = hashmap_member m x;
update m::hashmap x y = hashmap_add2 m x y $$ m;
insert m::hashmap (x=>y) = hashmap_add2 m x y $$ m;
insert m::hashmap x = hashmap_add m x $$ m;
delete m::hashmap x = hashmap_del m x $$ m;

keys m::hashmap = hashmap_keys m;
vals m::hashmap = hashmap_vals m;

list m::hashmap = hashmap_list m;
tuple m::hashmap = hashmap_tuple m;
vector m::hashmap = hashmap_vector m;

// Basic list-like operations and support for list and matrix comprehensions.

do f m::hashmap = do f (list m);
map f m::hashmap = map f (list m);
catmap f m::hashmap = catmap f (list m);
listmap f m::hashmap = map f (list m);
listcatmap f m::hashmap = catmap f (list m);
rowmap f m::hashmap = rowcat (map f m);
rowcatmap f m::hashmap = rowcat (map f m);
colmap f m::hashmap = colcat (map f m);
colcatmap f m::hashmap = colcat (map f m);

/* Semantic equality of hashmaps. These compare both keys and values for
   syntactic equality. Equality holds iff two hashmaps contain the same
   key=>val pairs, irrespective of their ordering. For ordinary hashmaps, this
   check should work in O(n log n) time. Note that no submap comparisons
   (<, <=, etc.) are provided, as the STL doesn't have them either. But see
   examples/hashmap_examp.pure for a possible Pure implementation of these. */

x::hashmap == y::hashmap = hashmap_equal x y;
x::hashmap ~= y::hashmap = ~hashmap_equal x y;
