
/* Some basic examples for the hashmap module. This is intended to be fed to
   the interpreter in a piecemeal fashion (best done using "Send Current Line"
   in Emacs). To see the results, you can also run the script from the command
   line as follows: pure < hashmap_examp.pure

   In this directory you'll also find a log file of running the script through
   Pure. You can run the script and compare the results with the log to see
   whether the hashmap module works ok on your system. The Makefile has a
   target which does this for you; simply run 'make check' in the main source
   directory. */

using hashmap;

public foo bar baz; // free symbols used below

/* Create a hashmap and populate it with some Pure data. Both keys and values
   may be arbitrary Pure expressions. Note that in general the elements may be
   stored in an apparently random order (not necessarily the order in which
   they were inserted). */

let m = hashmap [foo=>99, bar=>bar 4711L, baz=>1..5]; m;

/* Note that hashmaps are printed using the format 'hashmap [key=>val,...]' by
   default, which reconstructs the value when used as a literal in Pure code.
   It is also possible to define a custom pretty-printing, using your own
   preferred symbol in place of 'hashmap'. In particular, the symbol may also
   be an outfix symbol so that hashmaps can be printed and entered in a
   bracketed format analogous to list and matrix notation. The following code
   shows how to make this work. To these ends, we introduce a nonfix symbol
   {$$} denoting the empty hashmap (note that this must be written as is, with
   no spaces between the "brackets"), and a corresponding pair of outfix
   symbols {$ $} which will be used to denote non-empty hashes. */

nonfix {$$};  // empty hashmap
outfix {$ $}; // hashmap brackets

// Define the above as macros which expand to proper hashmap values.
// NOTE: This needs the new built-in __list__ macro from Pure 0.49 or
// later. If you don't have this, you can substitute the list function for
// __list__, but then sets with tuple elements won't be parsed correctly.

def {$$} = hashmap [];
def {$ xs@(_,_) $} = hashmap (__list__ xs);
def {$ x $} = hashmap [x];

/* Now we can use the notation {$ key=>val, ... $} to enter hashmap literals
   in Pure code, and a call to the hashmap_symbol function also makes the
   hashmap pretty-printer use this notation. */

hashmap_symbol ({$ $});

let m = {$ foo=>99, bar=>bar 4711L, baz=>1..5 $}; m;

// Query the map.
m!bar;  // => bar 4711L
keys m; // => [foo,bar,baz]
vals m; // => [99,bar 4711L,[1,2,3,4,5]]
list m; // => [foo=>99,bar=>bar 4711L,baz=>[1,2,3,4,5]]

// Membership test.
member m foo, member m bar;

// Delete an element. Note that hashmaps are mutable, so you need to take a
// copy if you want to preserve the original value.
let m1 = copy m;
delete m foo; m1;
m!foo;  // => out_of_bounds exception
keys m; // => [bar,baz]
vals m; // => [bar 4711L,[1,2,3,4,5]]
list m; // => [bar=>bar 4711L,baz=>[1,2,3,4,5]]

member m foo, member m bar;

// Hashmaps can also be used in list and matrix comprehensions.
[x,y | x=>y = m1];
{x,y | x=>y = m1; listp y};

/* Note that, as hashmaps are really pointers, syntactic equality holds if and
   only if two hashmaps are exactly the same object. */

m===m, m===m1, m === copy m,
m === {$ bar=>bar 4711L,baz=>[1,2,3,4,5] $}; // => 1,0,0,0

/* The above can always be done in constant time but isn't very useful if you
   want to verify that two hashmaps contain the same key=>value associations.
   This can be done using the equality operation provided by the module. */

m==m, m==m1, m == copy m,
m == {$ bar=>bar 4711L,baz=>[1,2,3,4,5] $}; // => 1,0,1,1

/* Note that no submap comparisons are provided by the module. If you need
   them, here's one way to define them in Pure instead. A hashmap x is
   considered a submap of a hashmap y iff all key=>val pairs of x are also
   contained in y. */

x::hashmap <= y::hashmap = x===y ||
  (all (member y) xks && vals x === [y!k | k = xks] when xks = keys x end);
x::hashmap >= y::hashmap = x===y ||
  (all (member x) yks && vals y === [x!k | k = yks] when yks = keys y end);
x::hashmap <  y::hashmap = x<=y && #x<#y;
x::hashmap >  y::hashmap = x>=y && #x>#y;

m<=m1, m<m1, m>=m, m>m; // => 1,1,1,0

/* Hashmaps can also serve as a hashed set data structure which contains only
   keys but no values. In this case the value associated with a key defaults
   to the key itself. */

let m = {$ 99, bar 4711L, 1..5 $}; m;

member m 99;
m!99;
delete m 99;
member m 99;
m!99;
insert m 99;

// You can also mix singleton elements with ordinary key-value associations.
delete m (bar 4711L);
insert m (bar=>bar 4711L);
m!99;
m!bar;

/* Basic set-like operations like union, intersection etc. aren't provided by
   the module either, but you can easily implement them yourself as follows.
   Note that we take a copy of the first operand here in order to preserve
   value semantics. */

x::hashmap + y::hashmap = foldl insert (copy x) (list y);
x::hashmap - y::hashmap = foldl delete (copy x) (keys y);
x::hashmap * y::hashmap = x-(x-y);

let m1 = {$5,1,3,11,3$};
let m2 = hashmap (3..6);

m1;m2;
m1+m2; // => {$11,1,3,4,5,6$}
m1-m2; // => {$11,1$}
m1*m2; // => {$3,5$}

// These operations also work with general hashmaps, of course.
{$foo=>99,baz=>1..5$} + {$bar=>bar 4711L$};
