//Most of this file doesn't care about which headers you are scraping.
//It has functions to grab struct declarations as well as enums, even 
//though GL uses neither of these. They are included in here for use 
//in scraping headers for other libraries (SDL for instance)

const dumper = "./dump-ast"; 

using strings;
using system;
using dict;



nullary Nothing;

// Language.C AST terminals
nullary CVoidType;
nullary CCharType;
nullary CShortType;
nullary CIntType;
nullary CLongType;
nullary CFloatType;
nullary CDoubleType;
nullary CSignedType;
nullary CUnsigType;
nullary CBoolType;
nullary CStructTag;
nullary CUnionTag;
nullary CPlusOp;
nullary CMinOp ;
nullary CNegOp ;
nullary CAddOp ;
nullary CSubOp ;
nullary CMulOp ;
nullary CDivOp ;
nullary CRmdOp ;
nullary CShlOp ;
nullary CShrOp ;
nullary CLeOp  ;
nullary CGrOp  ;
nullary CLeqOp ;
nullary CGeqOp ;
nullary CEqOp  ;
nullary CNeqOp ;
nullary CAndOp ;
nullary COrOp  ;
nullary CLndOp ;
nullary CLorOp ;
nullary CXorOp ;


nullary unknown_decl_type;
nullary not_found;

//these mirror the ffi type values
nullary void_t;
nullary uint8_t;
nullary sint8_t;
nullary uint16_t;
nullary sint16_t;
nullary uint32_t;
nullary sint32_t;
nullary uint64_t;
nullary sint64_t;
nullary float_t;
nullary double_t;
nullary pointer_t;
nullary uchar_t;
nullary schar_t;
nullary ushort_t;
nullary sshort_t;
nullary uint_t;
nullary sint_t;
nullary ulong_t;
nullary slong_t;

// to_ffi_type does a preliminary conversion from Language.C types (types
// specified in the C spec) to ffi types (real types on the machine.)
// short, long, signed and unsigned can also be used as modifiers, 
// in which case the _t suffix is dropped.

to_ffi_type x =
  case x of
  //these come from Language.C
  CVoidType     = void_t;
  CCharType     = schar_t;
  CShortType    = sshort_t;
  CIntType      = sint_t;
  CLongType     = slong_t;
  CFloatType    = float_t;
  CDoubleType   = double_t;
  CSignedType   = sint_t;
  CUnsigType    = uint_t;
  CBoolType     = sint_t; //??? char?
  CTypeDef str  = CTypeDef str; //these are resolved in a second pass
  CSUType (CStructUnion _ (Just tag) _ _) = struct_or_union tag;
  CSUType (CStructUnion _ Nothing _ _) = struct_or_union "anonymous";
  _             = (puts $ "to_ffi_type error : " + str x) $$ void_t;
  end;


// pure_type takes an ffi type and makes a string suitable for a pure
// extern declaration

//these mirror the ffi type values
pure_type t =
  case t of
  void_t     = "void";
  uint8_t    = "char";
  sint8_t    = "char";
  uint16_t   = "short";
  sint16_t   = "short";
  uint32_t   = "int";
  sint32_t   = "int";
  uint64_t   = "long";
  sint64_t   = "long";
  float_t    = "float";
  double_t   = "double";
  pointer_t  = "void*";
  uchar_t    = "char";
  schar_t    = "char";
  ushort_t   = "short";
  sshort_t   = "short";
  uint_t     = "int";
  sint_t     = "int";
  ulong_t    = "int";
  slong_t    = "int";
  ptr_type (func_type _ _) = "void*";
  ptr_type t = pure_type t + "*";
  _          = puts ("pure_type error : "+str t) $$ "void";
  end;


// complete_ffi_type finishes the conversion by collecting typespecifiers such
// as long, unsigned, etc. This also strips away the "basic_type" specifier,
// which is used mostly for typedef resolution.

complete_ffi_type (basic_type x)  = complete_ffi_type x;



// ffi only knows "pointer_t" but pure's extern decls can take typed pointers
//complete_ffi_type (ptr_type _)    = pointer_t; 
complete_ffi_type (ptr_type t) = ptr_type ( complete_ffi_type t );

complete_ffi_type (func_type r a) = func_type (complete_ffi_type r)
                                            (map complete_ffi_type a);
complete_ffi_type (structure n f) = 
  structure n (zip ns (map complete_ffi_type fs))
  when (ns,fs) = unzip f end;

complete_ffi_type x =
  case x of
  //this is kind of a mess, due to all the different ways one might 
  //specify an int: int, long int, long, singed long, signed long int...
  void_t   = void_t;
  schar_t  = schar_t;
  sshort_t = sshort_t;
  slong_t  = slong_t;
  sint_t   = sint_t;
  uint_t   = uint_t;
  (long (sint_t))      = slong_t; 
  (long (slong_t))     = sint64_t; 
  (long (long sint_t)) = sint64_t; 
  float_t  = float_t;
  double_t = double_t;
  signed schar_t    = schar_t;  
  signed sshort_t   = sshort_t; 
  signed sint_t     = sint_t;   
  signed slong_t    = sint_t;
  signed (long (slong_t))     = sint64_t; 
  signed (long (long sint_t)) = sint64_t; 
  unsigned schar_t  = uchar_t;  
  unsigned sshort_t = ushort_t; 
  unsigned sint_t   = uint_t; 
  unsigned slong_t  = uint_t; 
  unsigned (long (sint_t))      = ulong_t; 
  unsigned (long (slong_t))     = uint64_t; 
  unsigned (long (long sint_t)) = uint64_t; 
  
  _ = puts ("complete_ffi_type: unknown type "+str x+", defaulting to void") 
        $$ void_t;

  end;
   
  


// The primitive type of a declaration. Returns an ffi type, with specifiers.
type_spec ( (CTypeQual _) : more ) = type_spec more;
  //skip things like const, volatile, etc.

type_spec ( (CTypeSpec CShortType) :  []  ) = sshort_t;
type_spec ( (CTypeSpec CShortType) : more ) = short $ type_spec more;

type_spec ( (CTypeSpec CLongType) :  []  ) = slong_t;
type_spec ( (CTypeSpec CLongType) : more ) = long $ type_spec more;

type_spec ( (CTypeSpec CUnsigType) :  []  ) = uint_t;
type_spec ( (CTypeSpec CUnsigType) : more ) = unsigned $ type_spec more;

type_spec ( (CTypeSpec CSignedType) :  []  ) = sint_t;
type_spec ( (CTypeSpec CSignedType) : more ) = signed $ type_spec more;

type_spec ( (CTypeSpec t) : _ ) = to_ffi_type t; 
 //I don't really know what else could be in the list here

type_spec ( _ : more ) = type_spec more;
type_spec [] = throw unknown_decl_type;



// decl_type : Grab a simplified type representation from a declaration.
// Result is a list of the following terms: 
//    basic_type t      : t is a c primitive type or a typedef
//    ptr_type t        : t is again one of basic_type, ptr_type or func_type
//    func_type ret args: ret is again one basic_type, ptr_type or func_type, 
//                        and args is a list of such terms.
// If the type cannot be described in the above terms, an exception
// "unknown_decl_type" is thrown.
// 
// The returned list contains one type for each object declared in this
// declaration, e.g. "int *x, y;" yields 
// [ ptr_type(basic_type sint_t), basic_type sint_t ]

decl_types (CDeclExt d _) = decl_types d ;

decl_types d@(CDecl decl_specs [] ) = [ basic_type (type_spec decl_specs) ];
decl_types d@(CDecl decl_specs init_declr_list ) = decl_types2 d;

decl_types2 d@(CDecl decl_specs init_declr_list) = 
  case init_declr_list of 
    (Just (CDeclr _ derivs _ arg_attrs), Nothing, Nothing) : more =
        apply_derivs (type_spec decl_specs) derivs : decl_types2 (CDecl decl_specs more);
    [] = [];
    _ = [];
  end
  with 
    //basic_type : get the type of a declaration, ignoring storage and access
    //modifiers
    apply_derivs t [] = basic_type t;
    apply_derivs t ( (CPtrDeclr _  ) : derivs ) |
    apply_derivs t ( (CArrDeclr _ _) : derivs ) = //treat arrays as pointers, 
      ptr_type $ apply_derivs t derivs;           //even if they are proper array objects
    apply_derivs t ( (CFunDeclr args _) : derivs ) = 
      case args of 
        Right (arg_decls,_) = 
          func_type (apply_derivs t derivs) (catmap decl_types arg_decls);
        Left _      = //old-style K&R declaration.
          throw unknown_decl_type;
      end;
  end;



// decl_idents : Grab the names of things declared in a declaration. Returns a
// list of strings (identifiers) which may be empty the the declaration is
// anonymous (i.e., a function parameter) or may contain multiple identifiers
// if the declaration declares multiple things, e.g. "int x,y,z;"

decl_idents (CDeclExt d _) = decl_idents d;
decl_idents d@(CDecl _ init_declr_list) = 
  case init_declr_list of 
    (Just (CDeclr (Just ident) _ _ _), _, _) : more =
        ident : decl_idents (CDecl decl_specs more);
    _ = [];
  end;



is_typedef ( (CStorageSpec CTypedef) : decl_specs) = 1;
is_typedef ( _ : decl_specs) = is_typedef decl_specs;
is_typedef [] = 0;


// typedef : returns a list of (name=>type) bindings, possibly empty if this
// declaration was not a typedef
typedefs (CDeclExt d _) = typedefs d;
typedefs d@(CDecl decl_specs _) =
  if is_typedef decl_specs 
  then zip (decl_idents d) (decl_types d)
  else [];


// func_decl : returns a list containing a single (name,type) binding if
// this declaration declares a function, otherwise [].
func_decl (CDeclExt d _) = func_decl d;
func_decl d@(CDecl _ _) =
  case decl_types d of
    f@([func_type ret args]) = zip (decl_idents d) f;
    _ = [];
  end;

//resolve a typedef : d is a dictionary 
resolve_typedef d t = lookup t
  with
    lookup (basic_type (CTypeDef n)) =
      catch ( \_ -> puts $ "could not resolve typedef: "+n+
                           ", defaulting to int" $$ sint_t  ) 
            ( lookup (d!n) );

    lookup (basic_type (CSUType _ (CStructUnion _ (Just name) _ _))) = 
      basic_type (struct_or_union name);
    lookup t@(struct_or_union n) = t;
    lookup (basic_type (CEnumType n)) = sint_t;
    lookup t@(basic_type _) = t;
    lookup (ptr_type t) = ptr_type (lookup t);
    lookup (func_type ret args) = func_type (lookup ret) (map lookup args);
    lookup x = puts ("resolve_typedef error: "+str x) $$ void_t;
  end;
    
resolve_decl_typedefs tydefs decls = 
  map (\(n,t) -> (n , resolve_typedef tydefs t) ) decls;

resolve_struct_typedefs tydefs (structure name fields) = 
  structure name $ resolve_decl_typedefs tydefs fields;





// Gather the declared structs or unions. C allows structs to be declared just
// about anywhere but we only grab them from three toplevel declarations:
//   struct X { .. };
//   typedef struct Y { .. } X;
//   typedef struct { .. } X;
// In any case, the struct is bound to the name X.
//
// The result is either [] or [structure name fields] where
// fields are a list of (name,type) tuples
//
// Does not handle nested structs or unions yet.

decl_struct (CDeclExt d _) = decl_struct d;
decl_struct d@(CDecl ( (CStorageSpec CTypeDef ) : 
                       (CTypeSpec (CSUType strct)) : _ ) 
                     init_declr_list) 
    =
  case strct of
    //struct name
    CStructUnion _ (Just _) (Just fields) _  | //struct has a tag
    CStructUnion _ Nothing (Just fields)  _  = //struct is anonymous. 
      [ structure name $ 
        zip (catmap decl_idents fields) (catmap decl_types fields) ];
    _ = [];
  end
  when 
    name = head $ decl_idents d;
  end;

decl_struct d@(CDecl ( (CTypeSpec (CSUType strct)) : _ ) [] ) =
  case strct of
    CStructUnion _ (Just name) (Just fields) _  = 
      [ structure name $ 
        zip (catmap decl_idents fields) (catmap decl_types fields) ];
    _ = [];
  end;

decl_struct d = [];
  


  
// Scrape enum constants. Takes a list of top-level declarations (CDeclExt)
// and produces a dictionary of name=>value pairs. This has to be run over the
// whole list because some constants will be defined in terms of others. 
decl_enums = 
  foldl get_enum emptydict;

get_enum dict (CDeclExt d _) = get_enum dict d;

get_enum dict d@(CDecl ( (CStorageSpec CTypeDef ) : 
                         (CTypeSpec (CEnumType enum)) : _ ) 
                       init_declr_list) 
    =
  case enum of
    CEnum _ (Just vals) _ = calc_enum_values dict () vals
  end ;
  
get_enum dict d@(CDecl ( (CTypeSpec (CEnumType enum)) : _ ) []) =
  case enum of
    CEnum _ (Just vals) _ = calc_enum_values dict () vals
  end;

get_enum dict _ = dict;


calc_enum_values dict prev ((name,Just e):more) = 
  case eval_expr dict e of
    val::int = calc_enum_values (insert dict (name => val)) val more;
    x = puts $ "Couldn't evaluate enum expression for "+name+" : "+str e 
          $$ calc_enum_values dict prev more;
  end;

calc_enum_values dict () ((name,Nothing):more) = 
   calc_enum_values (insert dict (name=>0)) 0 more;

calc_enum_values dict prev ((name,Nothing):more) = 
    calc_enum_values (insert dict (name=>(prev+1))) (prev+1) more;
 
calc_enum_values dict _ [] = dict;

eval_expr d (CVar n) = 
  catch 
  (\e  -> 
    puts$"Couldn't lookup name "+n+" in enum definition. Defaulting to 0."$$0
  ) (d!n);

eval_expr d (CConst (CIntConst x)) = x;

eval_expr d (CUnary  CPlusOp x) =     eval_expr d x;
eval_expr d (CUnary  CMinOp x) = neg (eval_expr d x);
eval_expr d (CUnary  CNegOp x) = not (eval_expr d x);

eval_expr d (CBinary CAddOp e1 e2) = (eval_expr d e1) +   (eval_expr d e2);
eval_expr d (CBinary CSubOp e1 e2) = (eval_expr d e1) -   (eval_expr d e2);
eval_expr d (CBinary CMulOp e1 e2) = (eval_expr d e1) *   (eval_expr d e2);
eval_expr d (CBinary CDivOp e1 e2) = (eval_expr d e1) /   (eval_expr d e2);
eval_expr d (CBinary CRmdOp e1 e2) = (eval_expr d e1) mod (eval_expr d e2);
eval_expr d (CBinary CShlOp e1 e2) = (eval_expr d e1) <<  (eval_expr d e2);
eval_expr d (CBinary CShrOp e1 e2) = (eval_expr d e1) >>  (eval_expr d e2);
eval_expr d (CBinary CLeOp  e1 e2) = (eval_expr d e1) <   (eval_expr d e2);
eval_expr d (CBinary CGrOp  e1 e2) = (eval_expr d e1) >   (eval_expr d e2);
eval_expr d (CBinary CLeqOp e1 e2) = (eval_expr d e1) <=  (eval_expr d e2);
eval_expr d (CBinary CGeqOp e1 e2) = (eval_expr d e1) >=  (eval_expr d e2);
eval_expr d (CBinary CEqOp  e1 e2) = (eval_expr d e1) ==  (eval_expr d e2);
eval_expr d (CBinary CNeqOp e1 e2) = (eval_expr d e1) ~=  (eval_expr d e2);
eval_expr d (CBinary CAndOp e1 e2) = (eval_expr d e1) &&  (eval_expr d e2);
eval_expr d (CBinary COrOp  e1 e2) = (eval_expr d e1) ||  (eval_expr d e2);
eval_expr d (CBinary CLndOp e1 e2) = (eval_expr d e1) and (eval_expr d e2);
eval_expr d (CBinary CLorOp e1 e2) = (eval_expr d e1) or  (eval_expr d e2);
eval_expr d (CBinary CXorOp e1 e2) = xor (eval_expr d e1) (eval_expr d e2)
  with 
  xor a b = (a and not b) or (not a and b); // why exclude poor xor?
  end;
                  






// Grab all #define'd constants. lns is a list of strings, the 
// lines of the file. Thus, this can't deal with #defines that span
// multiple lines.
scrape_defines lns = 
  foldr 
    (\ln out -> 
      case catmap (split_ "\t") $ split_ " " ln of
        [define,name,val] =
          case define of
            "#define" = 
              // If val is a number (in hex) then its a Constant.  If val is a
              // string, then its probably another #define'd constant, so call
              // it indirect.
              catch 
                ( \_ -> catch 
                    (\_ -> (puts $ "Can't parse "+ln) $$ out)
                    ( indirect name (sscanf val "%s") : out ) )
                ( constant name (sscanf val "%x") : out );
            _ = out;
          end;
        _ = out;
      end
    ) [] lns;


// Some constants are defined in terms of others.  Here we resolve those
// indirections.
resolve_indirects constants =
  filter (\i -> case i of not_found = 0; _ = 1; end) $
    map (lookup dict) constants 
  when
    dict = foldl build emptydict constants;
  end
  with
  build d i@(indirect n _) = 
    /*puts ("adding ["+n+"] to dict") $$*/ 
    insert d (n=>i) ;
  build d c@(constant n _) = 
    /*puts ("adding ["+n+"] to dict") $$*/ 
    insert d (n=>c) ;
  lookup _ c@(constant _ _) = c;
  lookup d (indirect n c) = 
    catch
      (\_ -> 
          puts $ "Target of indirected constant not found: \""+
                 n+"\" => \""+c+"\"" $$ 
          not_found )
      ( case d!c of
        (constant _ v) = constant n v;
        (indirect _ i) = lookup d i; 
        end );
  end;





// Output a constant declaration.
// If after stripping the prefix the constant name starts with a number, then
// add a leading underscore.
const_decl pfx nmspace (constant name val) = 
  case strip_prefix pfx name of
    name =
      if regex "^[0-9]" REG_NOSUB name 0 
        then "const "+nmspace+"::_"+name+" = "+str val+";\n"
        else "const "+nmspace+"::"+name+" = "+str val+";\n"
      ;
  end;

//output a function declaration for the ffi interface
ffi_extern_decl pfx::string nmspace::string (name, func_type ret args) =
  "let "+nmspace+"::"+strip_prefix pfx name+" = fcall \""+
    name+"\" FFI_DEFAULT_ABI "+str ret+" ("+str(tuple args)+");\n";

//output a function declaration for the native pure extern interface
pure_extern_decl pfx::string nmspace::string (name, func_type ret args) =
  "extern "+pure_type ret+" "+name+"("+arg_str args+") = "+
    strip_prefix pfx name+";"
  with
  arg_str [void_t] = "";
  arg_str args = join "," $ map pure_type args;
  end;

//output a function declaration for the native pure extern interface,
//appending the prefix "PureGL_" to the function name
PureGL_extern_decl pfx::string nmspace::string (name, func_type ret args) =
  "extern "+pure_type ret+" PureGL_"+name+"("+arg_str args+") = "+
    strip_prefix pfx name+";"
  with
  arg_str [void_t] = "";
  arg_str args = join "," $ map pure_type args;
  end;




//output the C portion of a function
//TODO: at this point the GL typedefs have been resolved. It would be better
//if they were not.
c_impl (name, func_type ret args) = 
ret_str+" PureGL_"+name+"("+formal_params+") {\n"+
"  static "+ret_str+"(APIENTRY*ptr)("+arg_types+") = NULL;\n"+
"  static const char name[] = \""+name+"\";\n"+
"  if (!ptr) {\n"+
"    ptr = ("+ret_str+"(APIENTRY*)("+arg_types+"))get_proc_addr(name);\n"+
"    if (!ptr) throw_unsupported(name);\n"+
"  }\n"+
"  return (*ptr)("+arg_names+");\n}\n\n"
  when
    ret_str = pure_type ret;

    formal_params = 
      if args === [void_t] then "" else 
      join ", " $ zipwith (\x y -> pure_type x+" arg"+str y) args (0..inf);

    arg_names = 
      if args === [void_t] then "" else 
      join "," $ map (\y -> "arg" + str y) (take (#args) (0..inf));

    arg_types = 
      if args === [void_t] then "" else 
      join "," $ map pure_type args;
    
  end;


//shunt constant and function declarations to various output files based on a
//regex match
matches_regex pat (constant name _) = regex pat REG_NOSUB name 0;
matches_regex pat (name, _) = regex pat REG_NOSUB name 0;



//misc helpful stuff


//get all lines in a file
fgetlines f = reverse $ get [] 
  with 
  get a = 
    case fgets f of 
    s::string = get (s:a); 
    _ = a; 
    end 
  end;

//a better split
split_ delim s = filter (\s -> s ~= "") $ split delim s;

//inverse of split
join sep (x:y:z) = join sep ((x+sep+y):z);
join _ [x] = x ;
join _ [] = "";

strip_prefix pfx::string str::string = substr str (#pfx) (#str);


//need these for nub
constant a _ < constant b _ = a < b;
constant a _ > constant b _ = a > b;
constant a _ == constant b _ = a == b;

nub xs = reverse $ go [] emptydict xs
  with
  go a d (x:xs) = go a d xs if member d x;
                = go (x:a) (insert d (x=>x)) xs otherwise;
  go a _ [] = a;
  end;


//////////////////////// everything above is generic ///////////////
//////////////////////// everything below is specific to GL ////////




let gl_h    = fgetlines $ fopen "gl.h" "r";
let glu_h   = fgetlines $ fopen "glu.h" "r";
let glext_h = fgetlines $ fopen "glext.h" "r";
//let glut_h  = fgetlines $ fopen "glut.h" "r";
let glut_h  = fgetlines $ fopen "freeglut_std.h" "r";
// check whether we want the freeglut extensions
let glutext_h  = if pointerp fp then fgetlines fp else []
when fp = fopen "freeglut_ext.h" "r" end;




is_extension =
matches_regex 
"\\(EXT\\|ARB\\|NV\\|ATI\\|APPLE\\|SGI\\|SGIS\\|SGIX\\|3DFX\\|SUN\\|SUNX\\|\
MESA\\|INTEL\\|IBM\\|GREMEDY\\|HP\\|PGI\\|INGR\\|S3TC\\|OML\\|OES\\)$" ;


//the AST of all gl/glu/glut

puts "Loading AST";
// check whether we want the freeglut extensions
if null glutext_h then system(dumper+" all_gl.h > all_gl.ast")
else system(dumper+" all_gl_ext.h > all_gl.ast");
let ast = fgetlines $ fopen "all_gl.ast" "r";

puts "Parsing";
let declarations = filter ((~=) ()) $ map eval ast;

puts "Building typedef dictionary";
let tydefs = 
      foldl (\d (n,t) -> insert d (n=>t)) emptydict $
        catmap typedefs declarations;


puts "Building #define dictionary";
let defines = 
  nub $ resolve_indirects $ catmap scrape_defines $ 
    [gl_h,glext_h,glu_h,glut_h,glutext_h];

puts "Gathering function prototypes";
//all function prototypes (gl, glu and glut)
let func_protos =
      mapsnd complete_ffi_type $
        resolve_decl_typedefs tydefs $
          catmap func_decl declarations
  with
    mapsnd f = map (\(a,b) -> a,f b)
  end;



//Output the C part
system("cat pure-gl.c.fragment > pure-gl.c");
let out_c = fopen "pure-gl.c" "a";
puts "Writing C module";

do (flip fputs out_c) $
  map c_impl $
  filter (matches_regex "^gl\\(u\\|ut\\)\\?[A-Z]") func_protos;


//OpenGL proper
let out_gl   = fopen "GL.pure" "w";
puts "Writing GL.pure";
//fputs "using ffi;\n" out_gl;
//fputs "using \"lib:libGL\";\n" out_gl;
fputs "using \"lib:pure-gl\";\n" out_gl;
fputs "\n\nnamespace GL;\n" out_gl;

do (flip fputs out_gl . const_decl "GL_" "GL") $
  filter ((~) . is_extension) $
  filter ((~) . matches_regex "[a-z]") $ //normal enums should be all uppercase
  filter (matches_regex "^GL_") defines;

do (flip fputs out_gl) $
  map (\x -> PureGL_extern_decl "gl" "GL" x + "\n") $
  filter ((~) . is_extension) $
  filter (matches_regex "^gl[A-Z]") func_protos;


//ARB extensions
let out_gl   = fopen "GL_ARB.pure" "w";
puts "Writing GL_ARB.pure";
//fputs "using ffi;\n" out_gl;
//fputs "using \"lib:libGL\";\n" out_gl;
fputs "using \"lib:pure-gl\";\n" out_gl;
fputs "\n\nnamespace GL;\n" out_gl;

do (flip fputs out_gl . const_decl "GL_" "GL") $
  filter (matches_regex "ARB$") $
  filter ((~) . matches_regex "[a-z]") $ //normal enums should be all uppercase
  filter (matches_regex "^GL_") defines;

do (flip fputs out_gl) $
  map (\x -> PureGL_extern_decl "gl" "GL" x + "\n") $
  filter (matches_regex "^gl[A-Z][A-Za-z1-9]*ARB$") func_protos;


//EXT extensions
let out_gl   = fopen "GL_EXT.pure" "w";
puts "Writing GL_EXT.pure";
//fputs "using ffi;\n" out_gl;
//fputs "using \"lib:libGL\";\n" out_gl;
fputs "using \"lib:pure-gl\";\n" out_gl;
fputs "\n\nnamespace GL;\n" out_gl;

do (flip fputs out_gl . const_decl "GL_" "GL") $
  filter (matches_regex "EXT$") $
  filter ((~) . matches_regex "[a-z]") $ 
  filter (matches_regex "^GL_") defines;

do (flip fputs out_gl) $
  map (\x -> PureGL_extern_decl "gl" "GL" x + "\n") $
  filter (matches_regex "^gl[A-Z][A-Za-z1-9]*EXT$") func_protos;



//NV extensions
let out_gl   = fopen "GL_NV.pure" "w";
puts "Writing GL_NV.pure";
//fputs "using ffi;\n" out_gl;
//fputs "using \"lib:libGL\";\n" out_gl;
fputs "using \"lib:pure-gl\";\n" out_gl;
fputs "\n\nnamespace GL;\n" out_gl;

do (flip fputs out_gl . const_decl "GL_" "GL") $
  filter (matches_regex "NV$") $
  filter ((~) . matches_regex "[a-z]") $
  filter (matches_regex "^GL_") defines;

do (flip fputs out_gl) $
  map (\x -> PureGL_extern_decl "gl" "GL" x + "\n") $
  filter (matches_regex "^gl[A-Z][A-Za-z1-9]*NV$") func_protos;



//ATI extensions
let out_gl   = fopen "GL_ATI.pure" "w";
puts "Writing GL_ATI.pure";
//fputs "using ffi;\n" out_gl;
//fputs "using \"lib:libGL\";\n" out_gl;
fputs "using \"lib:pure-gl\";\n" out_gl;
fputs "\n\nnamespace GL;\n" out_gl;

do (flip fputs out_gl . const_decl "GL_" "GL") $
  filter (matches_regex "ATI$") $
  filter ((~) . matches_regex "[a-z]") $
  filter (matches_regex "^GL_") defines;

do (flip fputs out_gl) $
  map (\x -> PureGL_extern_decl "gl" "GL" x + "\n") $
  filter (matches_regex "^gl[A-Z][A-Za-z1-9]*ATI$") func_protos;



//GLU
let out_glu  = fopen "GLU.pure" "w";
puts "Writing GLU.pure";
//fputs "using ffi;\n" out_glu;
//fputs "using \"lib:libGLU\";\n" out_glu;
fputs "using \"lib:pure-gl\";\n" out_glu;
fputs "\n\nnamespace GLU;\n" out_glu;

do (flip fputs out_glu . const_decl "GLU_" "GLU") $
  filter (matches_regex "^GLU_") defines;

do (flip fputs out_glu) $
  map (\x -> PureGL_extern_decl "glu" "GLU" x + "\n") $
  filter (matches_regex "^glu[A-Z]") func_protos;



//GLUT
let out_glut = fopen "GLUT.pure" "w";
puts "Writing GLUT.pure";
//fputs "using ffi;\n" out_glut;
//fputs "using \"lib:libglut\";\n" out_glut;
fputs "using \"lib:pure-gl\";\n" out_glut;
fputs "\n\nnamespace GLUT;\n" out_glut;

do (flip fputs out_glut . const_decl "GLUT_" "GLUT") $
  filter (matches_regex "^GLUT_") defines;

do (flip fputs out_glut) $
  map (\x -> PureGL_extern_decl "glut" "GLUT" x + "\n") $
  filter (matches_regex "^glut[A-Z]") func_protos;
