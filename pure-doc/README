
========
pure-doc
========

:Author: Albert Graef <Dr.Graef@t-online.de>
:License: GPL V3, see the accompanying COPYING file

.. |RST| replace:: reStructuredText
.. _RST: http://docutils.sourceforge.net/rst.html
.. _docutils: http://docutils.sourceforge.net

pure-doc is a simple utility for literate programming and documenting source
code written in the Pure programming language. It is supposed to be used with
the excellent docutils_ tools and the gentle markup format supported by these,
called RST_ a.k.a. "|RST|", usually pronounced "rest".

The basic idea is that you just comment your code as usual, but using RST
markup instead of plain text. In addition, you can also designate literate
programming fragments in your code, which will be translated to RST literal
blocks automatically. You then run pure-doc on your source files to extract
all marked up comments and the literate code blocks. The resulting RST source
can then be processed with the docutils utilities like rst2html.py and
rst2latex.py to create the documentation in a variety of formats.

.. contents::

Installation
============

Just do the customary ``make && sudo make install``. This only needs flex and
a standards-compliant C++ compiler.

Usage
=====

First, see the description of the RST_ format. RST is a very simple markup
format, almost like plain text (in fact, you're looking at RST right now, this
README is written in it!). You can learn enough of it to start marking up your
source in about five minutes.

Second, you'll have to mark up your source comments. pure-doc recognizes
comments in RST format by looking at the first non-empty line of the
comment. A comment (either ``/* ... */`` or a contiguous sequence of ``//``
line comments) is assumed to contain RST format if the first non-empty line
starts with ``:``, ``..`` or ``__``. Other comments are taken to be plain text
and are ignored by pure-doc.

Notes:

* pure-doc makes no other assumption about the contents of marked up comments,
  so you can include whatever you want: titles, section headers, fields, plain
  text, whatever. Just make sure that the comment starts with one of the
  special tokens listed above. (You can always put just ``..`` at the
  beginning of the comment to force it to be recognized, this will be treated
  as a comment by the docutils tools.)

* Also, pure-doc makes very few assumptions about the source; in fact, any
  source files with a C/C++-like comment and string syntax should work. So you
  could also use it to document your C/C++ programs, or even plain text files
  like this one, as long as they adhere to these standards.

* Indentation in extracted comments is preserved (assuming tabs = 8 spaces,
  you can change this in pure-doc.ll).  This is important because indentation
  conveys document structure in RST.

For instance, here is a sample RST-formatted comment::

  /* :Name: ``rand`` - compute random numbers
     :Synopsis: ``rand``
     :Description: Computes a (pseudo) random number. Takes no parameters.
     :Example: Here is how you can call ``rand`` in Pure:
       ::

         > extern int rand();
         > rand;
         1804289383

     :See Also: rand(3) */

Finally, you run pure-doc on your source files as follows::

  pure-doc source-files ...

If no input files are specfied then the source is read from standard
input. Otherwise all input files are read and processed in the indicated
order. The output is written to stdout, so that you can directly pipe it into
one of the docutils programs::

  pure-doc source-files ... | rst2html.py

If you prefer to write the output to a file, you can do that as follows::

  pure-doc source-files ... > rst-file

There are no other options, but the docutils programs offer plenty of options
to change the formatting of the output; please refer to the docutils_
documentation for details.

Literate Programming
====================

pure-doc also recognizes literate code delimited by comments which, besides
the comment delimiters and whitespace, contain nothing but the special start
and end "tags" ``>>>`` and ``<<<``. Code between these delimiters (including
all comments) is extracted from the source and output as a RST literal code
block.

For instance::

  /* ..

     pure-doc supports literate programming, too: */

  // >>>

  // This is a literate comment.
  /* .. This too! */

  extern int rand();
  rand;

  // <<<

Try it now! You can scrape all the documentation from this file and format it
as html, as follows::

  pure-doc README | rst2html.py --no-doc-title --no-doc-info > test.html

As already mentioned, this README itself is also in RST format, so you can
also do the following to get nicely formatted documentation::

  rst2html.py README pure-doc.html

(You can also just type ``make html`` to get this.)

Generating Documentation
========================

If you're generating some library documentation for which you have to process
a bigger collection of source files, then it is often convenient to have a few
Makefile rules to automatize the process. To these ends, simply add rules
similar to the following to your Makefile::

  # The sources. Order matters here. The generated documentation will have the
  # comments from each source file in the indicated order.
  sources = foo.pure bar.pure

  # The basename of the documentation files to be generated.
  target = foo

  .PHONY: html tex pdf

  html: $(target).html
  tex: $(target).tex
  pdf: $(target).pdf

  $(target).txt: $(sources)
          pure-doc $(sources) > $@

  # This requires that you have docutils installed.

  %.html: %.txt
          rst2html.py $< $@

  %.tex: %.txt
          rst2latex.py $< $@

  # This also requires that you have TeX installed.

  %.pdf: %.tex
          pdflatex $<
          rm -f *.aux *.log *.out

  clean:
          rm -f *.html *.tex *.pdf

(This assumes GNU make. If you use some other make utility then you will have
to adapt the pattern rules accordingly.)

Now you can just type ``make`` or ``make html`` to generate the documentation
in html format, and ``make tex`` or ``make pdf`` to generate the other
formats. The ``clean`` target removes the generated files.

Installing Documentation
========================

Now that you generated the documentation for your Pure library, you might want
to make the Pure interpreter know about it, so that you can read your
documentation with the ``help`` command of the interpreter. This isn't
difficult either. You just install the html files on the Pure library
path. The following Makefile rule automatizes this process. Add this to the
Makefile in the previous section::

  # Try to guess the installation prefix (this needs GNU make):
  prefix = $(patsubst %/bin/pure,%,$(shell which pure 2>/dev/null))
  ifeq ($(strip $(prefix)),)
  # Fall back to /usr/local.
  prefix = /usr/local
  endif

  libdir = $(prefix)/lib
  datadir = $(libdir)/pure

  install:
          test -d "$(DESTDIR)$(datadir)" || mkdir -p "$(DESTDIR)$(datadir)"
          cp $(target).html "$(DESTDIR)$(datadir)"

After a ``make install`` your documentation should now end up in the Pure
library directory, and you can read it in the Pure interpreter using a
command like the following::

  > help foo#

For a concrete example, you can find all this and more in pure-doc's own
Makefile. In fact, after installation this README ends up as pure-doc.html in
the Pure library directory, so that you can read it with::

  > help pure-doc#

Note the hash character. This tells the ``help`` command that this is an
auxiliary documentation file, rather than a function name to be looked up in
the Pure Library Manual. You can also look up a specific section in the
pure-doc manual as follows::

  > help pure-doc#literate-programming

Please also refer to the Pure Manual for more information on how to use the
interpreter's online help.
