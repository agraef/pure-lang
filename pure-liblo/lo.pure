/* /usr/include/lo/lo.h: */
using "lib:lo";

namespace lo;
const lo::ENOPATH = 9901;
const lo::ENOTYPE = 9902;
const lo::UNKNOWNPROTO = 9903;
const lo::NOPORT = 9904;
const lo::TOOBIG = 9905;
const lo::INT_ERR = 9906;
const lo::EALLOC = 9907;
const lo::EINVALIDPATH = 9908;
const lo::EINVALIDTYPE = 9909;
const lo::EBADTYPE = 9910;
const lo::ESIZE = 9911;
const lo::EINVALIDARG = 9912;
const lo::ETERM = 9913;
const lo::EPAD = 9914;
const lo::EINVALIDBUND = 9915;
const lo::EINVALIDTIME = 9916;
const lo::MAX_MSG_SIZE = 32768;
const lo::DEFAULT = 0;
const lo::UDP = 1;
const lo::UNIX = 2;
const lo::TCP = 4;
const lo::INT32 = 105;
const lo::FLOAT = 102;
const lo::STRING = 115;
const lo::BLOB = 98;
const lo::INT64 = 104;
const lo::TIMETAG = 116;
const lo::DOUBLE = 100;
const lo::SYMBOL = 83;
const lo::CHAR = 99;
const lo::MIDI = 109;
const lo::TRUE = 84;
const lo::FALSE = 70;
const lo::NIL = 78;
const lo::INFINITUM = 73;
extern int lo_send_message(void*, char*, void*) = send_message;
extern int lo_send_message_from(void*, void*, char*, void*) = send_message_from;
extern int lo_send_bundle(void*, void*) = send_bundle;
extern int lo_send_bundle_from(void*, void*, void*) = send_bundle_from;
extern void* lo_message_new() = message_new;
extern void lo_message_free(void*) = message_free;
extern void lo_message_add_int32(void*, int) = message_add_int32;
extern void lo_message_add_float(void*, float) = message_add_float;
extern void lo_message_add_string(void*, char*) = message_add_string;
extern void lo_message_add_blob(void*, void*) = message_add_blob;
extern void lo_message_add_int64(void*, int) = message_add_int64;
extern void Pure_lo_message_add_timetag(void*, lo_timetag*) = message_add_timetag;
extern void lo_message_add_double(void*, double) = message_add_double;
extern void lo_message_add_symbol(void*, char*) = message_add_symbol;
extern void lo_message_add_char(void*, char) = message_add_char;
extern void lo_message_add_midi(void*, char*) = message_add_midi;
extern void lo_message_add_true(void*) = message_add_true;
extern void lo_message_add_false(void*) = message_add_false;
extern void lo_message_add_nil(void*) = message_add_nil;
extern void lo_message_add_infinitum(void*) = message_add_infinitum;
extern void* lo_message_get_source(void*) = message_get_source;
extern char* lo_message_get_types(void*) = message_get_types;
extern int lo_message_get_argc(void*) = message_get_argc;
extern lo_arg** lo_message_get_argv(void*) = message_get_argv;
extern long lo_message_length(void*, char*) = message_length;
extern void* lo_message_serialise(void*, char*, void*, long*) = message_serialise;
extern void* lo_message_deserialise(void*, long, int*) = message_deserialise;
extern char* lo_address_get_hostname(void*) = address_get_hostname;
extern char* lo_address_get_port(void*) = address_get_port;
extern int lo_address_get_protocol(void*) = address_get_protocol;
extern char* lo_address_get_url(void*) = address_get_url;
extern void lo_address_set_ttl(void*, int) = address_set_ttl;
extern int lo_address_get_ttl(void*) = address_get_ttl;
extern void* Pure_lo_bundle_new(lo_timetag*) = bundle_new;
extern void lo_bundle_add_message(void*, char*, void*) = bundle_add_message;
extern long lo_bundle_length(void*) = bundle_length;
extern void* lo_bundle_serialise(void*, void*, long*) = bundle_serialise;
extern void lo_bundle_free(void*) = bundle_free;
extern void lo_bundle_free_messages(void*) = bundle_free_messages;
extern int lo_is_numerical_type(int) = is_numerical_type;
extern int lo_is_string_type(int) = is_string_type;
extern int lo_coerce(int, lo_arg*, int, lo_arg*) = coerce;
extern double Pure_lo_hires_val(int, lo_arg*) = hires_val;
extern void* lo_server_new(char*, void*) = server_new;
extern void* lo_server_new_with_proto(char*, int, void*) = server_new_with_proto;
extern void* lo_server_new_multicast(char*, char*, void*) = server_new_multicast;
extern void lo_server_free(void*) = server_free;
extern int lo_server_recv_noblock(void*, int) = server_recv_noblock;
extern int lo_server_recv(void*) = server_recv;
extern void* lo_server_add_method(void*, char*, char*, void*, void*) = server_add_method;
extern void lo_server_del_method(void*, char*, char*) = server_del_method;
extern int lo_server_get_socket_fd(void*) = server_get_socket_fd;
extern int lo_server_get_port(void*) = server_get_port;
extern int lo_server_get_protocol(void*) = server_get_protocol;
extern char* lo_server_get_url(void*) = server_get_url;
extern int lo_server_events_pending(void*) = server_events_pending;
extern double lo_server_next_event_delay(void*) = server_next_event_delay;
extern char* lo_url_get_protocol(char*) = url_get_protocol;
extern char* lo_url_get_hostname(char*) = url_get_hostname;
extern char* lo_url_get_port(char*) = url_get_port;
extern char* lo_url_get_path(char*) = url_get_path;
extern int lo_strsize(char*) = strsize;
extern int lo_blobsize(void*) = blobsize;
extern int lo_pattern_match(char*, char*) = pattern_match;
extern double Pure_lo_timetag_diff(lo_timetag*, lo_timetag*) = timetag_diff;
extern void lo_timetag_now(lo_timetag*) = timetag_now;
extern void lo_bundle_pp(void*) = bundle_pp;
extern void lo_message_pp(void*) = message_pp;
extern void lo_arg_pp(int, void*) = arg_pp;
extern void lo_server_pp(void*) = server_pp;
extern void lo_method_pp(void*) = method_pp;
extern void lo_method_pp_prefix(void*, char*) = method_pp_prefix;
extern void lo_server_thread_pp(void*) = server_thread_pp;
extern void* lo_address_new(char*, char*) = address_new;
extern void* lo_address_new_from_url(char*) = address_new_from_url;
extern void lo_address_free(void*) = address_free;
extern void lo_address_set_ttl(void*, int) = address_set_ttl;
extern int lo_address_get_ttl(void*) = address_get_ttl;
extern int lo_address_errno(void*) = address_errno;
extern char* lo_address_errstr(void*) = address_errstr;
extern void* lo_server_thread_new(char*, void*) = server_thread_new;
extern void* lo_server_thread_new_multicast(char*, char*, void*) = server_thread_new_multicast;
extern void* lo_server_thread_new_with_proto(char*, int, void*) = server_thread_new_with_proto;
extern void lo_server_thread_free(void*) = server_thread_free;
extern void* lo_server_thread_add_method(void*, char*, char*, void*, void*) = server_thread_add_method;
extern void lo_server_thread_del_method(void*, char*, char*) = server_thread_del_method;
extern void lo_server_thread_start(void*) = server_thread_start;
extern void lo_server_thread_stop(void*) = server_thread_stop;
extern int lo_server_thread_get_port(void*) = server_thread_get_port;
extern char* lo_server_thread_get_url(void*) = server_thread_get_url;
extern void* lo_server_thread_get_server(void*) = server_thread_get_server;
extern int lo_server_thread_events_pending(void*) = server_thread_events_pending;
extern void* lo_blob_new(int, void*) = blob_new;
extern void lo_blob_free(void*) = blob_free;
extern int lo_blob_datasize(void*) = blob_datasize;
extern void* lo_blob_dataptr(void*) = blob_dataptr;

/* This one is in the liblo headers, but not wrapped automatically as it's an
   array constant. Define it as a Pure vector which can readily be passed to
   liblo functions expecting a timestamp value. */

const lo::TT_IMMEDIATE = {0,0};

/* These are varargs functions in the liblo interface, so we massage them
   somewhat to make them callable from Pure. */

extern int Pure_lo_message_add(void*, char*, expr*) = message_add;
extern int Pure_lo_send(void*, char*, char*, expr*) = send;
extern int Pure_lo_send_timestamped(void*, lo_timetag*, char*, char*, expr*)
 = send_timestamped;
extern int Pure_lo_send_from(void*, void*, lo_timetag*, char*, char*, expr*)
 = send_from;

/* liblo allows these to be invoked also with NULL pointers as strings, so we
   emulate this behaviour here. */

private extern void *lo_address_new(void*,void*);
address_new host::pointer port::pointer =
  lo_address_new host port if host==NULL && port==NULL;
address_new host::pointer port::string =
  lo_address_new host (cooked $ byte_cstring port) if host==NULL;
address_new host::string port::pointer =
  lo_address_new (cooked $ byte_cstring host) port if port==NULL;

private extern void *lo_server_add_method(void*,void*,void*,void*,void*);
server_add_method s::pointer path::pointer types::pointer h::pointer data::pointer =
  lo_server_add_method s path types h data if path==NULL && types==NULL;
server_add_method s::pointer path::pointer types::string h::pointer data::pointer =
  lo_server_add_method s path (cooked $ byte_cstring types) h data if path==NULL;
server_add_method s::pointer path::string types::pointer h::pointer data::pointer =
  lo_server_add_method s (cooked $ byte_cstring path) types h data if types==NULL;

private extern void lo_server_del_method(void*,void*,void*);
server_del_method s::pointer path::pointer types::string =
  lo_server_del_method s path types if path==NULL && types==NULL;
server_del_method s::pointer path::pointer types::string =
  lo_server_del_method s path (cooked $ byte_cstring types) if path==NULL;
server_del_method s::pointer path::string types::string =
  lo_server_del_method s (cooked $ byte_cstring path) types if types==NULL;

private extern void *lo_server_thread_add_method(void*,void*,void*,void*,void*);
server_thread_add_method s::pointer path::pointer types::pointer h::pointer data::pointer =
  lo_server_thread_add_method s path types h data if path==NULL && types==NULL;
server_thread_add_method s::pointer path::pointer types::string h::pointer data::pointer =
  lo_server_thread_add_method s path (cooked $ byte_cstring types) h data if path==NULL;
server_thread_add_method s::pointer path::string types::pointer h::pointer data::pointer =
  lo_server_thread_add_method s (cooked $ byte_cstring path) types h data if types==NULL;

private extern void lo_server_thread_del_method(void*,void*,void*);
server_thread_del_method s::pointer path::pointer types::string =
  lo_server_thread_del_method s path types if path==NULL && types==NULL;
server_thread_del_method s::pointer path::pointer types::string =
  lo_server_thread_del_method s path (cooked $ byte_cstring types) if path==NULL;
server_thread_del_method s::pointer path::string types::string =
  lo_server_thread_del_method s (cooked $ byte_cstring path) types if types==NULL;

/* Convenience functions to decode liblo OSC messages and addresses. */

public decode_arg decode_argv;

decode_arg "i" p::pointer = get_int p;
decode_arg "h" p::pointer = get_int64 p;
decode_arg "c" p::pointer = get_byte p;
decode_arg "f" p::pointer = get_float p;
decode_arg "d" p::pointer = get_double p;
decode_arg "b" p::pointer = p;
decode_arg "s" p::pointer = cstring_dup p;
decode_arg "S" p::pointer = cstring_dup p;
decode_arg "t" p::pointer = int_matrix 2 p;
decode_arg "m" p::pointer = map ubyte $ byte_matrix 4 p;
decode_arg "T" p::pointer = ();
decode_arg "F" p::pointer = ();
decode_arg "N" p::pointer = ();
decode_arg "I" p::pointer = ();
decode_arg _   p::pointer = p; // unknown

decode_argv types::string p::pointer n::int = tuple $
  zipwith decode_arg (chars types)
  [get_pointer (p+i*SIZEOF_POINTER) | i = 0..n-1];

/* This returns a triple host, port, protocol. */

public decode_address;

decode_address a::pointer =
  address_get_hostname a, address_get_port a, address_get_protocol a;

public message_data;

message_data m::pointer =
  decode_argv (message_get_types m) (message_get_argv m) (message_get_argc m);

/* A convenience function to create an OSC timetag at a given (nonnegative)
   offset in seconds (a double) from another timetag, which can be either a
   lo_timetag pointer or a Pure int vector. If the given timetag is NULL, the
   current time is assumed (as given by lo::timetag_now). The return value is
   always a Pure int vector which can readily be passed to liblo functions
   expecting a timestamp value. */

public timetag;

timetag p::pointer offs = {ts!0+secs,ts!1+ticks} when
  ts = int_matrix 2 p; if null p then timetag_now ts else ();
  secs = int (trunc offs); ticks = int (frac offs*4294967296.0);
end if offs>=0;

timetag ts::matrix offs = {ts!0+secs,ts!1+ticks} when
  secs = int (trunc offs); ticks = int (frac offs*4294967296.0);
end if imatrixp ts && offs>=0;
