/*..

======================================
Some Solutions to the N Queens Problem
======================================

:Author: Libor Spacek (C) <libors@gmail.com\>
:License: GPL V3
:Date: Version 2: June 2009

**Example usage**::

	#pure -i queens.pure
	>fullboard (thequeens 30); */

// using namespace queens;
// public allqueens queens tailqueens fullboard thequeens checkqs queenstest;
// private safe;

nullary nosolution passed failed;

/*..

**(diagsafe j l)**

	is square j in the current row safe from the diagonal attacks by 
	queens placed on the previous rows (list l)? */

diagsafe j::int l = rsafe 1 l
	with
	rsafe id::int [j2::int] = if id==(abs(j2-j)) then 0 else 1;
	rsafe id::int (j2::int:l) = if id==(abs(j2-j)) then 0 else rsafe (succ id) l 
	end;
	
ecat h::int [] = [h];
ecat h::int (h2::int:t) = h2:(ecat h t);
rotate (h::int:t) = ecat h t;

rot 1 l = [l];
rot i::int l = l:(rot (pred i)(rotate l));
rotations l = rot (#l) l;

iteraten n::int f x = (iterate f x)!!(0..(pred n));
lazyrotations l = iteraten (#l) rotate l;

permtree [i::int] = [i];
permtree l =  map (\(h::int:t) -> h:(permtree t)) (rotations l);

/* remove an element from an ordered list used for candidates list reduction */
rem _ [] = [];
rem h1::int (h2::int:t) = if h1 == h2 then t else h2:(rem h1 t);

/* remove an ordered tuple from an ordered tuple of ints */
remtuple _ () = ();
remtuple () l = l;
remtuple h1::int (h2::int,t2) = (h2,t2) if h1 < h2;
remtuple h1::int (h2::int,t2) = t2 if h1 == h2;
remtuple h1::int (h2::int,t2) = h2,(remtuple h1 t2);
remtuple (h1::int,t1) (h2::int,t2) = remtuple t1 (h2,t2) if h1 < h2;
remtuple (h1::int,t1) (h2::int,t2) = remtuple t1 t2 if h1 == h2;
		= h2,(remtuple (h1,t1) t2); 

/* remove an ordered triple from a list of ordered lists 
remlists _ [] = [];
remlists (ld::int,m::int,hd::int) (h2:t2) = ((remlist (h1:t1) h2):(remlists   if h1 == 1;
remlist (h1::int:t1) (h2::int:t2) = remlist t1 (h2:t2) if h1 < h2;
remlist (h1::int:t1) (h2::int:t2) = remlist t1 t2 if h1 == h2;
		= h2:(remlist (h1:t1) t2); */
/*..

**(fullboard s)**

	full coordinates representation [(row,column),...] is redundant
	because the first coordinate of any solution will always be 1..n. 
	However, it can be reconstructed with, e.g. (fullboard (thequeens n));
	All solutions here are encoded as the columns permutations only, 
	[column, ...], leaving out (the index formed by) the ordered rows.
	In all cases rows and columns are interchangeable, 
	i.e. reading the same numbers as [row, ....] for ordered
	columns is also a valid solution. */
	
fullboard s = zip (1..(#s)) s;

/*..

**(allqueens n)**

	returns all possible solutions by constrained search, e.g.
	(allqueens 8) returns a list of all 92 chessboard solutions. 
	There is no known method to find the number
	of solutions for any n. Experimental solutions exist currently 
	for up to n=26 by using special purpose parallel hardware and 
	running for a long time. Allqueens, which is quite fast,
	is quite breathless for n=15 (number of solutions = 2 279 184). 
	It is unwise to ask for the full list
	to be printed for anything beyond n=10 (724  solutions).
	
	Only half of the first row is considered for the first queen, 
	thus halving the total search effort, 
	followed by adding a reflection of all the solutions found 
	about the middle column. 
	Odd sized boards must have additionally the first midrow starting position
	searched and add its solutions. 
	More reflections and rotations could be done but the solutions 
	would have to be 	tested for duplicates.
	All rook checking (row and column) is eliminated by using only unused 
	candidates list c, leaving just the bishop check, id==abs(j2-j),  
	(both diagonals).*/

allqueens n::int = unimplemented for less than 5 if (n < 5);
	= if (n mod 2 == 0) then (hsoln+revsoln) else
		hsoln+(list (search pn (rem hsn nl) [hsn]))+revsoln
  when pn = pred n; sn = succ n; hsn = sn div 2;
	hnl = (1..(n div 2)); nl = (1..n);
	hsoln = list (tuple (map (\j -> search pn (rem j nl) [j]) hnl));
   revsoln = map (\y -> map (\z -> sn-z) y) hsoln
	end
	with
	search 0 c p = p;
	search i::int c p = tuple 
		(map (\j -> search (pred i) (rem j c) (j:p)) [k | k = c; diagsafe k p])
  end;
/* work in progress
newqueens n::int = unimplemented for less than 5 if (n < 5);
	= if (n mod 2 == 0) then (hsoln+revsoln) else
		(hsoln+(list (search pn (remlist [(pred hsn),hsn,(succ hsn)] nl) [hsn]))+revsoln)
  when pn = pred n; sn = succ n; hsn = sn div 2;
	hnl = (1..(n div 2)); nnl = [(1..n)|i=1..pn];
	hsoln = list (tuple (map (\j -> search pn (rem j nl) [j]) hnl));
   revsoln = map (\y -> map (\z -> sn-z) y) hsoln
	end
	with
	search 0 c p = p;
	search i::int c p = tuple 
		(map (\j -> search (pred i) (rem j c) (j:p)) [k | k = c; diagsafe k p])
  end;
*/

/*..

**(queens n)** */

queens n::int = search n n []
  with
   search 0 _ p = [];  			// last i, solved
   search _ 0 _ = nosolution;    // failed, run out of alternative js
   search i::int j::int p = 
     if (nosolution === solution) then search i (pred j) p else j:solution
     when solution = search (pred i) n (j:p) end if safe j p;
     = search i (pred j) p	       // also try another j when unsafe
  end;

/*..

**(tailqueens n)**

	this concise backtracking tailrecursive version 
	throws a single solution which is the rows reflection
	of that found by "queens"  */

tailqueens n::int = catch id (srch n n []) 
  with srch 0 _ p = throw p; // no more rows: solved
		 srch _ 0 _ = nosolution; // out of columns: failed
       srch i::int j::int p = if safe j p then 
         ( if nosolution === (srch (i-1) n (j:p)) then srch i (j-1) p else [] ) 
       else srch i (j-1) p
  end;

/*..

**(thequeens n)**

	encodes my no search regular solution in just 12 lines of code,
	which is to my knowledge the simplest and fastest known algorithm for 
	the N-Queens problem. It is very fast even for large boards.

	There always exists one symmetrical (under 180 degrees rotation) 
	solution of this form, producing an orbit of just 4 equivalent solutions, 
	instead of the usual 8. The correct pattern is generated directly without
	any checking or searching being necessary.
	The solutions had been tested exhaustively for board sizes 0 to 5000 
	and individually for board size 50000x50000. */

thequeens n::int = case n of
	1 = [1];  // trivial solution to one square board
	2 | 3 = nosolution;
	_::int = 1:(map succ (thequeens (n-1))) if (n mod 2);// odd size boards done
		= map (newsq) (0..(n-1)) // the rest is even sized boards solution
		with 
		newsq x::int = (succ ((start+2*x) mod n)) if x < hn;
						 = (succ ((restart+2*(x-hn)) mod n)) end
		when hn::int = (n div 2); // half n
			start::int = if (n mod 3) then (pred hn) else 1; //(n mod 3) special
			restart::int = (1+n-start) end 
end; // end of case and thequeens

/*.. The rest are test utilities

**(safe j l)**

	is square j in current row safe from any attacks by previously
	placed queens in list l? id is the +ve rows difference used for recursion 
	with rsafe */

safe j::int l = rsafe 1 l
	with
	rsafe _ [] = 1;
	rsafe id::int (j2::int:l) = 
		if ((jd == 0) || (jd == id)) then 0 else rsafe (succ id) l
		when jd = abs(j2-j) end
	end;

/*..

**(checkqs l)**

	checks one solution either in 0..n-1 encoding or in 1..n
	encoding. It returns 1 for a correct result, including "nosolution" 
	for sizes 2 and 3; 0 is returned if a queen attack exists anywhere 
	within the presented 'solution'. */

checkqs [] = 1;
checkqs (s::int:l) = if safe s l then checkqs l else 0;
checkqs (nosolution) = 1;

/*..

**(queenstest method l)**

	conducts exhaustive tests of solutions for boards of all listed sizes. 
	Example usage::
	
	>queenstest (id) (allqueens 8);
	>queenstest queens (1..10);
	>queenstest tailqueens ([5,6,7]);
	>queenstest thequeens (5000:4999..100); */

queenstest _ [] = passed;
queenstest method (h:l) = 
	if checkqs (method h) then (queenstest method l) else failed;
