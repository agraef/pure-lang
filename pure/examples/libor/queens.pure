/*..

======================================
Some Solutions to the N Queens Problem
======================================

:Author: Libor Spacek (C) <libors@gmail.com\>
:License: GPL V3
:Date: Version 2: June 2009

Example usage:
______________

	#pure -i queens.pure

	>fullboard (thequeens 30); */

// using namespace queens;
// public allqueens queens tailqueens fullboard thequeens checkqs queenstest;
// private safe;
/*..

Utilities:
__________
*/
//>>>
nullary nosolution passed failed;
//<<<
/*..

**(diagsafe j l)**

	is square j in the current row safe from the diagonal attacks by 
	all queens in previous rows placed on other columns recorded in list l ? */
// >>>
diagsafe j::int l = rsafe 1 l
	with
		rsafe id::int [j2::int] = if id==(abs(j2-j)) then 0 else 1;
		rsafe id::int (j2::int:l) = 
			if id==(abs(j2-j)) then 0 else rsafe (succ id) l 
	end;
// <<<
/* remove an element from an ordered list used for candidates list reduction */
rem _ [] = [];
rem h1::int (h2::int:t) = if h1 == h2 then t else h2:(rem h1 t);

/*..

**(fullboard s)**

	full coordinates representation [(row,column),...] is redundant
	because the first coordinate of any solution will always be 1..n. 
	However, it can be reconstructed with, e.g. (fullboard (thequeens n));
	All solutions here are encoded as the columns permutations only, 
	[column, ...], leaving out (the index formed by) the ordered rows.
	In all cases rows and columns are interchangeable, 
	i.e. reading the same numbers as [row, ....] for ordered
	columns is also a valid solution. */
//>>>	
fullboard s = zip (1..(#s)) s;
//<<<
/*..

Solutions:
__________

**(allqueens n)**

	returns all possible solutions by constrained search, e.g.
	(allqueens 8) returns a list of all 92 chessboard solutions. 
	There is no known method to find the number
	of solutions for any n. Experimental solutions exist currently 
	for up to n=26 by using special purpose parallel hardware and 
	running for a long time. Allqueens, which is quite fast,
	is quite breathless for n=15 (number of solutions = 2 279 184). 
	It is unwise to ask for the full list
	to be printed for anything beyond n=10 (724  solutions).
	
	Only half of the first row is considered for the first queen, 
	thus halving the total search effort, 
	followed by adding a reflection of all the solutions found 
	about the middle column. 
	Odd sized boards must have additionally the first midrow starting position
	searched and add its solutions. 
	More reflections and rotations could be done but the solutions 
	would have to be 	tested for duplicates.
	All rook checking (row and column) is eliminated by using only unused 
	candidates list c, leaving just the bishop check, id==abs(j2-j),  
	(both diagonals).*/
//>>>
allqueens n::int = unimplemented for less than 5 if (n < 5);
	= if (n mod 2 == 0) then (hsoln+revsoln) 
		else hsoln+(list (search (rem hsn nl) [hsn]))+revsoln
	when 
		pn = pred n; sn = succ n; hsn = sn div 2;
		hnl = (1..(n div 2)); nl = (1..n);
		hsoln = list (tuple [search (rem j nl) [j] | j = hnl]);
		revsoln = map (\y -> map (\z -> sn-z) y) hsoln
	end
	with
		search [] p = p;
		search c p = tuple [ search (rem j c) (j:p) | j = c; diagsafe j p]
	end;
//<<<

/*..

**(queens n)** 
*/

queens n::int = search n n []
	with
	search 0 _ p = [];   // last i, solved
	search _ 0 _ = nosolution;   // failed, run out of alternative js
	search i::int j::int p = search i (pred j) p if unsafe j p; // try another j
		= if (solution === nosolution) then search i (pred j) p else j:solution
		when solution = search (pred i) n (j:p) end 
   end;

/*..

**(tailqueens n)**

	this concise backtracking tailrecursive version 
	throws a single solution which is the rows reflection
	of that found by "queens"  */

tailqueens n::int = catch id (srch n n [])
	with srch 0 _ p = throw p; // no more rows: solved
		srch _ 0 _ = nosolution; // out of columns: failed
		srch i::int j::int p = if unsafe j p then srch i (j-1) p else
		( if ((srch (i-1) n (j:p)) === nosolution) then srch i (j-1) p else [] )
	end;

/*..

**(thequeens n)**

	Any two queens placement symmetric under a single reflection around any of the
	board's four axis of symmetry is not part of a solution by problem definition.
	It follows that any complete solution cannot be symmetric (invariant) under a single reflection.

	There are so called doubly symmetric solutions, invariant under any 
	combination of 90 degrees rotations,
	which have an orbit of just two equivalent solutions, produced by a single reflection
	(e.g. viewing the board from top or from underneath). A double symmetric solution has the
	full square symmetry internally but its axis of symmetry do not coincide with those of the
	board.

	There always exists at least one symmetric solution 
	invariant under 180 degrees rotation (or two orthogonal reflections), producing an orbit of  
	four equivalent solutions. The symmetric solutions are the ones found by 'thequeens' and
	possibly other regular methods.

	All other solutions are asymmetric and thus can be rotated into four different positions
	and viewed from above or below the board, in each case producing a different (equivalent)
	solution, the total orbit (of the dihedral group) of eight.

	There are no other solutions.

	'Thequeens' encodes my solution in the following few lines of code.
	It is to my knowledge the simplest algorithm for 
	the N-Queens problem. It is very fast even for large boards, 
	being a regular (linear) solution requiring no search.
	Of course, it does not give all the solutions and thus does not solve the
	hard problem described above for 'allqueens'.

	The correct pattern is simply written down directly without
	any checking or searching being necessary. It can be easily learnt to do
	'by inspection', which is probably a neat party trick to perform.
	The solutions had been tested exhaustively for board sizes 0 to 5001 
	and individually for board size 50000x50000. */
//>>>
thequeens n::int = case n of
	1 = [1];  // trivial solution to one square board
	2 | 3 = nosolution;
	_::int = 1:(map succ (thequeens (n-1))) if (n mod 2);// odd size boards done
		= map (newsq) (0..(n-1)) // the rest is even sized boards solution
	with 
		newsq x::int = (succ ((start+2*x) mod n)) if x < hn;
						 = (succ ((restart+2*(x-hn)) mod n)) end
	when 
		hn::int = (n div 2); // half n
		start::int = if (n mod 3) then (pred hn) else 1; //(n mod 3) special
		restart::int = (1+n-start) 
	end 
end; // end of case and thequeens

//<<<
/*.. 

Testing:
________

**(unsafe j l)**

	is square j in the current row attacked (rook or bishop)
	by any previously placed queen in list l?  */
//>>>
unsafe j::int l = rsafe 1 l
	with
		rsafe _ [] = 0;
		rsafe id::int (j2::int:l) = 
			if ((jd == 0) || ((id-jd) == 0) || ((id+jd) == 0)) then 1 
			else rsafe (succ id) l
			when jd = j2-j end
	end;
//<<<
/*..

**(checkqs l)**

	checks one solution either in 0..n-1 encoding or in 1..n
	encoding. It returns 0 for a correct result, including "nosolution" 
	for sizes 2 and 3; 1 is returned if a queen attack exists anywhere 
	within the presented 'solution'. */
//>>>
checkqs [] = 0;
checkqs (s::int:l) = if unsafe s l then 1 else checkqs l;
checkqs (nosolution) = 0;
//<<<
/*..

**(queenstest method l)**

	conducts exhaustive tests of solutions,
	returns either 'passed' or 'failed'. Can be supplied either a
	name of a method that will produce a single solution for each
	listed board size, or (id) followed by a list of candidate
	solutions. The latter form is useful for testing 'allqueens'.
	Example usage::
	
	>queenstest (id) (allqueens 8);
	>queenstest queens (1..10);
	>queenstest tailqueens ([5,6,7]);
	>queenstest thequeens (5000:4999..100); */
//>>>
queenstest _ [] = passed;
queenstest method (h:l) = 
		if checkqs (method h) then failed 
		else (queenstest method l);
//<<<