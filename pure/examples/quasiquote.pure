
/* An implementation of Lisp's quasiquote. 2009-05-26 AG. */

/* Some syntactic sugar for Lisp weenies. Note that we cannot have ',' for
   unquoting, we use ',$' instead. Also note that '`', ',$' and ',@' are just
   ordinary prefix operators, applications of these must be parenthesized
   accordingly. Thus, e.g., `(f ,@[a,b,c]) won't work, you have to write
   `(f (,@[a,b,c])) instead. */

prefix 9 ` ,$ ,@ ;
def (`) = quasiquote; def (,$) = unquote; def (,@) = splice;

/* Quasiquote itself is implemented as a macro which simply expands to a call
   of the qq function below. */

def quasiquote x = qq (quote x);

/* The following implementation tries to stay as close to the spirit of the
   original quasiquote (see, e.g., Guy L. Steele, Common Lisp the Language,
   2nd Edition) as reasonably possible in Pure. Nested quasiquotes work as
   usual. However, due to Pure's different handling of function applications,
   splicing works somewhat differently:

   - `@,[a,b,c]		=> a b c

   - `(@,[a,b,c]) x y	=> a b c x y

   - `x (@,[a,b,c]) y	=> x a b c y

   Thus, splicing works essentially by "currying" the argument list, and this
   will work in any context. Also note that the argument of 'splice' must
   always evaluate to a proper list, otherwise 'quasiquote' raises an
   exception. The current implementation does *not* support splicing into
   other Pure aggregate structures such as lists, tuples and matrices, as
   these data structures already provide their own means to do this. */

qq x = qqn 0 x with
/* qqn n x descends into x, substituting embedded instances of unquote and
   splice at level 0 (i.e., belonging to the outermost quasiquote). Also note
   that we have to handle both the normalized forms unquote and splice as well
   as the ,$ and ,@ aliases, as the latter may occur unevaluated inside quoted
   subterms. */
qqn n (`x)		|
qqn n (qq (quote x))	= quote (quasiquote y) when y = qqn (n+1) x end;
qqn 0 (,$x)		|
qqn 0 (unquote x)	= eval x;
qqn 0 (,@x)		|
qqn 0 (splice x)	= case eval x of
			    x = foldl1 ($) x if listp x;
			      = throw (bad_list_value x);
			  end;
qqn 0 (f@_ (,@x))	|
qqn 0 (f@_ (splice x))	= case eval x of
			    x = foldl ($) (qqn 0 f) x if listp x;
			      = throw (bad_list_value x);
			  end;
qqn n (,$x)		|
qqn n (unquote x)	= unquote (qqn (n-1) x);
qqn n (,@x)		|
qqn n (splice x)	= splice (qqn (n-1) x);
qqn n (f@_ (,@x))	|
qqn n (f@_ (splice x))	= qqn n f (splice (qqn (n-1) x));
qqn n (f@_ x)		= qqn n f (qqn n x);
qqn n x::matrix		= map (qqn n) x;
qqn n x			= x;
end;

/* Unquoting example. This yields 'foo 1 2 0.75 (5/6)'. */

`foo 1 2 (,$(3/4)) (5/6);

/* In fact, you can also achieve the same by just substituting a local
   variable into a normal quoted expression. This works in Pure, because in
   difference to Lisp a local variable is never quoted. */

'foo 1 2 x (5/6) when x = 3/4 end;

/* Splicing allows you to insert arguments into a function application. The
   argument of 'splice' must be a list value with the arguments to be
   inserted. The following example yields 'foo 1 2 (2/3) (3/4) (5/6)'. */

`foo 1 2 (,@'[2/3,3/4]) (5/6);

/* You can also splice a list in a local variable. The following example
   computes the same value as above. Note, however, that since local variables
   can never be quoted, in difference to Lisp the *value* of the variable gets
   evaluated, not the variable itself. Hence an extra quote is needed on the
   value x to make one quote go through. */

`foo 1 2 (,@x) (5/6) when x = ''[2/3,3/4] end;

/* It's also possible to splice a list as the head of a function application.
   This example yields 'foo (2/3) (3/4) (5/6)'. */

`(,@'[foo,2/3,3/4]) (5/6);

/* A nested quasiquote. This only expands the outermost quasiquote, yielding
   'a (quasiquote (b (unquote (1+2)) (unquote (foo 4 d)) e)) f'. A subsequent
   evaluation of the resulting term then expands the nested quasiquote,
   yielding 'a (b 3 (foo 4 d) e) f'. */

let x = `(a (`(b (,$(1+2)) (,$(foo (,$(1+3)) d)) e)) f);
x; eval x;
