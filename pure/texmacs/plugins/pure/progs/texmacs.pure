
/* texmacs support module 2012-10-18 Albert Graef <Dr.Graef@t-online.de>. */

/* Copyright (c) 2012 Albert Graef

   Copying and distribution of this file, with or without modification,
   are permitted in any medium without royalty provided the copyright
   notice and this notice are preserved.  This file is offered as-is,
   without any warranty. */

/* Some auxiliary definitions for use with Pure in TeXmacs. This gets loaded
   automatically if you run the Pure scripting plugin (Document|Scripts|Pure).
   Inside a Pure session, you can invoke this module with `using texmacs;`. */

// Additional operators provided by TeXmacs.
infixl (+) oplus ominus pm mp cup uplus;
infixl (*) otimes oslash div cap;

// Sum and product (used by the big operators in TeXmacs).
sum xs::list = foldl (+) 0 xs;
prod xs::list = foldl (*) 1 xs;

/* These rules bring some TeXmacs constructs into a form which can be readily
   processed with Reduce. They are implemented as a local rule set so as not
   to interfere with global Pure definitions. */

public ceiling limit d df bad_diff;

preproc_diff = reduce with
  // These rules are factored out to make the pattern set slimmer, yielding
  // much better compilation times.
  ::d*x/y = d x/y;
  ::d^k*x/y = d k x/y;
  x/(::d*y^k) = x/d y k;
  x/(::d*y) = x/d y;
  x/(u*::d*y^k) = x/(v*d y k) when _/v = x/u end;
  x/(u*::d*y) = x/(v*d y) when _/v = x/u end;
end;

preproc1 = reduce with
  // Ceil. Name change only.
  ceil x = ceiling x;

  // Limits. Simple change of argument order.
  lim v l x = limit x v l;

  // Differentials. This is a mess. :(
  ::d/y*x = d x/y;
  (::d^k)/y*x = d k x/y;
  (::d^k) x/y = d k x/y;
  ::d^k@_ x/y = d k x/y;
  x/(d y^k) = x/d y k;
  x/(d (y^k)) = x/d y k;
  x/(u*d y^k) = x/(u*d y k);
  x/(u*d (y^k)) = x/(u*d y k);

  /* Base forms where d is simply an operator and all the multiplication and
     exponentiation sugar has been eliminated. These expand to a Reduce
     df. Note that we require constant orders here to resolve some
     ambiguities, but don't do any checking on these. */
  d f/d x = df f x;
  d f/d x l::int = df f x;
  d f/(y*d x) = (d 0 f/y) x;
  d f/(y*d x l::int) = (d (1-l) f/y) x l;
  d k::int f/d x = df f x k;
  d k::int f/d x l::int = df f x k;
  d k::int f/(y*d x) = (d (k-1) f/y) x;
  d k::int f/(y*d x l::int) = (d (k-l) f/y) x l;
end;

preproc x = preproc1 (preproc_diff x);

/* The ? convenience macro simplifies an expression using Reduce. To make
   this work, you'll also have to import the reduce module. This isn't done
   here so that this module also works without having the pure-reduce package
   installed.

   ? passes the argument as a quoted expression and automatically applies the
   rules for massaging of limits and differentials, see above. ?: does the
   same but evaluates its argument. We also define these as functions, so that
   they can be passed around as function arguments if needed, but note that in
   this case ? looses its call-by-name argument processing.

   These operators are at the lowest possible precendence so that their
   arguments don't have to be parenthesized (but applications of ?  and ?:
   must be parenthesized when used in any larger context). */

prefix 0 ? ?: ;
public simplify;
def ? x = simplify (preproc ('x));
def ?:x = simplify (preproc x);

? x = ? x;
?:x = ?:x;

/* LaTeX pretty-printing using the tmprint package of Reduce. Thanks are due
   to Kurt Pagani who figured out most of the necessary Lisp magic to make
   this work. You enable this with a call to the parameterless `math`
   function; `verbatim` switches back to program mode again. This also starts
   up Reduce in a lazy fashion when `math` is invoked, so that we avoid
   depending on the pure-reduce package. Note, however, that pure-reduce *is*
   required to make the pretty-printing work. */

// Enable this pragma to enable math mode by default.
//#! --enable tmmath

let tminit, tmmode = ref false, ref false;
let texmacs_valid_fun, texmacs_post_fun = ref (), ref ();

public declare operator texmacs_valid texmacs_post;
namespace reduce with
  public capture output load pure_syms;
end;

tmstart = () when
  // The externals are in the reduce module.
  eval "using reduce;\
extern int texmacs_valid(char *s);\
extern char *texmacs_post(char *s);";
  put texmacs_valid_fun (eval "texmacs_valid");
  put texmacs_post_fun (eval "texmacs_post");
  reduce::capture 1;
  reduce::load "tmprint";
  reduce::capture 0;
  put tminit true;
end if ~get tminit;

public lisp lispval lispsym;

/* NOTE: This recursively descends into the (already simplified) term to see
   whether it's actually printable. tmprint chokes on strings (wants them to
   be symbols) and of course doesn't know about C pointers, Pure closures and
   the like, so we exclude them here, also any operator symbols which are not
   in the reduce::pure_syms table or valid Reduce identifiers. */

/* If the following compile time option is enabled, subterms will be tried
   again by the pretty-printer if the check fails on the parent term. This
   comes at a cost (pretty-printing will become progressively slower as the
   terms get larger), but normally this shouldn't be much of a problem and we
   recommend to leave this enabled so that as much of the term is rendered in
   latex mode as possible. */

//#! --disable recurse

tmprint x = s when
  tmstart;
  x = lispval x;
  lisp (lispsym "fancy-output" (''maprin) ('aeval ('x)));
  reduce::capture 1;
  lisp (lispsym "fancy-flush");
  reduce::capture 0;
  s = reduce::output;
  // There's still have some postprocessing to do...
  s = get texmacs_post_fun s;
end if printable x when
  /* We need to simplify first (even though tmprint will do it anyway), in
     order to decide whether the expression is printable. However, if the
     original expression doesn't look printable already, simplify itself will
     probably choke on it as well (the typical symptom are spurious "operator
     declared" messages), so we give up right away in this case. */
  x = if printable x then simplify (preproc x) else "no";
end with
  printable x::number = true;
  printable [] = true;
  printable (x:xs) = printable x && ~thunkp xs && printable xs;
  printable x::matrix = all printable x;
  printable (x@_ y::tuple) = printable x && all printable (list y);
  printable (x@_ y) = printable x && printable y;
  printable x::symbol = x ~== (..) && x ~== '(..) &&
    member reduce::pure_syms x || get texmacs_valid_fun (str x);
  printable _ = false;
end;
#! --ifnot recurse
tmprint x = str x;
#! --endif

// Switch between math and verbatim output.
math = tmstart $$ put tmmode true $$ ();
verbatim = put tmmode false $$ ();

// Pretty-printing routine for Pure's --texmacs mode.
__texmacs__ x = tmprint x if get tmmode;

#! --ifndef tmmath
#! --disable tmmath
#! --endif
#! --if tmmath
math;
#! --endif
