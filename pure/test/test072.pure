
// Interface types (0.50+).

// A subset of the stack interface.
interface nonempty_stack with
  pop xs::nonempty_stack;
  top xs::nonempty_stack;
end;

// The interface definition.
get_interface nonempty_stack;

// Construction function for list stacks.
astack xs::list = xs;

// Test function.
foo xs::nonempty_stack = top xs, pop xs;
// This fails right now, since the interface isn't implemented yet.
foo $ astack (1..10);

// Implementation of pop and top in terms of lists.
pop (x:xs) = xs;
top (x:xs) = x;

// Works now.
foo $ astack (1..10);

// Fails, because the nonempty_stack interface doesn't match the empty list.
foo $ astack [];

// Full stack interface.
interface stack with
  push xs::stack x;
  /* Test some of the more advanced diagnostics provided by interfaces. These
     are all enabled with the -w option or the --warn pragma. In the following
     case, we'll be warned about the partial implementations of the pop and
     top functions which don't apply to empty stacks (a.k.a. lists). */
#! --warn
  // Include the nonempty_stack interface. This effectively makes 'stack' a
  // subtype of the 'nonempty_stack' type which offers one additional
  // interface function.
  interface nonempty_stack;
#! --rewarn
end;

// Implementation of push in terms of lists.
push xs@[] x | push xs@(_:_) x = x:xs;

get_interface stack;

/* Looking at the actual patterns of the type (e.g., with 'show interface
   stack'), you'll see that, just as the warnings indicate, empty stacks/lists
   aren't supported by the interface because pop and top don't provide rules
   for them. The easiest way to fix this is to turn pop and top into "defined
   functions" (with the --defined pragma) since these are always by definition
   "complete", as far as interfaces are concerned. (This isn't really the
   recommended method, though, since it also disables any further warnings on
   these functions. In production code we'd want to add proper rules to pop
   and top which handle all the relevant cases.) */

#! --defined pop
#! --defined top

foo xs::stack = top xs, pop xs;
foo $ astack (1..10);
// This causes an exception now because of the empty list which can't be
// handled by pop and top.
foo $ astack [];

bar x xs::stack = foo (push xs x);
bar 99 $ astack (1..3);

// A different implementation of the same interface.

nonfix nil;
public cons;

push xs@nil x | push xs@(cons _ _) x = cons xs x;
pop (cons xs x) = xs;
top (cons xs x) = x;

// Construction function for our fancy stacks.
bstack xs::list = foldl push nil xs;

// foo and bar now automagically work with these, too.
foo $ bstack (1..3);
bar 99 $ bstack (1..3);
