interface nonempty_stack with
  pop xs/*0:1*/::nonempty_stack;
  top xs/*0:1*/::nonempty_stack;
end;
get_interface nonempty_stack;
[pop (xs __type__ nonempty_stack),top (xs __type__ nonempty_stack)]
get_interface_typedef nonempty_stack;
[]
astack xs/*0:1*/::list = reverse xs/*0:1*/;
foo xs/*0:1*/::nonempty_stack = top xs/*0:1*/,pop xs/*0:1*/;
{
  rule #0: astack xs::list = reverse xs
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: foo xs::nonempty_stack = top xs,pop xs
  state 0: #0
	<var> state 1
  state 1: #0
}
foo (astack (1..10));
foo [10,9,8,7,6,5,4,3,2,1]
pop (x/*0:101*/:xs/*0:11*/) = xs/*0:11*/;
top (x/*0:101*/:xs/*0:11*/) = x/*0:101*/;
interface nonempty_stack {
  rule #0: nonempty_stack (x:xs) = 1
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
}
{
  rule #0: pop (x:xs) = xs
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
}
{
  rule #0: top (x:xs) = x
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
}
foo (astack (1..10));
10,[9,8,7,6,5,4,3,2,1]
foo (astack []);
foo []
interface stack with
  push xs/*0:01*/::stack x/*0:1*/;
  pop xs/*0:1*/::stack;
  top xs/*0:1*/::stack;
end;
push xs@[] x/*0:1*/ = x/*0:1*/:xs/*0:01*/;
push xs@(_/*0:0101*/:_/*0:011*/) x/*0:1*/ = x/*0:1*/:xs/*0:01*/;
warning: interface 'stack' may be incomplete
warning: function 'pop' might lack a rule for 'xs@[]'
warning: function 'top' might lack a rule for 'xs@[]'
interface stack {
  rule #0: stack xs@(_:_) = 1
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
}
{
  rule #0: push xs@[] x = x:xs
  rule #1: push xs@(_:_) x = x:xs
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #1
	<app> state 2
  state 2: #1
	: state 3
  state 3: #1
	<var> state 4
  state 4: #1
	<var> state 5
  state 5: #1
	<var> state 6
  state 6: #1
  state 7: #0
	<var> state 8
  state 8: #0
}
get_interface stack;
[push (xs __type__ stack) x,pop (xs __type__ stack),top (xs __type__ stack)]
get_interface_typedef stack;
[stack (xs __as__ (_:_))-->1]
foo xs/*0:1*/::stack = top xs/*0:1*/,pop xs/*0:1*/;
interface nonempty_stack {
  rule #0: nonempty_stack (x:xs) = 1
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
}
interface stack {
  rule #0: stack xs@[] = 1
  rule #1: stack xs@(_:_) = 1
  state 0: #0 #1
	<app> state 1
	[] state 6
  state 1: #1
	<app> state 2
  state 2: #1
	: state 3
  state 3: #1
	<var> state 4
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0
}
{
  rule #0: pop (x:xs) = xs
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
}
{
  rule #0: top (x:xs) = x
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
}
{
  rule #0: foo xs::nonempty_stack = top xs,pop xs
  rule #1: foo xs::stack = top xs,pop xs
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
}
foo (astack (1..10));
10,[9,8,7,6,5,4,3,2,1]
foo (astack []);
<stdin>, line 72: unhandled exception 'failed_match' while evaluating 'foo$astack []'
pop [] = throw "empty stack";
top [] = throw "empty stack";
interface nonempty_stack {
  rule #0: nonempty_stack (x:xs) = 1
  rule #1: nonempty_stack [] = 1
  state 0: #0 #1
	<app> state 1
	[] state 6
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
  state 6: #1
}
interface stack {
  rule #0: stack xs@[] = 1
  rule #1: stack xs@(_:_) = 1
  state 0: #0 #1
	<app> state 1
	[] state 6
  state 1: #1
	<app> state 2
  state 2: #1
	: state 3
  state 3: #1
	<var> state 4
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0
}
{
  rule #0: pop (x:xs) = xs
  rule #1: pop [] = throw "empty stack"
  state 0: #0 #1
	<app> state 1
	[] state 6
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
  state 6: #1
}
{
  rule #0: top (x:xs) = x
  rule #1: top [] = throw "empty stack"
  state 0: #0 #1
	<app> state 1
	[] state 6
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
  state 6: #1
}
foo (astack (1..10));
10,[9,8,7,6,5,4,3,2,1]
foo (astack []);
<stdin>, line 87: unhandled exception '"empty stack"' while evaluating 'foo$astack []'
bar x/*0:01*/ xs/*0:1*/::stack = foo (push xs/*0:1*/ x/*0:01*/);
{
  rule #0: bar x xs::stack = foo (push xs x)
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
bar 99 (astack (1..3));
99,[3,2,1]
type cons nil;
type cons (cons xs/*0:101*/ x/*0:11*/);
push xs/*0:01*/::cons x/*0:1*/ = cons xs/*0:01*/ x/*0:1*/;
pop xs/*0:1*/::cons = case xs/*0:1*/ of cons xs/*0:01*/ x/*0:1*/ = xs/*0:01*/; _/*0:*/ = throw "empty stack" {
  rule #0: cons xs x = xs
  rule #1: _ = throw "empty stack"
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	cons state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
} end;
top xs/*0:1*/::cons = case xs/*0:1*/ of cons xs/*0:01*/ x/*0:1*/ = x/*0:1*/; _/*0:*/ = throw "empty stack" {
  rule #0: cons xs x = x
  rule #1: _ = throw "empty stack"
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	cons state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
} end;
bstack xs/*0:1*/::list = foldl push nil xs/*0:1*/;
interface nonempty_stack {
  rule #0: nonempty_stack (x:xs) = 1
  rule #1: nonempty_stack [] = 1
  rule #2: nonempty_stack xs::cons = 1
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
	[] state 12
  state 1: #2
  state 2: #0 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #2
	<var> state 6
	: state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #0 #2
	<var> state 10
  state 10: #0 #2
	<var> state 11
  state 11: #0 #2
  state 12: #1 #2
}
interface stack {
  rule #0: stack xs@[] = 1
  rule #1: stack xs@(_:_) = 1
  rule #2: stack xs::cons = 1
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
	[] state 12
  state 1: #2
  state 2: #1 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #1 #2
	<var> state 6
	: state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #1 #2
	<var> state 10
  state 10: #1 #2
	<var> state 11
  state 11: #1 #2
  state 12: #0 #2
}
type cons {
  rule #0: cons nil = 1
  rule #1: cons (cons xs x) = 1
  state 0: #0 #1
	<app> state 1
	nil state 6
  state 1: #1
	<app> state 2
  state 2: #1
	cons state 3
  state 3: #1
	<var> state 4
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0
}
{
  rule #0: pop (x:xs) = xs
  rule #1: pop [] = throw "empty stack"
  rule #2: pop xs::cons = case xs of cons xs x = xs; _ = throw "empty stack" end
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
	[] state 12
  state 1: #2
  state 2: #0 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #2
	<var> state 6
	: state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #0 #2
	<var> state 10
  state 10: #0 #2
	<var> state 11
  state 11: #0 #2
  state 12: #1 #2
}
{
  rule #0: top (x:xs) = x
  rule #1: top [] = throw "empty stack"
  rule #2: top xs::cons = case xs of cons xs x = x; _ = throw "empty stack" end
  state 0: #0 #1 #2
	<var> state 1
	<app> state 2
	[] state 12
  state 1: #2
  state 2: #0 #2
	<var> state 3
	<app> state 5
  state 3: #2
	<var> state 4
  state 4: #2
  state 5: #0 #2
	<var> state 6
	: state 9
  state 6: #2
	<var> state 7
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #0 #2
	<var> state 10
  state 10: #0 #2
	<var> state 11
  state 11: #0 #2
  state 12: #1 #2
}
{
  rule #0: push xs@[] x = x:xs
  rule #1: push xs@(_:_) x = x:xs
  rule #2: push xs::cons x = cons xs x
  state 0: #0 #1 #2
	<var> state 1
	<app> state 3
	[] state 16
  state 1: #2
	<var> state 2
  state 2: #2
  state 3: #1 #2
	<var> state 4
	<app> state 7
  state 4: #2
	<var> state 5
  state 5: #2
	<var> state 6
  state 6: #2
  state 7: #1 #2
	<var> state 8
	: state 12
  state 8: #2
	<var> state 9
  state 9: #2
	<var> state 10
  state 10: #2
	<var> state 11
  state 11: #2
  state 12: #1 #2
	<var> state 13
  state 13: #1 #2
	<var> state 14
  state 14: #1 #2
	<var> state 15
  state 15: #1 #2
  state 16: #0 #2
	<var> state 17
  state 17: #0 #2
}
{
  rule #0: bstack xs::list = foldl push nil xs
  state 0: #0
	<var> state 1
  state 1: #0
}
foo (bstack (1..3));
3,cons (cons nil 1) 2
bar 99 (bstack (1..3));
99,cons (cons (cons nil 1) 2) 3
interface stack with
  test1 xs/*0:1*/::stack;
  test2 xs/*0:1*/::stack;
end;
add_interface stack ('[test1 (xs __type__ stack),test2 (xs __type__ stack)]);
()
get_interface stack;
[push (xs __type__ stack) x,pop (xs __type__ stack),top (xs __type__ stack),test1 (xs __type__ stack),test2 (xs __type__ stack)]
get_interface_typedef stack;
[]
test1 (x/*0:101*/:xs/*0:11*/) = x/*0:101*/,xs/*0:11*/;
test2 xs/*0:1*/::cons = case xs/*0:1*/ of cons xs/*0:01*/ x/*0:1*/ = xs/*0:01*/,x/*0:1*/; _/*0:*/ = throw "empty stack" {
  rule #0: cons xs x = xs,x
  rule #1: _ = throw "empty stack"
  state 0: #0 #1
	<var> state 1
	<app> state 2
  state 1: #1
  state 2: #0 #1
	<var> state 3
	<app> state 5
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	cons state 9
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
  state 9: #0 #1
	<var> state 10
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
} end;
{
  rule #0: test1 (x:xs) = x,xs
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
}
{
  rule #0: test2 xs::cons = case xs of cons xs x = xs,x; _ = throw "empty stack" end
  state 0: #0
	<var> state 1
  state 1: #0
}
bar 99 (astack (1..3));
bar 99 [3,2,1]
bar 99 (bstack (1..3));
bar 99 (cons (cons (cons nil 1) 2) 3)
interface stack {
  rule #0: stack xs@(_:_) = 1
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
}
del_interface stack ('test2 (xs __type__ stack));
()
get_interface stack;
[push (xs __type__ stack) x,pop (xs __type__ stack),top (xs __type__ stack),test1 (xs __type__ stack)]
get_interface_typedef stack;
[stack (xs __as__ (_:_))-->1]
bar 99 (astack (1..3));
99,[3,2,1]
bar 99 (bstack (1..3));
bar 99 (cons (cons (cons nil 1) 2) 3)
interface stack with
  test2 xs/*0:1*/::stack;
end;
add_interface_at stack ('test1 (xs __type__ stack)) ('[test2 (xs __type__ stack)]);
()
get_interface stack;
[push (xs __type__ stack) x,pop (xs __type__ stack),top (xs __type__ stack),test2 (xs __type__ stack),test1 (xs __type__ stack)]
get_interface_typedef stack;
[]
bar 99 (astack (1..3));
bar 99 [3,2,1]
bar 99 (bstack (1..3));
bar 99 (cons (cons (cons nil 1) 2) 3)
interface monoid with
  x/*0:01*/::monoid+y/*0:1*/::monoid;
end;
interface monoid {
  rule #0: monoid x::int = 1
  rule #1: monoid x::double = 1
  rule #2: monoid x::bigint = 1
  rule #3: monoid c::string = 1
  rule #4: monoid [] = 1
  rule #5: monoid xs@(_:_) = 1
  rule #6: monoid ([]+s::string) = 1
  state 0: #0 #1 #2 #3 #4 #5 #6
	<var>::int state 1
	<var>::bigint state 2
	<var>::double state 3
	<var>::string state 4
	<app> state 5
	[] state 13
  state 1: #0
  state 2: #2
  state 3: #1
  state 4: #3
  state 5: #5 #6
	<app> state 6
  state 6: #5 #6
	: state 7
	+ state 10
  state 7: #5
	<var> state 8
  state 8: #5
	<var> state 9
  state 9: #5
  state 10: #6
	[] state 11
  state 11: #6
	<var>::string state 12
  state 12: #6
  state 13: #4
}
add_interface monoid ('[x __type__ monoid+y __type__ monoid]);
()
get_interface monoid;
[x __type__ monoid+y __type__ monoid]
get_interface_typedef monoid;
[(monoid (x __type__ int)-->1),(monoid (x __type__ double)-->1),(monoid (x __type__ bigint)-->1),(monoid (c __type__ string)-->1),(monoid []-->1),(monoid (xs __as__ (_:_))-->1),(monoid ([]+s __type__ string)-->1)]
