'__lambda__ [x] (x+1);
__lambda__ [x] (x+1)
foo = '__lambda__ [x] (x+1);
{
  rule #0: foo = '__lambda__ [x] (x+1)
  state 0: #0
}
foo;
__lambda__ [x] (x+1)
let x = '__case__ 99 [x __type__ int-->x+1 __if__ x>0];
x;
__case__ 99 [x __type__ int-->x+1 __if__ x>0]
eval x;
100
let x = '(x+1 __when__ [x __type__ int-->99]);
x;
x+1 __when__ [x __type__ int-->99]
eval x;
100
let x = '(f 99 __with__ [f (x __type__ int)-->x+1]);
x;
f 99 __with__ [f (x __type__ int)-->x+1]
eval x;
100
bar (__lambda__ [x/*0:10101*/,y/*0:101101*/] z/*0:11*/) = '__lambda__ [y/*0:101101*/,x/*0:10101*/] z/*0:11*/;
{
  rule #0: bar (__lambda__ [x,y] z) = '__lambda__ [y,x] z
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	__lambda__ state 3
  state 3: #0
	<app> state 4
  state 4: #0
	<app> state 5
  state 5: #0
	: state 6
  state 6: #0
	<var> state 7
  state 7: #0
	<app> state 8
  state 8: #0
	<app> state 9
  state 9: #0
	: state 10
  state 10: #0
	<var> state 11
  state 11: #0
	[] state 12
  state 12: #0
	<var> state 13
  state 13: #0
}
{
  rule #0: x = bar ('__lambda__ [a,b] (a-b))
  state 0: #0
	<var> state 1
  state 1: #0
}
let x = bar ('__lambda__ [a,b] (a-b));
x;
__lambda__ [b,a] (a-b)
eval x 2 3;
1
baz x/*0:1*/ = '__lambda__ [x/*0:1*/] (x/*0:1*/+1);
{
  rule #0: baz x = '__lambda__ [x] (x+1)
  state 0: #0
	<var> state 1
  state 1: #0
}
{
  rule #0: x = baz y
  state 0: #0
	<var> state 1
  state 1: #0
}
let x = baz y;
x;
__lambda__ [y] (y+1)
eval x 99;
100
def bar (__lambda__ [x/*0:10101*/,y/*0:101101*/] z/*0:11*/) = __eval__ ('__lambda__ [y/*0:101101*/,x/*0:10101*/] z/*0:11*/);
def baz x/*0:1*/ = __eval__ ('__lambda__ [x/*0:1*/] (x/*0:1*/+1));
f = \b/*0:01*/ a/*0:1*/ -> a/*0:1*/-b/*0:01*/ {
  rule #0: _ b a = a-b
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
};
{
  rule #0: f = \b a -> a-b
  state 0: #0
}
f 2 3;
1
g = \y/*0:1*/ -> y/*0:1*/+1 {
  rule #0: _ y = y+1
  state 0: #0
	<var> state 1
  state 1: #0
};
{
  rule #0: g = \y -> y+1
  state 0: #0
}
f/*0*/ with f x/*0:1*/ = y/*0:*/ when y/*0:*/ = x/*0:1*/+1 {
  rule #0: y = x+1
  state 0: #0
	<var> state 1
  state 1: #0
} end {
  rule #0: f x = y when y = x+1 end
  state 0: #0
	<var> state 1
  state 1: #0
} end;
f
f/*0*/ with f x/*0:1*/ = y/*0*/ with y = x/*1:1*/+1 {
  rule #0: y = x+1
  state 0: #0
} end {
  rule #0: f x = y with y = x+1 end
  state 0: #0
	<var> state 1
  state 1: #0
} end;
f
get_macdef (*);
[]
get_macdef ($);
[f$x-->f x]
get_fundef bla;
[]
get_fundef ($);
[f$x-->f x]
fact n/*0:1*/ = n/*0:1*/*fact (n/*0:1*/-1) if n/*0:1*/>0;
fact n/*0:1*/ = 1;
{
  rule #0: fact n = n*fact (n-1) if n>0
  rule #1: fact n = 1
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
}
fact __with__ get_fundef fact;
fact __with__ [(fact n-->n*fact (n-1) __if__ n>0),(fact n-->1)]
{
  rule #0: x = eval (fact __with__ get_fundef fact)
  state 0: #0
	<var> state 1
  state 1: #0
}
let x = eval (fact __with__ get_fundef fact);
map x (0..10);
[1,1,2,6,24,120,720,5040,40320,362880,3628800]
foldr __with__ get_fundef foldr;
foldr __with__ [(foldr f a (x __type__ matrix)-->__C::matrix_foldr f a x),(foldr f a (s __type__ string)-->foldr f a (chars s)),(foldr f a []-->a),(foldr f a (xs __as__ (_:_))-->tick [] xs __with__ [(tick zs (x:xs)-->tack (x:zs) (foldr f a xs&) __if__ thunkp xs),(tick zs (x:xs)-->tick (x:zs) xs),(tick zs []-->tack zs a),(tick zs xs-->tack zs (foldr f a xs)),(tack (x:xs) y-->tack xs (f x y)),(tack [] y-->y)])]
{
  rule #0: x = eval (foldr __with__ get_fundef foldr)
  state 0: #0
	<var> state 1
  state 1: #0
}
let x = eval (foldr __with__ get_fundef foldr);
x (*) 1 (1..10);
3628800
fold f/*0:001*/ a/*0:01*/ [] = a/*0:01*/;
fold f/*0:001*/ a/*0:01*/ xs@(_/*0:101*/:_/*0:11*/) = tick/*0*/ [] xs/*0:1*/ with tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tack/*1*/ (x/*0:101*/:zs/*0:01*/) (fold f/*2:001*/ a/*2:01*/ xs/*1:11*/&) if thunkp xs/*0:11*/; tick zs/*0:01*/ (x/*0:101*/:xs/*0:11*/) = tick/*1*/ (x/*0:101*/:zs/*0:01*/) xs/*0:11*/; tick zs/*0:01*/ [] = tack/*1*/ zs/*0:01*/ a/*1:01*/; tick zs/*0:01*/ xs/*0:1*/ = tack/*1*/ zs/*0:01*/ (fold f/*1:001*/ a/*1:01*/ xs/*0:1*/) {
  rule #0: tick zs (x:xs) = tack (x:zs) (fold f a xs&) if thunkp xs
  rule #1: tick zs (x:xs) = tick (x:zs) xs
  rule #2: tick zs [] = tack zs a
  rule #3: tick zs xs = tack zs (fold f a xs)
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #3
  state 3: #0 #1 #3
	<var> state 4
	<app> state 6
  state 4: #3
	<var> state 5
  state 5: #3
  state 6: #0 #1 #3
	<var> state 7
	: state 10
  state 7: #3
	<var> state 8
  state 8: #3
	<var> state 9
  state 9: #3
  state 10: #0 #1 #3
	<var> state 11
  state 11: #0 #1 #3
	<var> state 12
  state 12: #0 #1 #3
  state 13: #2 #3
}; tack (x/*0:0101*/:xs/*0:011*/) y/*0:1*/ = tack/*1*/ xs/*0:011*/ (f/*1:001*/ x/*0:0101*/ y/*0:1*/); tack [] y/*0:1*/ = y/*0:1*/ {
  rule #0: tack (x:xs) y = tack xs (f x y)
  rule #1: tack [] y = y
  state 0: #0 #1
	<app> state 1
	[] state 7
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
	<var> state 8
  state 8: #1
} end;
{
  rule #0: fold f a [] = a
  rule #1: fold f a xs@(_:_) = tick [] xs with tick zs (x:xs) = tack (x:zs) (fold f a xs&) if thunkp xs; tick zs (x:xs) = tick (x:zs) xs; tick zs [] = tack zs a; tick zs xs = tack zs (fold f a xs); tack (x:xs) y = tack xs (f x y); tack [] y = y end
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
  state 2: #0 #1
	<app> state 3
	[] state 8
  state 3: #1
	<app> state 4
  state 4: #1
	: state 5
  state 5: #1
	<var> state 6
  state 6: #1
	<var> state 7
  state 7: #1
  state 8: #0
}
add_fundef ('[(fold f a []-->a),(fold f a (xs __as__ (_:_))-->tick [] xs __with__ [(tick zs (x:xs)-->tack (x:zs) (fold f a xs&) __if__ thunkp xs),(tick zs (x:xs)-->tick (x:zs) xs),(tick zs []-->tack zs a),(tick zs xs-->tack zs (fold f a xs)),(tack (x:xs) y-->tack xs (f x y)),(tack [] y-->y)])]);
()
fold (*) 1 (1..10);
3628800
def app f/*0:01*/ x/*0:1*/ = f/*0:01*/ x/*0:1*/;
add_macdef ('[app f x-->f x]);
()
h x/*0:01*/ y/*0:1*/ = x/*0:01*/+y/*0:1*/;
{
  rule #0: h x y = x+y
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
}
h 2 3;
5
