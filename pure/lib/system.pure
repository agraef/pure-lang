
/* Pure system interface. Or at least its beginnings. */

/* NOTE: This module isn't loaded by the standard prelude right now, so you'll
   have to add the clause 'using system;' to your programs in which you want
   to use this interface. */

/* Copyright (c) 2008, 2009 by Albert Graef <Dr.Graef@t-online.de>.

   This file is part of the Pure standard library.

   The Pure standard library is free software: you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
   more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */

/* ..

   System Interface
   ================

   This module offers some useful system routines, straight from the C
   library, as well as some convenience functions for wrapping these up in
   Pure. Even the "purest" program needs to do some basic I/O every once in a
   while, and this module provides the necessary stuff to do just that. The
   interface is rather minimalistic and preliminary right now, but will
   probably grow over time, and it already offers many common system functions
   that Pure programmers might want to use in their scripts.

   Most of the following functions are extensively documented in the C library
   manual pages, so we concentrate on the Pure-specific aspects here.

   Imports
   -------

   To use the operations of this module, add the following import declaration
   to your program::

     using system; */

/* Provide some useful values as global variables. These also include the
   standard I/O streams and various constants related to the I/O, glob and
   regex functions. After loading this module, see show -gcv * for a list of
   these. */

namespace __C;
extern void pure_sys_vars(); pure_sys_vars;
namespace;

/* ..

   Errno and Friends
   -----------------

   .. _errno:
   .. _set_errno:
   .. _perror:
   .. _strerror:

   ``errno``, ``set_errno n``, ``perror msg``, ``strerror n``
     This value and the related routines are indispensable to give proper
     diagnostics when system calls fail for some reason. Note that, by its
     very nature, ``errno`` is a fairly volatile value, don't expect it to
     survive a return to the command line in interactive sessions.

   Example::

     > using system;
     > fopen "junk" "r", perror "junk";
     junk: No such file or directory
     fopen "junk" "r"

*/

extern int pure_errno() = errno, void pure_set_errno(int) = set_errno;
extern void perror(char*), char* strerror(int);

/* ..

   POSIX Locale
   ------------

   .. _setlocale:

   ``setlocale category locale``
     Set or retrieve the current locale.

   Details are platform-specific, but you can expect that at least the
   categories ``LC_ALL``, ``LC_COLLATE``, ``LC_CTYPE``, ``LC_MONETARY``,
   ``LC_NUMERIC`` and ``LC_TIME`` are defined, as well as the following values
   for the locale parameter: ``"C"`` or ``"POSIX"`` (the default POSIX
   locale), ``""`` (the system default locale), and ``NULL``, to just query
   the current locale.

   Other string values which can be passed as the locale argument depend on
   the implementation, please check your local setlocale(3) documentation for
   details. If locale is not ``NULL``, the current locale is changed
   accordingly. The return value is the new locale, or the current locale when
   passing ``NULL`` for the locale parameter. In either case, the string
   returned by ``setlocale`` is such that it can be passed to ``setlocale`` to
   restore the same locale again. In case of an error, ``setlocale`` fails
   (rather than returning a null pointer).

   Please note that calling this function alters the Pure interpreter's idea
   of what the current locale is. When the interpreter starts up, it always
   sets the default system locale. Unless your scripts rely on a specific
   encoding, setting the locale to either ``"C"`` or ``""`` should always be
   safe.

   Example::

     > setlocale LC_ALL NULL;
     "en_US.UTF-8"

*/

namespace __C;
extern void* setlocale(int category, void* locale);
namespace;

setlocale category::int locale = cstring_dup res if ~null res when
  res = case locale of
          _::string  = __C::setlocale category $ sentry free $
                       byte_cstring locale;
          _::pointer = __C::setlocale category locale if null locale;
          _          = pointer 0 otherwise;
        end;
end;

/* ..

   Signal Handling
   ---------------

   .. _trap:

   ``trap action sig``
     Establish or remove Pure signal handlers.

   The action parameter of ``trap`` can be one of the predefined integer
   values ``SIG_TRAP``, ``SIG_IGN`` and ``SIG_DFL``. ``SIG_TRAP`` causes the
   given signal to be handled by mapping it to a Pure exception of the form
   ``signal sig``. ``SIG_IGN`` ignores the signal, ``SIG_DFL`` reverts to the
   system's default handling. See ``show -g SIG*`` for a list of known signal
   values on your system.

   Note: When the interpreter runs interactively, most standard termination
   signals (``SIGINT``, ``SIGTERM``, etc.) are already set up to report
   corresponding Pure exceptions; if this is not desired, you can use ``trap``
   to either ignore these or revert to the default handlers instead.

   See `Exception Handling`_ in the Pure Manual for details and examples. */

extern void pure_trap(int action, int sig) = trap;

/* ..

   Time Functions
   --------------

   .. _time:

   ``time``
     Reports the current time in seconds since the `epoch`, 00:00:00 UTC, Jan
     1 1970. The result is always a bigint (in fact, the ``time`` value is
     already 64 bit on many OSes nowadays). */

extern int64 pure_time() = time;

/* ..

   The following functions are provided to convert a time value to
   "broken-down" time or a string. See the ctime(3), gmtime(3), localtime(3),
   asctime(3) and strftime(3) manual pages for details.

   .. _ctime:

   ``ctime t``
     Convert a time value as returned by the ``time`` function to a string in
     local time.

   .. _gmtime:
   .. _localtime:

   ``gmtime t``, ``localtime t``
     Convert a time value to UTC or local time in "broken-down" form (a static
     pointer to a ``tm`` struct containing a bunch of ``int`` fields) which
     can then be passed to the ``asctime`` and ``strftime`` functions, or to
     |int_matrix|_ if you want to convert the data to a matrix; see the
     example below.

   .. |int_matrix| replace:: ``int_matrix``

   .. _asctime:
   .. _strftime:

   ``asctime tm``, ``strftime format tm``
     Format broken-down time as a string. ``strftime`` also uses a format
     string supplied by the user.

   For instance::

     > let tm = localtime time; tm;
     #<pointer 0x7f1292131de0>
     > asctime tm;
     "Sat Mar 14 01:07:18 2009\n"
     > int_matrix 9 tm;
     {18,7,1,14,2,109,6,72,0}

*/

extern char* pure_ctime(int64) = ctime;
extern void* pure_gmtime(int64) = gmtime;
extern void* pure_localtime(int64) = localtime;
extern char* asctime(void *tm);
extern char* pure_strftime(char* format, void *tm) = strftime;

/* ..

   We also provide some functions to retrieve wallclock and cpu time which
   usually offer much better resolution than ``time``.

   .. _gettimeofday:

   ``gettimeofday``
     Returns wallclock time as seconds since the epoch, like ``time``, but
     theoretically offers resolutions in the microsec range (actual
     resolutions vary, but are usually in the msec range for contemporary
     systems). The result is returned as a double value (which also limits
     precision). This function may actually be implemented through different
     system calls, depending on what's available on the host OS. */

extern double pure_gettimeofday() = gettimeofday;

/* .. _clock:

   ``clock``
     Returns the current CPU (not wallclock) time since an arbitrary point in
     the past, as a machine int. The number of "ticks" per second is given by
     the ``CLOCKS_PER_SEC`` constant. Note that this value will wrap around
     approximately every 72 minutes. */

extern int clock();

/* .. _sleep:
   .. _nanosleep:

   ``sleep t``, ``nanosleep t``
     Suspend execution for a given time interval in seconds. ``sleep`` takes
     integer (int/bigint) arguments only and uses the ``sleep()`` system
     function. ``nanosleep`` also accepts double arguments and theoretically
     supports resolutions down to 1 nanosecond (again, actual resolutions
     vary). This function may actually be implemented through different system
     calls, depending on what's available on the host OS. Both functions
     usually return zero, unless the sleep was interrupted by a signal, in
     which case the time remaining to be slept is returned. */

extern int sleep(int);
extern double pure_nanosleep(double) = nanosleep;

nanosleep t::int | nanosleep t::bigint = nanosleep (double t);

/* ..

   Process Functions
   -----------------

   The following process functions are available on all systems. Please note
   that, as of Pure 0.28, some additional process-related functions such as
   ``fork``, ``kill``, ``wait`` and ``waitpid`` are available in the posix
   module, which can be used together with the system module if the additional
   functionality is required.

   .. _exit:

   ``exit status``
     Terminate the program with the given status code.

   .. _system:

   ``system cmd``
     Execute a shell command.

   .. _execv:
   .. _execvp:
   .. _execve:

   ``execv prog argv``, ``execvp prog argv``, ``execve prog argv envp``
     Execute a new process. ``prog`` denotes the name of the executable to be
     run, ``argv`` the argument vector (which repeats the program name in the
     first component), and ``envp`` a vector of environment strings of the
     form ``"var=value"``. The ``execv`` function executes the program
     ``prog`` exactly as given, while ``execvp`` also performs a path
     search. The ``execve`` function is like ``execv``, but also specifies an
     environment to be passed to the process. In either case, the new process
     replaces the current process. For convenience, both ``argv`` and ``envp``
     can be specified as Pure string lists, which are automatically translated
     to the raw, ``NULL``-terminated C string vectors (i.e., ``char**``)
     required by the underlying C functions, using the
     ``byte_cstring_pointer`` function (see `Low-Level Operations`_ in the
     `String Functions`_ section).

   .. _spawnv:
   .. _spawnvp:
   .. _spawnve:

   ``spawnv mode prog argv``, ``spawnvp mode prog argv``, ``spawnve mode prog argv envp``
     Spawn a new child process. These work like the corresponding MS Windows
     functions; on Un*x systems this functionality is implemented using a
     combination of ``fork`` and ``execv``. The arguments are the same as for
     the ``execv`` functions, except that there's an additional ``mode``
     argument which specifies how the process is to be executed: ``P_WAIT``
     waits for the process to finish, after which ``spawnv`` returns with the
     exit status of the terminated child process; ``P_NOWAIT`` makes
     ``spawnv`` return immediately, returning the process id; and
     ``P_OVERLAY`` causes the child process to replace its parent, just like
     with ``execv``. (On Windows, there's an additional ``P_DETACH`` flag
     which works like ``P_NOWAIT`` but also turns the child process into a
     background task.)

   Examples::

     > system "pwd";
     /home/ag/svn/pure-lang/trunk/pure/lib
     0

     > spawnvp P_WAIT "pwd" ["pwd"];
     /home/ag/svn/pure-lang/trunk/pure/lib
     0
     > spawnv P_WAIT "/bin/sh" ["/bin/sh","-c","pwd"];
     /home/ag/svn/pure-lang/trunk/pure/lib
     0

     > exit 0; // This exits from the interpreter with the given status code.

*/

extern void exit(int status);
extern int system(char* cmd);

extern int execv(char *prog, char **argv);
extern int execvp(char *prog, char **argv);
extern int execve(char *prog, char **argv, char **envp);

execv prog::string argv =
  execv prog (byte_cstring_pointer argv) if listp argv;
execvp prog::string argv =
  execvp prog (byte_cstring_pointer argv) if listp argv;
execve prog::string argv envp =
  execve prog (byte_cstring_pointer argv) (byte_cstring_pointer envp)
  if listp argv && listp envp;

extern int spawnv(int mode, char *prog, char **argv);
extern int spawnvp(int mode, char *prog, char **argv);
extern int spawnve(int mode, char *prog, char **argv, char **envp);

spawnv mode::int prog::string argv =
  spawnv mode prog (byte_cstring_pointer argv) if listp argv;
spawnvp mode::int prog::string argv =
  spawnvp mode prog (byte_cstring_pointer argv) if listp argv;
spawnve mode::int prog::string argv envp =
  spawnve mode prog (byte_cstring_pointer argv) (byte_cstring_pointer envp)
  if listp argv && listp envp;

/* ..

   Basic I/O Interface
   -------------------

   Note that this module also defines the standard I/O streams ``stdin``,
   ``stderr`` and ``stdout`` as variables on startup. These are ready to be
   used with the operations described below. Also note that for convenience
   some of the following routines are actually Pure wrappers, rather than just
   providing the raw C library routines.

   .. _fopen:
   .. _popen:

   ``fopen name mode``, ``popen cmd mode``
     Open a file or a pipe. These take care of closing a file object
     automagically when it's garbage-collected, and fail (instead of returning
     a null pointer) in case of error, so that you can provide any desired
     error handling simply by adding suitable equations.

   .. _fdopen:

   ``fdopen fd mode``
     Associates a file object with a given existing file descriptor. Otherwise
     works like ``fopen``, so the resulting file is closed automatically when
     it's garbage-collected.

   .. _freopen:

   ``freopen path mode fp``
     Reopens a file object. The existing file object is closed. Otherwise
     works like ``fopen``, so the resulting file is closed automatically when
     it's garbage-collected.

   .. _fclose:
   .. _pclose:

   ``fclose fp``, ``pclose fp``
     Close a file or a pipe.

   .. _tmpfile:

   ``tmpfile``
     Creates a unique temporary file (opened in ``"w+b"`` mode) which gets
     deleted automatically when it is closed or the file object gets
     garbage-collected.

   .. _feof:
   .. _ferror:
   .. _clearerr:

   ``feof fp``, ``ferror fp``, ``clearerr fp``
     Check the end-of-file and error bits. ``clearerr`` clears the error bit.

   .. _fileno:

   ``fileno fp``
     Returns the file descriptor associated with the given file.

   .. _fflush:

   ``fflush fp``
     Flushes the given file (or all open files if ``fp`` is ``NULL``).

   .. _fgets:
   .. _gets:

   ``fgets fp``, ``gets``
     Pure wrappers for the C ``fgets`` and ``gets`` functions which handle the
     necessary buffering automatically.

   .. _fget:

   ``fget fp``
     A variation of ``fgets`` which slurps in an entire text file at once.

   .. _fputs:
   .. _puts:

   ``fputs s fp``, ``puts s``
     Output a string to the given file or ``stdout``, respectively. These
     are just the plain C functions. Note that ``puts`` automatically adds
     a newline, while ``fputs`` doesn't. Hmm.

   .. _fread:
   .. _fwrite:

   ``fread ptr size nmemb fp``, ``fwrite ptr size nmemb fp``
     Binary read/writes. Here you'll have to manage the buffers yourself.
     See the corresponding manual pages for details.

   .. _fseek:
   .. _ftell:
   .. _rewind:

   ``fseek fp offset whence``, ``ftell fp``, ``rewind fp``
     Reposition the file pointer and retrieve its current value. The constants
     ``SEEK_SET``, ``SEEK_CUR`` and ``SEEK_END`` can be used for the
     ``whence`` argument of ``fseek``. The call ``rewind fp`` is equivalent to
     ``fseek fp 0 SEEK_SET`` (except that the latter also returns a result
     code). See the corresponding manual pages for details.

   .. _setbuf:
   .. _setvbuf:

   ``setbuf fp buf``, ``setvbuf fp buf mode size``
     Set the buffering of a file object, given as the first argument. The
     second argument specifies the buffer, which must be a pointer to suitably
     allocated memory or ``NULL``. The ``mode`` argument of ``setvbuf``
     specifies the buffering mode, which may be one of the predefined
     constants ``_IONBF``, ``_IOLBF`` and ``_IOFBF`` denoting no buffering,
     line buffering and full (a.k.a. block) buffering, respectively; the
     ``size`` argument denotes the buffer size.

     For ``setbuf``, the given buffer must be able to hold ``BUFSIZ``
     characters, where ``BUFSIZ`` is a constant defined by this module.
     ``setbuf fp buf`` is actually equivalent to the following call (except
     that ``setvbuf`` also returns an integer return value)::

       setvbuf fp buf (if null buf then _IONBF else _IOFBF) BUFSIZ

     Please see the setbuf(3) manual page for details.

   Examples::

     > puts "Hello, world!";
     Hello, world!
     14

     > map fileno [stdin,stdout,stderr];
     [0,1,2]

     > let fp = fopen "/etc/passwd" "r";
     > fgets fp;
     "at:x:25:25:Batch jobs daemon:/var/spool/atjobs:/bin/bash\n"
     > fgets fp;
     "avahi:x:103:104:User for Avahi:/var/run/avahi-daemon:/bin/false\n"
     > ftell fp;
     121L
     > rewind fp;
     ()
     > fgets fp;
     "at:x:25:25:Batch jobs daemon:/var/spool/atjobs:/bin/bash\n"

     > split "\n" $ fget $ popen "ls *.pure" "r";
     ["array.pure","dict.pure","getopt.pure","heap.pure","math.pure",
     "matrices.pure","prelude.pure","primitives.pure","quasiquote2.pure",
     "quasiquote.pure","set.pure","strings.pure","system.pure",""]

*/

namespace __C;
extern FILE* fopen(char* name, char* mode);
extern FILE* popen(char* cmd, char* mode);
extern FILE* fdopen(int fd, char* mode);
extern FILE* freopen(char* name, char* mode, FILE* fp);
extern int fclose(FILE* fp), int pclose(FILE* fp);
extern char* fgets(void* buf, int size, FILE* fp);
namespace;

extern FILE* tmpfile();
extern int fflush(FILE* fp);
extern int fputs(char* s, FILE* fp), int puts(char* s);
extern size_t fread(void* ptr, size_t size, size_t nmemb, FILE* fp);
extern size_t fwrite(void* ptr, size_t size, size_t nmemb, FILE* fp);
extern void clearerr(FILE* fp);
extern int feof(FILE* fp), int ferror(FILE* fp);
extern int fileno(FILE* fp);

extern int fseek(FILE* fp, long offset, int whence);
extern long ftell(FILE *fp);
extern void rewind(FILE *fp);

extern void setbuf(FILE* fp, void* buf);
extern int setvbuf(FILE* fp, void* buf, int mode, size_t size);

/* Pure wrappers for fopen/fdopen/freopen/popen and fclose/pclose which take
   care of closing a file object automagically when it's garbage-collected.
   Please note that these fail (instead of returning a null pointer) in case
   of error, so that you can provide any desired error handling simply by
   adding suitable equations. */

fopen name::string mode::string = sentry __C::fclose fp if ~null fp
when fp = __C::fopen name mode end;

fdopen fd::int mode::string = sentry __C::fclose fp if ~null fp
when fp = __C::fdopen fd mode end;

freopen name::string mode::string fp::pointer = sentry __C::fclose fp
if ~null fp when clear_sentry fp; fp = __C::freopen name mode fp end;

popen name::string mode::string = sentry __C::pclose fp if ~null fp
when fp = __C::popen name mode end;

fclose fp::pointer = clear_sentry fp $$ __C::fclose fp;
pclose fp::pointer = clear_sentry fp $$ __C::pclose fp;

/* Pure wrappers for fgets and gets which handle the necessary buffering
   automatically. */

fgets f::pointer = read_a_line f buf "" when buf = malloc 1024 end
with read_a_line f buf t = check s when s = __C::fgets buf 1024 f end
  with check s::string = return (t+s) if done s;
		       = read_a_line f buf (t+s) otherwise;
       check s         = return s if null t;
                       = return t otherwise;
       done s::string  = feof f || ferror f || ~null s && last s == "\n";
       return x        = free buf $$ x;
  end;
end;

gets = if null s then s else if last s == "\n" then init s else s
when s = fgets stdin end;

/* A variation of fgets which slurps in an entire text file at once. */

fget f::pointer = read_a_file f buf "" when buf = malloc 0x10000 end
with read_a_file f buf t = check s when s = __C::fgets buf 0x10000 f end
  with check s::string = return (t+s) if feof f || ferror f;
		       = read_a_file f buf (t+s) otherwise;
       check s         = return s if null t;
                       = return t otherwise;
       return x        = free buf $$ x;
  end;
end;

/* ..

   C-style formatted I/O is provided through the following wrappers for the C
   ``printf`` and ``scanf`` functions. Our wrapper functions take or return a
   tuple of values, and check these against the format specifiers, so they
   shouldn't segfault. However, only simple formats derived from ``%cdioux``,
   ``%efg``, ``%s`` and ``%p`` are supported right now.

   .. _printf:
   .. _fprintf:

   ``printf format args``, ``fprintf fp format args``
     Print a formatted string to ``stdout`` or the given file, respectively.
     Normally, these functions return the result of the underlying C routines
     (number of characters written, or negative on error). However, in case of
     an abnormal condition in the wrapper function (error in format string,
     argument mismatch), they will throw an exception.

   .. _sprintf:

   ``sprintf format args``
     Print a formatted string to a buffer and return the result as a string.
     Unlike the C routine, this wrapper just returns the string result, or a
     null pointer in case of an error; otherwise, the error handling is the
     same as with ``printf`` and ``fprintf``. The implementation actually uses
     the C routine ``snprintf`` for safety, and a suitable output buffer is
     provided automatically. */

/* Since Pure cannot call C varargs functions directly, the runtime provides
   us with some functions which only process a single argument at a time. */

using namespace __C, system;

namespace __C;
extern int pure_fprintf(FILE *fp, char *format);
extern int pure_fprintf_int(FILE *fp, char *format, int x);
extern int pure_fprintf_double(FILE *fp, char *format, double x);
extern int pure_fprintf_string(FILE *fp, char *format, char *x);
extern int pure_fprintf_pointer(FILE *fp, char *format, void *x);
namespace;

namespace system;
private printf_split_format printf_format_spec printf_format_str;
namespace;

printf format::string args = fprintf stdout format args;

fprintf fp::pointer format::string args = count when
  args = if tuplep args then list args else [args];
  count, _ = catch error_handler
    (foldl (do_fprintf fp) (0,args) $ printf_split_format format);
end with
  error_handler (printf_error res::int) = res, [];
  error_handler x = throw x otherwise;
  do_fprintf fp (count,arg:args) (printf_format_spec t s) = count, args
  when
    res = case t, arg of
      "c", x::int | "c", x::bigint |
      "d", x::int | "d", x::bigint = pure_fprintf_int fp s x;
      "g", x::double = pure_fprintf_double fp s x;
      "s", x::string = pure_fprintf_string fp s x;
      "p", x::string | "p", x::pointer = pure_fprintf_pointer fp s x;
      _ = throw (printf_value_error s arg);
    end;
    count = if res>=0 then count+res else throw (printf_error res);
  end;
  do_fprintf fp (count,args) (printf_format_str s) = count, args
  when
    res = pure_fprintf fp s;
    count = if res>=0 then count+res else throw (printf_error res);
  end;
  do_fprintf fp (count,[]) (printf_format_spec t s) =
    throw (printf_value_error s ());
  do_fprintf fp (count,_) _ = throw (this_cant_happen count);
end;

printf_split_format format = regexg analyze
  "(%[-#0 ]?[0-9]*([.][0-9]*)?[cdiouxXeEfgGsp])|(%)|([^%]|%%)+"
  REG_EXTENDED format 0
with
  analyze info =
    if p>=0 then // format specifier
      printf_format_spec (format_type (last u)) u
    else if q>=0 then // error
      throw (printf_format_error q)
    else printf_format_str u // literal
  when
    _, u = reg 0 info; // matched portion of the format string
    p, _ = reg 1 info; // p>=0 indicates valid format specifier
    q, _ = reg 3 info; // q>=0 indicates unrecognized format specifier
  end;
  format_type x = 
    if index "diouxX" x >= 0 then "d"
    else if index "eEfgG" x >= 0 then "g"
    else x;
end;

namespace __C;
extern int pure_snprintf(void *buf, int, char *format);
extern int pure_snprintf_int(void *buf, int, char *format, int x);
extern int pure_snprintf_double(void *buf, int, char *format, double x);
extern int pure_snprintf_string(void *buf, int, char *format, char *x);
extern int pure_snprintf_pointer(void *buf, int, char *format, void *x);
namespace;

sprintf format::string args = s when
  args = if tuplep args then list args else [args];
  s, _ = catch error_handler
    (foldl do_sprintf ("",args) $ printf_split_format format);
end with
  error_handler (printf_error res::int) = pointer 0, [];
  error_handler x = throw x otherwise;
  do_sprintf (u,arg:args) (printf_format_spec t s) = u, args
  when
    size = case t, arg of
      "s", x::string = #s+#x+1000; // guestimate
      _ = 64; // should be enough for number formats in any case
    end;
    buf = check_buf (malloc size);
    res = case t, arg of
      "c", x::int | "c", x::bigint |
      "d", x::int | "d", x::bigint = pure_snprintf_int buf size s x;
      "g", x::double = pure_snprintf_double buf size s x;
      "s", x::string = pure_snprintf_string buf size s x;
      "p", x::string | "p", x::pointer = pure_snprintf_pointer buf size s x;
      _ = free buf $$ throw (printf_value_error s arg);
    end;
    u = if res>=0 then u + cstring buf
        else free buf $$ throw (printf_error res);
  end;
  do_sprintf (u,args) (printf_format_str s) = u, args
  when
    size = #s+1000; buf = check_buf (malloc size);
    res = pure_snprintf buf size s;
    u = if res>=0 then u + cstring buf
        else free buf $$ throw (printf_error res);
  end;
  do_sprintf (u,[]) (printf_format_spec t s) =
    throw (printf_value_error s ());
  do_sprintf (u,_) _ = throw (this_cant_happen u);
  check_buf buf = throw malloc_error if null buf;
                = buf otherwise;
end;

/* .. _scanf:
   .. _fscanf:

   ``scanf format``, ``fscanf fp format``
     Read formatted input from ``stdin`` or the given file, respectively.
     These normally return a tuple (or singleton) with the converted
     values. An exception of the form ``scanf_error ret``, where ``ret`` is
     the tuple of successfully converted values (which may be less than the
     number of requested input items), is thrown if end-of-file was met or
     another error occurred while still reading. The handling of other
     abnormal conditions (e.g., error in format string) is analogous to
     ``printf`` et al. Also note that our implementation here doesn't accept
     any of the length modifiers used by the C routines. Floating point values
     will *always* be read in double precision, so you just specify ``"e"``,
     ``"g"`` etc. for these. However, the "assignment suppression" flag
     ``"*"`` *is* understood; the corresponding items will not be returned. */

namespace __C;
extern int pure_fscanf(FILE *fp, char *format);
extern int pure_fscanf_int(FILE *fp, char *format, int *x);
extern int pure_fscanf_double(FILE *fp, char *format, double *x);
extern int pure_fscanf_string(FILE *fp, char *format, void *x);
extern int pure_fscanf_pointer(FILE *fp, char *format, void **x);
namespace;

namespace system;
private scanf_split_format scanf_format_spec scanf_format_str;
namespace;

scanf format::string = fscanf stdin format;

fscanf fp::pointer format::string = tuple $ reverse ret when
  _, ret = catch error_handler
    (foldl (do_fscanf fp) (0,[]) $ scanf_split_format format);
end with
  error_handler (scanf_error ret) = throw (scanf_error (tuple $ reverse ret));
  error_handler x = throw x otherwise;
  do_fscanf fp (nread,ret) (scanf_format_spec t s) = nread+res, ret
  when
    // 16 bytes should be more than enough to hold any elementary type;
    // for the string case, see guestimate below.
    size, s = if t=="s" then guestimate s else 16, s;
    // Make sure to zero the buffer here, since %c doesn't store a terminal
    // null byte.
    buf = check_buf (calloc size 1);
    res = case t of
      "n" = pure_fscanf_int fp s buf;
      "d" = pure_fscanf_int fp s buf;
      "g" = pure_fscanf_double fp s buf;
      "s" = pure_fscanf_string fp s buf;
      "p" = pure_fscanf_pointer fp s buf;
      _ = throw (this_cant_happen ret);
    end;
    // Note: In difference to C scanf, the return value is the number of read
    // characters here, with -1 denoting an error condition.
    res = if res>=0 then res
          else free buf $$ throw (scanf_error ret);
    val = case t of
      "n" = nread+get_int buf;
      "d" = get_int buf;
      "g" = get_double buf;
      "s" = cstring buf;
      "p" = get_pointer buf;
      _ = throw (this_cant_happen ret);
    end;
    _ = if t=="s" then () else free buf;
    ret = val:ret;
  end;
  do_fscanf fp (nread,ret) (scanf_format_str s) = nread+res, ret
  when
    res = pure_fscanf fp s;
    ret = if res>=0 then ret else throw (scanf_error ret);
  end;
  do_fscanf _ (_,ret) _ = throw (this_cant_happen ret);
  check_buf buf = throw malloc_error if null buf;
                = buf otherwise;
  // Compute a reasonable size for a string buffer; if necessary, modify the
  // field width of the format accordingly.
  guestimate "%c" = 2, "%c";
  guestimate format = n, format
  when
    1,0,_,1,s = regex "^%([0-9]*)" REG_EXTENDED format 0;
    // Leave one extra byte for the null terminator.
    n, format = if null s then 1025, "%1024"+tail format else eval s+1, format;
  end;
end;

scanf_split_format format = regexg analyze
  "(%[*]?[0-9]*([cdiouxXneEfgsp]|\\[\\^?\\]?[^]]+\\]))|(%)|([^%]|%%)+"
  REG_EXTENDED format 0
with
  analyze info =
    if p>=0 && u!1~="*" then // format specifier
      (scanf_format_spec t (kludge t u) when t = format_type (last u) end)
    else if q>=0 then // error
      throw (scanf_format_error q)
    else scanf_format_str u // literal
  when
    _, u = reg 0 info; // matched portion of the format string
    p, _ = reg 1 info; // p>=0 indicates valid format specifier
    q, _ = reg 3 info; // q>=0 indicates unrecognized format specifier
  end;
  format_type x = 
    if x == "n" then "n"
    else if index "diouxX" x >= 0 then "d"
    else if index "eEfg" x >= 0 then "g"
    else if x=="]" || x=="c" then "s"
    else x;
  // fix up the format specifier for double values (needs 'l' modifier)
  kludge "g" u = init u + "l" + last u;
  kludge _ u = u otherwise;
end;

/* .. _sscanf:

   ``sscanf s format``
     This works exactly like ``fscanf``, but input comes from a string (first
     argument) rather than a file.

   Examples::

     > do (printf "%s%d\n") [("foo",5),("catch",22)];
     foo5
     catch22
     ()
     > sscanf "foo 5 22" "%s %d %g";
     "foo",5,22.0

*/

namespace __C;
extern int pure_sscanf(char *buf, char *format);
extern int pure_sscanf_int(char *buf, char *format, int *x);
extern int pure_sscanf_double(char *buf, char *format, double *x);
extern int pure_sscanf_string(char *buf, char *format, void *x);
extern int pure_sscanf_pointer(char *buf, char *format, void **x);
namespace;

sscanf s::string format::string = tuple $ reverse ret when
  _, _, ret = catch error_handler
    (foldl do_sscanf (s,0,[]) $ scanf_split_format format);
end with
  error_handler (scanf_error ret) = throw (scanf_error (tuple $ reverse ret));
  error_handler x = throw x otherwise;
  do_sscanf (u,nread,ret) (scanf_format_spec t s) = u, nread+res, ret
  when
    // 16 bytes should be more than enough to hold any elementary type;
    // for the string case, see guestimate below.
    size, s = if t=="s" then guestimate s else 16, s;
    // Make sure to zero the buffer here, since %c doesn't store a terminal
    // null byte.
    buf = check_buf (calloc size 1);
    res = case t of
      "n" = pure_sscanf_int u s buf;
      "d" = pure_sscanf_int u s buf;
      "g" = pure_sscanf_double u s buf;
      "s" = pure_sscanf_string u s buf;
      "p" = pure_sscanf_pointer u s buf;
      _ = throw (this_cant_happen ret);
    end;
    // Note: In difference to C scanf, the return value is the number of read
    // characters here, with -1 denoting an error condition.
    res = if res>=0 then res
          else free buf $$ throw (scanf_error ret);
    val = case t of
      "n" = nread+get_int buf;
      "d" = get_int buf;
      "g" = get_double buf;
      "s" = cstring buf;
      "p" = get_pointer buf;
      _ = throw (this_cant_happen ret);
    end;
    _ = if t=="s" then () else free buf;
    ret = val:ret;
    u = drop res u;
  end;
  do_sscanf (u,nread,ret) (scanf_format_str s) = u, nread+res, ret
  when
    res = pure_sscanf u s;
    ret = if res>=0 then ret else throw (scanf_error ret);
    u = drop res u;
  end;
  do_sscanf (_,_,ret) _ = throw (this_cant_happen ret);
  check_buf buf = throw malloc_error if null buf;
                = buf otherwise;
  // Compute a reasonable size for a string buffer; if necessary, modify the
  // field width of the format accordingly.
  guestimate "%c" = 2, "%c";
  guestimate format = n, format
  when
    1,0,_,1,s = regex "^%([0-9]*)" REG_EXTENDED format 0;
    // Leave one extra byte for the null terminator.
    n, format = if null s then 1025, "%1024"+tail format else eval s+1, format;
  end;
end;

using namespace;

/* ..

   Stat and Friends
   ----------------

   .. _stat:

   ``stat path``
     Return information about the given file. This is a simple wrapper around
     the corresponding system call, see the stat(2) manual page for
     details. The function returns a tuple with the most important fields from
     the ``stat`` structure, in this order: ``st_dev``, ``st_ino``,
     ``st_mode``, ``st_nlink``, ``st_uid``, ``st_gid``, ``st_rdev``,
     ``st_size``, ``st_atime``, ``st_mtime``, ``st_ctime``. Among these,
     ``st_mode``, ``st_nlink``, ``st_uid`` and ``st_gid`` are simple machine
     integers, the rest is encoded as bigints (even on 32 bit platforms).

   .. _lstat:

   ``lstat path``
     Return information about the given symbolic link (rather than the file
     it points to). On systems where this function isn't supported (e.g.,
     Windows), ``lstat`` is identical to ``stat``.

   .. _fstat:

   ``fstat fp``
     Return information about the given file object. Same as ``stat``, but
     here the file is given as a file pointer created with ``fopen`` (see
     `Basic I/O Interface`_ above). Note that the corresponding system
     function actually takes a file descriptor, so the Pure implementation is
     equivalent to the C call ``fstat(fileno(fp))``. This function might not
     be supported on all platforms.

   For average applications, the most interesting fields are ``st_mode`` and
   ``st_size``, which can be retrieved with ``stat filename!![2,7]``. Note
   that to facilitate access to the ``st_mode`` field, the usual masks and
   bits for file types (``S_IFMT``, ``S_IFREG``, etc.) and permissions
   (``S_ISUID``, ``S_ISGID``, ``S_IRWXU``, etc.) are defined as constants by
   this module.  Use the command ``show -g S_*`` in the interpreter to get a
   full list of these. Other interesting fields are ``st_atime``, ``st_mtime``
   and ``st_ctime``, which can be accessed using ``stat filename!!(8..10)``.
   The values of these fields are the times of last access, last modification
   and creation, respectively, which can be decoded using the appropriate time
   functions like ``ctime`` or ``strftime``, see `Time Functions`_.

   Examples::

     > stat "/etc/passwd";
     64773L,9726294L,33188,1,0,0,0L,1623L,1250373163L,1242692339L,1242692339L
     > stat "/etc/passwd"!7;                                // file size
     1623L
     > strftime "%c" $ localtime $ stat "/etc/passwd"!10;   // creation time
     "Tue 19 May 2009 02:18:59 AM CEST"
     > sprintf "0%o" $ stat "/etc/passwd"!2 and not S_IFMT; // permissions
     "0644"
     > stat "/etc/passwd"!2 and S_IFMT == S_IFREG; // this is a regular file
     1
     > stat "/etc"!2 and S_IFMT == S_IFDIR;        // this is a directory
     1

*/

extern expr* pure_stat(char* path) = stat;
extern expr* pure_lstat(char* path) = lstat;
extern expr* pure_fstat(FILE* fp) = fstat;

/* ..

   Readdir
   -------

   .. _readdir:

   ``readdir name``
     Read the contents of the given directory and return the names of all
     its entries as a list.

   Example::

     > readdir "/home";
     ["ag",".",".."]

*/

/* This is a little wrapper around the C readdir() interface. */

extern expr *pure_readdir(char *name) = readdir;

/* ..

   Shell Globbing
   --------------

   .. _fnmatch:

   ``fnmatch pat s flags``
     Returns a simple truth value (1 if ``pat`` matches ``s``, 0 if it
     doesn't), instead of an error code like the C function.

   .. _glob:

   ``glob pat flags``
     Returns a Pure list with the matches (unless there is an error in which
     case the integer result code of the underlying C routine is returned).

   The available flag values and glob error codes are available as symbolic
   ``FNM_*`` and ``GLOB_*`` constants defined as variables in the global
   environment. See the fnmatch(3) and glob(3) manpages for the meaning of
   these. (In extension to POSIX, Pure also provides the constant
   ``GLOB_SIZE`` which indicates the buffer size required for C ``glob``\ 's
   ``globptr`` argument, but this is only used internally.)

   Example::

     > glob "*.pure" 0;
     ["array.pure","dict.pure","getopt.pure","heap.pure","math.pure",
     "matrices.pure","prelude.pure","primitives.pure","set.pure",
     "strings.pure","system.pure"]

*/

namespace __C;
extern int fnmatch(char* pat, char* s, int flags);
extern int glob(char* pat, int flags, void* errfunc, void* globptr);
extern void globfree(void* globptr);
// runtime function to decode a globptr into a Pure string list
extern expr* globlist(void* globptr);
namespace;

fnmatch pat::string s::string flags::int = __C::fnmatch pat s flags == 0;

glob pat::string flags::int = result
when
  globptr = calloc 1 GLOB_SIZE;
  result = __C::glob pat flags (pointer 0) globptr;
  result = if result==0 then __C::globlist globptr else result;
  __C::globfree globptr; free globptr;
end;

/* ..

   Regex Matching
   --------------

   The POSIX regex functions (``regcomp`` and ``regexec``) have a somewhat
   difficult calling sequence, hence we provide a couple of rather elaborate
   high-level wrapper functions for use in Pure programs. These are
   implemented in terms of a low-level interface provided in the runtime. (The
   low-level interface isn't documented here, but these functions are also
   callable if you want to create your own regular expression engines in Pure.
   You might wish to take a look at the implementation of the high-level
   functions in system.pure to see how this can be done.) */

using namespace __C;

namespace __C;
// Lowlevel interface to the POSIX regex functions provided in the runtime.
extern void* pure_regcomp(char* pat, int cflags) = regcomp;
extern int pure_regexec(void* reg, char* s, int eflags) = regexec;
extern int pure_regnext(void* reg, int overlap) = regnext;
extern void pure_regdone(void* reg) = regdone;
extern void pure_regfree(void* reg) = regfree;
extern int pure_regstatus(void* reg) = regstatus;
extern expr* pure_regerror(void* reg) = regerror;
extern expr* pure_regmatch(void* reg) = regmatch;
extern expr* pure_regskip(void* reg) = regskip;
namespace;

/* .. _regex:

   ``regex pat cflags s eflags``
     Compiles and matches a regex in one go, and returns the list of
     submatches (if any).

   The arguments are:

   - ``pat::string``, the regular expression pattern;

   - ``cflags::int``, the compilation flags (bitwise or of any of the flags
     accepted by regcomp(3));

   - ``s::string``, the subject string to be matched;

   - ``eflags::int``, the matching execution flags (bitwise or of any of the
     flags accepted by regexec(3)).

   Symbolic ``REG_*`` constants are provided for the different flag values,
   see the regcomp(3) manpage for an explanation of these. Two particularly
   important compilation flags (to be included in the ``cflags`` argument) are
   ``REG_NOSUB``, which prevents submatches to be computed, and
   ``REG_EXTENDED``, which switches ``regex`` from "basic" to "extended"
   regular expressions so that it understands all the regular expression
   elements of egrep(1) in the pattern argument.

   Depending on the flags and the outcome of the operation, the result of this
   function can take one of the following forms:

   - ``regerr code msg``: This indicates an error during compilation of the
     pattern (e.g., if there was a syntax error in the pattern). ``code`` is
     the nonzero integer code returned by ``regcomp``, and ``msg`` is the
     corresponding error message string, as returned by ``regerror``. You can
     redefine the ``regerr`` function as appropriate for your application
     (e.g., if you'd like to print an error message or throw an exception).

   - ``0`` or ``1``: Just a truth value indicates whether the pattern matched
     or not. This will be the form of the result if the ``REG_NOSUB`` flag was
     specified for compilation, indicating that no submatch information is to
     be computed.

   - ``0`` (indicating no match), or ``1`` (indicating a successful match),
     where the latter value is followed by a tuple of ``(pos,substr)`` pairs
     for each submatch. This will be the form of the result only if the
     ``REG_NOSUB`` flag was *not* specified for compilation, so that submatch
     information is available.

   Note that, according to POSIX semantics, a return value of 1 does *not*
   generally mean that the entire subject string was matched, unless you
   explicitly tie the pattern to the beginning (``^``) and end (``$``) of the
   string.

   If the result takes the latter form, each ``(pos,substr)`` pair indicates a
   portion of the subject string which was matched; ``pos`` is the position at
   which the match starts, and ``substr`` is the substring (starting at
   position ``pos``) which was matched. The first ``(pos,substr)`` pair always
   indicates which portion of the string was matched by the entire pattern,
   the remaining pairs represent submatches for the parenthesized subpatterns
   of the pattern, as described on the regcomp(3) manual page. Note that some
   submatches may be empty (if they matched the empty string), in which case a
   pair ``(pos,"")`` indicates the (nonnegative) position ``pos`` where the
   subpattern matched the empty string. Other submatches may not participate
   in the match at all, in which case the pair ``(-1,"")`` is returned. */

regex pat::string cflags::int s::string eflags::int
= if regstatus re then regerr (regstatus re) (regerror re)
  else if regexec re s eflags then 0
  else 1,regmatch re when re = sentry regfree (regcomp pat cflags) end;

/* ..

   The following helper functions are provided to analyze the result returned
   by ``regex``.

   .. _reg_result:

   ``reg_result res``
     Returns the result of a ``regex`` call, i.e., a ``regerr`` term if
     compilation failed, and a flag indicating whether the match was
     successful otherwise. */

reg_result (regerr code msg) = regerr code msg;
reg_result b::int = b;
reg_result (b::int,_) = b;

/* .. _reg_info:

   ``reg_info res``
     Returns the submatch info if any, otherwise it returns ``()``. */

reg_info (_::int,info) = info;
reg_info _ = () otherwise;

/* .. _reg:

   ``reg n info``
     Returns the ``n``\ th submatch of the given submatch info, where ``info``
     is the result of a ``reg_info`` call. */

reg 0 (p,s,_) = p,s;
reg 0 (p,s) = p,s;
reg n::int (_,_,infos) = reg (n-1) infos if n>0;

/* .. _regs:

   ``regs info``
     Returns all valid submatches, i.e., the list of all triples ``(n,p,s)``
     for which ``reg n == (p,s)`` with ``p>=0``. */

regs info = myregs 0 info with
  myregs n (p,s,infos)	= (n,p,s):myregs (n+1) infos if p>=0;
			= myregs (n+1) infos otherwise;
  myregs n (p,s)	= [(n,p,s)] if p>=0;
			= [] otherwise;
end;

/* ..

   In addition, the following convenience functions are provided to perform
   global regex searches, to perform substitutions, and to tokenize a string
   according to a given delimiter regex.

   .. _regexg:

   ``regexg f pat cflags s eflags``
     Perform a global regular expression search. This routine will scan the
     entire string for (non-overlapping) instances of the pattern, applies the
     given function ``f`` to the ``reg_info`` for each match, and collects all
     results in a list. Note: Never specify the ``REG_NOSUB`` flag with this
     function, it needs the submatch info. */

regexg f pat::string cflags::int s::string eflags::int
= if regstatus re then regerr (regstatus re) (regerror re)
  else iterwhile check next first
with
  first = if regexec re s eflags then () else f (regmatch re);
  next _ = if regnext re 0 then () else f (regmatch re);
  check _ = regstatus re == 0;
end when re = sentry regfree (regcomp pat cflags) end
if ~(cflags and REG_NOSUB);

/* .. _regexgg:

   ``regexgg f pat cflags s eflags``
     This works like ``regexg``, but allows overlapping matches. */

regexgg f pat::string cflags::int s::string eflags::int
= if regstatus re then regerr (regstatus re) (regerror re)
  else iterwhile check next first
with
  first = if regexec re s eflags then () else f (regmatch re);
  next _ = if regnext re 1 then () else f (regmatch re);
  check _ = regstatus re == 0;
end when re = sentry regfree (regcomp pat cflags) end
if ~(cflags and REG_NOSUB);

/* .. _regsub:

   ``regsub f pat cflags s eflags``
     Replaces all non-overlapping instances of a pattern with a computed
     substitution string. To these ends, the given function ``f`` is applied
     to the ``reg_info`` for each match. The result string is then obtained by
     concatenating ``f info`` for all matches, with the unmatched portions of
     the string in between. To make this work, ``f`` must always return a
     string value; otherwise, ``regsub`` throws a ``bad_string_value``
     exception. */

regsub f pat::string cflags::int s::string eflags::int
= if regstatus re then regerr (regstatus re) (regerror re)
  else strcat (iterwhile check next first) + regskip re
with
  first = if regexec re s eflags then () else regskip re+h (f (regmatch re));
  next _ = if regnext re 0 then () else regskip re+h (f (regmatch re));
  check _ = regstatus re == 0;
  h x::string = x; h x = throw (bad_string_value x) otherwise;
end when re = sentry regfree (regcomp pat cflags) end
if ~(cflags and REG_NOSUB);

/* .. _regsplit:

   ``regsplit pat cflags s eflags``
     Splits a string into constituents delimited by substrings matching the
     given pattern. */

regsplit pat::string cflags::int s::string eflags::int
= if regstatus re then regerr (regstatus re) (regerror re)
  else if null s then []
  else iterwhile check next first + [regskip re]
with
  first = if regexec re s eflags then () else regskip re;
  next _ = if regnext re 0 then () else regskip re;
  check _ = regstatus re == 0;
end when re = sentry regfree (regcomp pat cflags) end
if ~(cflags and REG_NOSUB);

/* ..

   Please note that these operations all operate in an eager fashion, i.e.,
   they process the entire input string in one go. This may be unwieldy or at
   least inefficient for huge amounts of text. As a remedy, the following lazy
   alternatives are available:

   .. _regexgs:
   .. _regexggs:
   .. _regsplits:

   ``regexgs f pat cflags s eflags``

   ``regexggs f pat cflags s eflags``

   ``regsplits pat cflags s eflags``
     These work like ``regexg``, ``regexgg`` and ``regsplit`` above, but
     return a stream result which enables you to process the matches one by
     one, using "call by need" evaluation. */

regexgs f pat::string cflags::int s::string eflags::int
= if regstatus re then regerr (regstatus re) (regerror re)
  else takewhile check (iterate next first)
with
  first = if regexec re s eflags then () else f (regmatch re);
  next _ = if regnext re 0 then () else f (regmatch re);
  check _ = regstatus re == 0;
end when re = sentry regfree (regcomp pat cflags) end
if ~(cflags and REG_NOSUB);

regexggs f pat::string cflags::int s::string eflags::int
= if regstatus re then regerr (regstatus re) (regerror re)
  else takewhile check (iterate next first)
with
  first = if regexec re s eflags then () else f (regmatch re);
  next _ = if regnext re 1 then () else f (regmatch re);
  check _ = regstatus re == 0;
end when re = sentry regfree (regcomp pat cflags) end
if ~(cflags and REG_NOSUB);

regsplits pat::string cflags::int s::string eflags::int
= if regstatus re then regerr (regstatus re) (regerror re)
  else if null s then []
  else takewhile check (iterate next first) + [regskip re]&
with
  first = if regexec re s eflags then () else regskip re;
  next _ = if regnext re 0 then () else regskip re;
  check _ = regstatus re == 0;
  /* We need fully lazy stream concatenation here. (The standard + operator
     isn't lazy enough, because it's also used for arithmetic operations.) */
  []+ys = ys; (x:xs)+ys = x:(xs+ys)&;
end when re = sentry regfree (regcomp pat cflags) end
if ~(cflags and REG_NOSUB);

/* ..

   Basic Examples
   ~~~~~~~~~~~~~~

   Let's have a look at some simple examples::

     > let pat = "[[:alpha:]][[:alnum:]]*";
     > let s = "1var foo 99 BAR $%&";

   Simple match::

     > regex pat 0 s 0;
     1,1,"var"

   Same without match info::

     > regex pat REG_NOSUB s 0;
     1

   Global match, return the list of all matches::

     > regexg id pat 0 s 0;
     [(1,"var"),(5,"foo"),(12,"BAR")]

   Same with overlapping matches::

     > regexgg id pat 0 s 0;
     [(1,"var"),(2,"ar"),(3,"r"),(5,"foo"),(6,"oo"),(7,"o"),(12,"BAR"),
     (13,"AR"),(14,"R")]

   Note that ``id`` (the identity function) in the examples above can be
   replaced with an arbitrary function which processes the matches. For
   instance, if we only want the matched strings instead of the full match
   info::

     > regexg (!1) pat 0 s 0;
     ["var","foo","BAR"]

   Lazy versions of both ``regexg`` and ``regexgg`` are provided which return
   the result as a stream instead. These can be processed in a "call by need"
   fashion::

     > regexgs id pat 0 s 0;
     (1,"var"):#<thunk 0x7fb1b7976750>
     > last ans;
     12,"BAR"

   Let's verify that the processing is really done lazily::

     > test x = printf "got: %s\n" (str x) $$ x;
     > let xs = regexgs test pat 0 s 0;
     got: 1,"var"
     > xs!1;
     got: 5,"foo"
     5,"foo"
     > last xs;
     got: 12,"BAR"
     12,"BAR"

   As you can see, the first match is produced immediately, while the
   remaining matches are processed as the result stream is traversed. This is
   most useful if you have to deal with bigger amounts of text. By processing
   the result stream in a piecemeal fashion, you can avoid keeping the entire
   result list in memory. For instance, compare the following::

     > let s2 = fget $ fopen "system.pure" "r";
     > stats -m
     > #regexg id pat 0 s2 0;
     7977
     0.18s, 55847 cells
     > #regexgs id pat 0 s2 0;
     7977
     0.12s, 20 cells

   Regex Substitutions and Splitting
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   We can also perform substitutions on matches::

     > regsub (sprintf "<%d:%s>") pat 0 s 0;
     "1<1:var> <5:foo> 99 <12:BAR> $%&"

   Or split a string using a delimiter pattern (this uses an egrep pattern)::

     > let delim = "[[:space:]]+";
     > regsplit delim REG_EXTENDED s 0;
     ["1var","foo","99","BAR","$%&"]
     > regsplit delim REG_EXTENDED "The   quick brown    fox" 0;
     ["The","quick","brown","fox"]

   The ``regsplit`` operation also has a lazy variation::

     > regsplits "[[:space:]]+" REG_EXTENDED "The   quick brown    fox" 0;
     "The":#<thunk 0x7fb1b79775b0>
     > last ans;
     "fox"

   Empty Matches
   ~~~~~~~~~~~~~

   Empty matches are permitted, too, subject to the constraint that at most
   one match is reported for each position (which also prevents looping). And
   of course an empty match will only be reported if nothing else matches. For
   instance::

     > regexg id "" REG_EXTENDED "foo" 0;
     [(0,""),(1,""),(2,""),(3,"")]
     > regexg id "o*" REG_EXTENDED "foo" 0;
     [(0,""),(1,"oo"),(3,"")]
     > regexgg id "o*" REG_EXTENDED "foo" 0;
     [(0,""),(1,"oo"),(2,"o"),(3,"")]

   This also works when substituting or splitting::

     > regsub (cst " ") "" REG_EXTENDED "some text" 0;
     " s o m e   t e x t "
     > regsub (cst " ") " ?" REG_EXTENDED "some text" 0;
     " s o m e  t e x t "
     > regsplit "" REG_EXTENDED "some text" 0;
     ["","s","o","m","e"," ","t","e","x","t",""]
     > regsplit " ?" REG_EXTENDED "some text" 0;
     ["","s","o","m","e","","t","e","x","t",""]

   Submatches
   ~~~~~~~~~~

   Parenthesized subexpressions in a pattern yield corresponding submatch
   information, which is useful if we need to retrieve the text matched by a
   given subexpression. For instance, suppose we want to parse environment
   lines, such as those returned by the shell's ``set`` command. These can be
   dissected using the following regex::

     > const env_pat = "^([^=]+)=(.*)$";
     > const env_flags = REG_EXTENDED or REG_NEWLINE;
     > regex env_pat env_flags "SHELL=/bin/sh" 0;
     1,0,"SHELL=/bin/sh",0,"SHELL",6,"/bin/sh"

   Note that we again used an extended regex here, and we also added the
   ``REG_NEWLINE`` flag so that we properly deal with multiline input. The
   desired information is in the 4th and 6th element of the submatch info,
   we can retrieve that as follows::

     > parse_env s = regexg (\info -> info!3 => info!5) env_pat env_flags s 0;
     > parse_env "SHELL=/bin/sh\nHOME=/home/bar\n";
     ["SHELL"=>"/bin/sh","HOME"=>"/home/bar"]

   We can get hold of the real process environment as follows::

     > let env = parse_env $ fget $ popen "set" "r";
     > #env;
     109
     > head env;
     "BASH"=>"/usr/bin/sh"

   Just for the fun of it, let's convert this to a record, providing easy
   random access to the environment variables::

     > let env = record env;
     > env!!["SHELL","HOME"];
     {"/bin/bash","/home/ag"}

*/
