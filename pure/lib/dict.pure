/* Pure's dict and hdict data types based on AVL trees. */

/* Copyright (c) 2008-2010 by Albert Graef <Dr.Graef@t-online.de>.
   Copyright (c) 2008-2010 by Jiri Spitz <jiri.spitz@bluetone.cz>.

   This file is part of the Pure standard library.

   The Pure standard library is free software: you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
   more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */

/* ..

   Dictionaries
   ------------

   The dict.pure module provides Pure's ``Dict`` and ``HDict`` data types
   based on AVL trees. ``Dict`` is an ordered dictionary (assuming an ordered
   key type), ``HDict`` a hashed dictionary which works with any (mixture of)
   key types but stores members in an apparently random order.

   The used AVL tree algorithm has its origin in the SWI-Prolog implementation
   of association lists. The original implementation was created by
   R. A. O'Keefe and updated for SWI-Prolog by Jan Wielemaker. For the
   original source see http://www.swi-prolog.org.

   The port from SWI-Prolog and the deletion stuff (``rmfirst``, ``rmlast``,
   ``delete``) missing in the Prolog implementation was provided by Jiri
   Spitz.

   Imports
   ~~~~~~~

   To use the operations of this module, add the following import declaration
   to your program::

     using dict;

   Data Structure
   ~~~~~~~~~~~~~~

   Dictionaries are represented as balanced tree structures of the form ``Dict
   T`` or ``HDict T``, respectively, thus ``Dict`` and ``HDict`` may be used
   as type tags to restrict variables in pattern matching.

   The internal data structure ``T`` is an AVL tree built with the following
   constructors:

   ``nil``
     the empty tree.

   ``bin (key=>value) balance left right``
     a nonempty tree with given ``key`` and ``value`` in the root node, where
     ``left`` and ``right`` are the left and right subtree, and ``balance``
     is either 1, 0 or -1, denoting ``|left|-|right|`` = 1, 0, or -1,
     respectively.

   (This is for informational purposes only. The tree constructors are
   private, and client modules must not rely on the internal representation.)

   Operations
   ~~~~~~~~~~

   .. _emptydict:
   .. _emptyhdict:

   ``emptydict``, ``emptyhdict``
     return the empty dict or hdict

   .. _dict:
   .. _hdict:

   ``dict xs``, ``hdict xs``
     create a dict or hdict from list ``xs`` of key-value pairs in the form
     ``key=>value``

   .. _dictp:
   .. _hdictp:

   ``dictp d``, ``hdictp d``
     check whether ``x`` is a dict or hdict

   .. _mkdict:
   .. _mkhdict:

   ``mkdict y xs``, ``mkhdict y xs``
     create dict or hdict from a list of keys and a constant value

   .. _# (dict):
   .. _# (hdict):

   ``#d``
     size of dict or hdict ``d``

   .. _! (dict):
   .. _! (hdict):

   ``d!x``
     get value from ``d`` by key ``x``

   .. _null (dict):
   .. _null (hdict):

   ``null d``
     test whether ``d`` is the empty dict or hdict

   .. _member (dict):
   .. _member (hdict):

   ``member d x``
     test whether ``d`` contains a member with key ``x``

   .. _members (dict):
   .. _members (hdict):
   .. _list (dict):
   .. _list (hdict):

   ``members d``, ``list d``
     list members of ``d`` (in ascending order for dict)

   .. _keys:

   ``keys d``
     list keys of ``d`` (in ascending order for dict)

   .. _vals:

   ``vals d``
     list values of ``d``

   .. _first (dict):
   .. _first (hdict):
   .. _last (dict):
   .. _last (hdict):

   ``first d``, ``last d``
     return first and last member of ``d``

   .. _rmfirst (dict):
   .. _rmfirst (hdict):
   .. _rmlast (dict):
   .. _rmlast (hdict):

   ``rmfirst d``, ``rmlast d``
     remove first and last member from ``d``

   .. _insert (dict):
   .. _insert (hdict):
   .. _update (dict):
   .. _update (hdict):

   ``insert d (x=>y)``, ``update d x y``
     insert ``x=>y`` into ``d`` (replace any existing element); ``update`` is
     a fully curried version of ``insert``

   .. _delete (dict):
   .. _delete (hdict):

   ``delete d x``
     remove ``x`` from ``d``

   Examples
   ~~~~~~~~

   A normal (ordered) dictionary::

     > using dict;
     > let d::Dict = dict ["foo"=>77,"bar"=>99.1];
     > keys d; vals d; members d;
     ["bar","foo"]
     [99.1,77]
     ["bar"=>99.1,"foo"=>77]

   Indexing a dictionary works in the usual way, using Pure's ``!`` operator.
   By virtue of the prelude, slicing a dictionary with ``!!`` also works as
   expected::

     > d!"foo";
     77
     > d!!["foo","bar"];
     [77,99.1]

   A hashed dictionary can be used with any key values, which are stored in a
   seemingly random order::

     > let h::HDict = hdict [foo=>77,42=>99.1];
     > keys h; vals h; members h;
     [42,foo]
     [99.1,77]
     [42=>99.1,foo=>77]
     > h!foo;
     77
     > h!!keys h;
     [99.1,77]

*/

using avltrees;

// type checks
dictp _::Dict	= 1;
dictp _		= 0;

hdictp _::HDict	= 1;
hdictp _	= 0;

// create an empty dict
emptydict	= Dict  avl::emptytree;
emptyhdict	= HDict avl::emptytree;

// create a dict from a list
dict  xys	= foldl insert emptydict  xys if listp xys;
hdict xys	= foldl insert emptyhdict xys if listp xys;

// create a dict from a list of keys and a constant value
mkdict  y xs	= dict  (zipwith (=>) xs (repeatn (#xs) y)) if listp xs;
mkhdict y xs	= hdict (zipwith (=>) xs (repeatn (#xs) y)) if listp xs;

// insert a member
insert (Dict  d) el@(x=>y) = Dict  (avl::insertk  d el);
insert (HDict d) el@(x=>y) = HDict (avl::inserthk d el);

// curried version of insert
update d@(Dict  _) x y | update d@(HDict _) x y	= insert d (x=>y);

// delete a member by key
delete (Dict  d) x = Dict  (avl::deletek  d x);
delete (HDict d) x = HDict (avl::deletehk d x);

// check for the empty dict
null (Dict d)	|
null (HDict d)	= avl::null d;

// dict size
#(Dict  d)	= avl::size  d;
#(HDict d)	= avl::sizeh d;

// membership test
member (Dict  d) k = avl::memberk  d k;
member (HDict d) k = avl::memberhk d k;

// get the members, keys and values of a dict as a list
members (Dict  d) = avl::members  d;
members (HDict d) = avl::membersh d;
keys (Dict  d)    = avl::keys  d;
keys (HDict d)    = avl::keysh d;
vals (Dict  d)    = avl::vals  d;
vals (HDict d)    = avl::valsh d;

list d::Dict | list d::HDict = members d;

// get the first and last member
first (Dict d)	= avl::first  d;
last  (Dict d)	= avl::last   d;
first (HDict d)	= avl::firsth d;
last  (HDict d)	= avl::lasth  d;

// remove the first and last member
rmfirst (Dict d)  = Dict  (avl::rmfirst  d);
rmlast  (Dict d)  = Dict  (avl::rmlast   d);
rmfirst (HDict d) = HDict (avl::rmfirsth d);
rmlast  (HDict d) = HDict (avl::rmlasth  d);

// get a value by key
(Dict d)!k	= avl::get d k;
(HDict d)!k	= avl::geth d k;

// equality checks
d1::Dict  == d2::Dict  = (members d1) == (members d2);
d1::HDict == d2::HDict = all (member d1) (keys d2) &&
	     	       	 all (member d2) (keys d1) &&
	  		 (vals d1) == (map (d2!) (keys d1));

d1::Dict ~= d2::Dict   = (members d1) ~= (members d2);
d1::HDict ~= d2::HDict = ~(d1 == d2);
