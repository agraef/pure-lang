/* Pure's dictionary data types based on AVL trees. */

/* Copyright (c) 2008-2010 by Albert Graef <Dr.Graef@t-online.de>.
   Copyright (c) 2008-2010 by Jiri Spitz <jiri.spitz@bluetone.cz>.

   This file is part of the Pure standard library.

   The Pure standard library is free software: you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
   more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */

/* ..

   Dictionaries
   ------------

   The dict.pure module provides Pure's dictionary data types based on AVL
   trees. There are actually four different types to choose from, depending on
   whether you need ordered or hashed dictionaries and whether multiple values
   for the same key should be allowed or not.

   * ``Dict`` is an ordered dictionary (assuming an ordered key type, i.e.,
     the predicates ``==``, ``<`` and ``>`` must be defined on the keys).

   * ``HDict`` a hashed dictionary which works with any (mixture of) key types
     but stores members in an apparently random order.

   * ``MDict`` is an ordered dictionary, like ``Dict``, which allows multiple
     values to be associated with the same key.

   * ``HMDict`` is a multi-valued dictionary, like ``MDict``, but uses hashed
     keys like ``HDict``.

   ``MDict`` and ``HMDict`` are also colloquially referred to as (ordered or
   hashed) *multidicts*.

   The underlying AVL tree data structure can be found in the avltrees.pure
   module which is included in the library, but not to be invoked directly.

   The AVL tree algorithm has its origin in the SWI-Prolog implementation of
   association lists. The original implementation was created by R. A. O'Keefe
   and updated for SWI-Prolog by Jan Wielemaker. For the original source see
   http://www.swi-prolog.org.

   The port from SWI-Prolog and the deletion stuff (``rmfirst``, ``rmlast``,
   ``delete``) missing in the Prolog implementation was provided by Jiri
   Spitz. The generalization of the code to arbitrary combinations of
   ordered/hashed and single-/multi-valued keys was done by Albert Graef.

   Imports
   ~~~~~~~

   To use the operations of this module, add the following import declaration
   to your program::

     using dict;

   Data Structure
   ~~~~~~~~~~~~~~

   Dictionaries are represented as balanced tree structures of the form ``D
   T`` where ``D`` may be any of ``Dict``, ``HDict``, ``MDict`` and
   ``HMDict``. These constructors may be used as type tags to restrict
   variables in pattern matching.

   In any case, the internal data structure ``T`` is an AVL tree built with
   the following constructors (from the avltrees module):

   ``avl::nil``
     the empty tree.

   ``avl::bin (key=>value) balance left right``
     a nonempty tree with given ``key`` and ``value`` in the root node, where
     ``left`` and ``right`` are the left and right subtree, and ``balance``
     is either 1, 0 or -1, denoting ``|left|-|right|`` = 1, 0, or -1,
     respectively.

   (This is for informational purposes only. The tree constructors are
   private, and client modules must not rely on the internal representation.)

   All kinds of dictionaries can be compared for equality and inequality
   (``==`` and ``~=``), but note that there are no implicit conversions
   between the different dictionary types and thus the operand types must
   match. Ordered dictionaries compare their members using the ``==``
   predicate, while hashed dictionaries check for syntactical equality (using
   ``same``).

   Operations
   ~~~~~~~~~~

   .. _emptydict:
   .. _emptyhdict:
   .. _emptymdict:
   .. _emptyhmdict:

   ``emptydict``, ``emptyhdict``, ``emptymdict``, ``emptyhmdict``
     return an empty dictionary

   .. _dict:
   .. _hdict:
   .. _mdict:
   .. _hmdict:

   ``dict xs``, ``hdict xs``, ``mdict xs``, ``hmdict xs``
     create a dictionary from a list ``xs`` of key-value pairs in the form
     ``key=>value``

   .. _dictp:
   .. _hdictp:
   .. _mdictp:
   .. _hmdictp:

   ``dictp d``, ``hdictp d``, ``mdictp d``, ``hmdictp d``
     check whether ``x`` is a dictionary of the corresponding type

   .. _mkdict:
   .. _mkhdict:
   .. _mkmdict:
   .. _mkhmdict:

   ``mkdict y xs``, ``mkhdict y xs``, ``mkmdict y xs``, ``mkhmdict y xs``
     create a dictionary from a list of keys and a constant value

   .. _# (dictionary):

   ``#d``
     size of a dictionary (the number of members it contains)

   .. _! (dictionary):

   ``d!x``
     get the value from ``d`` by key ``x``; in the case of a multidict this
     actually returns a list of values (which may be empty if ``d`` doesn't
     contain ``x``)

   .. _null (dictionary):

   ``null d``
     test whether ``d`` is an empty dictionary

   .. _member (dictionary):

   ``member d x``
     test whether ``d`` contains a member with key ``x``

   .. _members (dictionary):
   .. _list (dictionary):

   ``members d``, ``list d``
     list the members of ``d`` (in ascending order for ordered dictionaries)

   .. _keys:

   ``keys d``
     list the keys of ``d`` (in ascending order for ordered dictionaries)

   .. _vals:

   ``vals d``
     list the values of ``d``

   .. _first (dictionary):
   .. _last (dictionary):

   ``first d``, ``last d``
     return the first and the last member of ``d``, respectively

   .. _rmfirst (dictionary):
   .. _rmlast (dictionary):

   ``rmfirst d``, ``rmlast d``
     remove the first and the last member from ``d``, respectively

   .. _insert (dictionary):
   .. _update (dictionary):

   ``insert d (x=>y)``, ``update d x y``
     insert ``x=>y`` into ``d``

     Note that in the case of a multidict this operation *always* adds a new
     member; otherwise it replaces an existing value if there is one. Also
     note that ``update`` is just a fully curried version of ``insert``, so
     ``update d x y`` behaves exactly like ``insert d (x=>y)``.

   .. _delete (dictionary):

   ``delete d x``
     remove ``x`` from ``d``

     Note that in the case of a multidict this only removes the "first" member
     for the given key ``x``, i.e., the member which corresponds to the first
     element in ``d!x``.

   Examples
   ~~~~~~~~

   A normal (ordered) dictionary::

     > using dict;
     > let d::Dict = dict ["foo"=>77,"bar"=>99.1];
     > keys d; vals d; members d;
     ["bar","foo"]
     [99.1,77]
     ["bar"=>99.1,"foo"=>77]

   Indexing a dictionary works in the usual way, using Pure's ``!`` operator.
   An ``out_of_bound`` exception is thrown if the key is not in the
   dictionary::

     > d!"foo";
     77
     > d!"baz";
     <stdin>, line 5: unhandled exception 'out_of_bounds' while evaluating 'd!"baz"'

   By virtue of the prelude, slicing a dictionary with ``!!`` also works as
   expected::

     > d!!["foo","bar","baz"];
     [77,99.1]

   A hashed dictionary can be used with any key values, which are stored in a
   seemingly random order::

     > let h::HDict = hdict [foo=>77,42=>99.1];
     > keys h; vals h; members h;
     [42,foo]
     [99.1,77]
     [42=>99.1,foo=>77]
     > h!foo;
     77
     > h!!keys h;
     [99.1,77]

   Multidicts work in pretty much the same fashion, but allow more than one
   value for a given key to be stored in the dictionary. In this case, the
   indexing operation returns a list of all values for the given key, which
   may be empty if the key is not in the dictionary (rather than throwing an
   ``out_of_bound`` exception)::

     > let d::MDict = mdict ["foo"=>77,"bar"=>99.1,"foo"=>99];
     > d!"foo"; d!"baz";
     [77,99]
     []

   Slicing thus returns a list of lists of values here::

     > d!!["foo","bar","baz"];
     [[77,99],[99.1],[]]

   To obtain a flat list you can just concatenate the results::

     > cat $ d!!["foo","bar","baz"];
     [77,99,99.1]

   Finally, hashed multidicts provide both key hashing and multiple values per
   key::

     > let h::HMDict = hmdict [foo=>77,42=>99.1,42=>77];
     > keys h; vals h; members h;
     [42,42,foo]
     [99.1,77,77]
     [42=>99.1,42=>77,foo=>77]
     > h!42;
     [99.1,77]

*/

using avltrees;

// type checks
dictp _::Dict	= 1;
dictp _		= 0;

hdictp _::HDict	= 1;
hdictp _	= 0;

mdictp _::MDict	= 1;
mdictp _	= 0;

hmdictp _::HMDict = 1;
hmdictp _	= 0;

// create an empty dict
emptydict	= Dict   avl::emptytree;
emptyhdict	= HDict  avl::emptytree;
emptymdict	= MDict  avl::emptytree;
emptyhmdict	= HMDict avl::emptytree;

// create a dict from a list
dict  xys	= foldl insert emptydict   xys if listp xys;
hdict xys	= foldl insert emptyhdict  xys if listp xys;
mdict  xys	= foldl insert emptymdict  xys if listp xys;
hmdict xys	= foldl insert emptyhmdict xys if listp xys;

// create a dict from a list of keys and a constant value
mkdict  y xs	= dict   (zipwith (=>) xs (repeatn (#xs) y)) if listp xs;
mkhdict y xs	= hdict  (zipwith (=>) xs (repeatn (#xs) y)) if listp xs;
mkmdict  y xs	= mdict  (zipwith (=>) xs (repeatn (#xs) y)) if listp xs;
mkhmdict y xs	= hmdict (zipwith (=>) xs (repeatn (#xs) y)) if listp xs;

// insert a member
insert (Dict  d)  el@(x=>y) = Dict   (avl::insertk   d el);
insert (HDict d)  el@(x=>y) = HDict  (avl::inserthk  d el);
insert (MDict  d) el@(x=>y) = MDict  (avl::insertkm  d el);
insert (HMDict d) el@(x=>y) = HMDict (avl::inserthkm d el);

// curried version of insert
update d@(Dict  _) x y | update d@(HDict  _) x y |
update d@(MDict _) x y | update d@(HMDict _) x y = insert d (x=>y);

// delete a member by key
delete (Dict   d) x = Dict   (avl::deletek  d x);
delete (HDict  d) x = HDict  (avl::deletehk d x);
delete (MDict  d) x = MDict  (avl::deletek  d x);
delete (HMDict d) x = HMDict (avl::deletehk d x);

// check for the empty dict
null (Dict  d) | null (HDict  d) |
null (MDict d) | null (HMDict d) = avl::null d;

// dict size
#(Dict  d) | #(MDict  d) = avl::size  d;
#(HDict d) | #(HMDict d) = avl::sizeh d;

// membership test
member (Dict  d) k | member (MDict  d) k = avl::memberk  d k;
member (HDict d) k | member (HMDict d) k = avl::memberhk d k;

// get the members, keys and values of a dict as a list
members (Dict  d) | members (MDict  d) = avl::members  d;
members (HDict d) | members (HMDict d) = avl::membersh d;
keys    (Dict  d) | keys    (MDict  d) = avl::keys     d;
keys    (HDict d) | keys    (HMDict d) = avl::keysh    d;
vals    (Dict  d) | vals    (MDict  d) = avl::vals     d;
vals    (HDict d) | vals    (HMDict d) = avl::valsh    d;

list d::Dict  | list d::MDict |
list d::HDict | list d::HMDict = members d;

// get the first and last member
first (Dict d)  | first (MDict d)  = avl::first  d;
last  (Dict d)  | last  (MDict d)  = avl::last   d;
first (HDict d) | first (HMDict d) = avl::firsth d;
last  (HDict d) | last  (HMDict d) = avl::lasth  d;

// remove the first and last member
rmfirst (Dict   d) = Dict   (avl::rmfirst  d);
rmlast  (Dict   d) = Dict   (avl::rmlast   d);
rmfirst (HDict  d) = HDict  (avl::rmfirsth d);
rmlast  (HDict  d) = HDict  (avl::rmlasth  d);
rmfirst (MDict  d) = MDict  (avl::rmfirst  d);
rmlast  (MDict  d) = MDict  (avl::rmlast   d);
rmfirst (HMDict d) = HMDict (avl::rmfirsth d);
rmlast  (HMDict d) = HMDict (avl::rmlasth  d);

// get a value by key
(Dict d)!k	= avl::get   d k;
(HDict d)!k	= avl::geth  d k;
(MDict d)!k	= avl::getm  d k;
(HMDict d)!k	= avl::gethm d k;

// equality checks
d1::Dict   == d2::Dict   |
d1::MDict  == d2::MDict  = (members d1) == (members d2);
d1::HDict  == d2::HDict  = all (member d1) (keys d2) &&
	     	       	   all (member d2) (keys d1) &&
	  		   (vals d1) == (map (d2!) (keys d1));
d1::HMDict == d2::HMDict = all (member d1) (keys d2) &&
	     	       	   all (member d2) (keys d1) &&
	  		   (map (d1!) ks) == (map (d2!) ks)
			   when ks = keys d1 end;

d1::Dict   ~= d2::Dict   |
d1::MDict  ~= d2::MDict  = (members d1) ~= (members d2);
d1::HDict  ~= d2::HDict  |
d1::HMDict ~= d2::HMDict = ~(d1 == d2);
