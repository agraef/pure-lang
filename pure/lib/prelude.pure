
/* Pure's standard prelude. */

/* Copyright (c) 2008-2010 by Albert Graef <Dr.Graef@t-online.de>.

   This file is part of the Pure standard library.

   The Pure standard library is free software: you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
   more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */

/* .. We use docutils to produce the documentation. Docstrings are extracted
   .. with pure-doc. Please see the pure-doc documentation for details.

   .. This module is always the first in the library docs, so produce the
   .. title here.

   ===================
   Pure Library Manual
   ===================

   .. Add all global docutils declarations here.

   .. role:: dfn(strong)
   .. default-role:: dfn

   .. |date| date::

   .. |GPL| replace:: GNU General Public License
   .. |FDL| replace:: GNU Free Documentation License
   .. _FDL: http://www.gnu.org/copyleft/fdl.html
   .. _GPL: http://www.gnu.org/copyleft/gpl.html

   .. _Pure Manual: pure.html

   .. Add all pertaining author and copyright information here.

   Version @version@, |today|

   Albert Gräf <Dr.Graef@t-online.de>

   Copyright (c) 2009-2010 by Albert Gräf. This document is available under
   the |FDL|_.

   This manual describes the operations in the standard Pure library,
   including the prelude and the other library modules which come bundled with
   the interpreter.

   There is a companion to this manual, the `Pure Manual`_ which describes the
   Pure language and the operation of the Pure interpreter.

   .. Table of contents, switch on section numbering.

   .. contents::
   .. sectnum::

   Prelude
   =======

   The prelude defines the basic operations of the Pure language. This
   includes the basic arithmetic and logical operations, string, list and
   matrix functions, as well as the support operations required to implement
   list and matrix comprehensions. The string, matrix and record operations
   are in separate modules strings.pure, matrices.pure and records.pure, the
   primitive arithmetic and logical operations can be found in
   primitives.pure. Note that since the prelude module gets imported
   automatically (unless the interpreter is invoked with the ``--no-prelude``
   option), all operations discussed in this section are normally available in
   Pure programs without requiring any explicit import declarations.

   .. _true:
   .. _false:

   The prelude also declares a signature of commonly used constant and
   operator symbols. This includes the truth values ``true`` and ``false``.
   These are actually just integers in Pure, but sometimes it's convenient to
   refer to them using these symbolic constants. Note that if you also want to
   use these on the left-hand side of equations, you still have to declare
   them as ``nonfix`` symbols yourself, using a declaration like::

     nonfix false true;

   In addition, the following special exception symbols are provided:

   .. _failed_cond:
   .. _failed_match:
   .. _stack_fault:
   .. _malloc_error:

   * Built-in exception values: ``failed_cond`` (failed conditional in guard
     or if-then-else), ``failed_match`` (failed pattern match in lambda,
     ``case`` expression, etc.), ``stack_fault`` (not enough stack space,
     ``PURE_STACK`` limit exceeded) and ``malloc_error`` (memory allocation
     error).

   .. _bad_list_value:
   .. _bad_tuple_value:
   .. _bad_string_value:
   .. _bad_matrix_value:

   * Value mismatches a.k.a. dynamic typing errors: ``bad_string_value x``,
     ``bad_matrix_value x``, ``bad_list_value x``, ``bad_tuple_value x``.
     These are thrown by some operations when they fail to find an expected
     value of the corresponding type.

   .. _out_of_bounds:

   * Index range exceptions: ``out_of_bounds`` is thrown by the index operator
     ``!`` if a list, tuple or matrix index is out of bounds.

*/

nonfix failed_cond failed_match stack_fault out_of_bounds malloc_error;
public bad_matrix_value bad_list_value bad_tuple_value bad_string_value;

/* .. _operators:

   Here's the list of predefined operator symbols. Note that the parser will
   automagically give unary minus the same precedence level as the
   corresponding binary operator. */

// >>>

infixl  1000   $$ ;                // sequence operator
infixr  1100   $ ;                 // right-associative application
infixr  1200   , ;                 // pair (tuple)
infix   1300   => ;                // key=>value pairs ("hash rocket")
infix   1400   .. ;                // arithmetic sequences
infixr  1500   || ;                // logical or (short-circuit)
infixr  1600   && ;                // logical and (short-circuit)
prefix  1700   ~ ;                 // logical negation
infix   1800   < > <= >= == ~= ;   // relations
infix   1800   === ~== ;           // syntactic equality
infixr  1900   : ;                 // list cons
infix   2000   +: <: ;             // complex numbers (cf. math.pure)
infixl  2100   << >> ;             // bit shifts
infixl  2200   + - or ;            // addition, bitwise or
infixl  2300   * / div mod and ;   // multiplication, bitwise and
infixl  2300   % ;                 // exact division (cf. math.pure)
prefix  2400   not ;               // bitwise not
infixr  2500   ^ ;                 // exponentiation
prefix  2600   # ;                 // size operator
infixl  2700   ! !! ;              // indexing, slicing
infixr  2800   . ;                 // function composition
prefix  2900   ' ;                 // quote
postfix 3000   & ;                 // thunk

// <<<

const false, true = 0, 1;

/* Pull in the primitives (arithmetic etc.) and the standard string functions.
   Note that the math and system modules are *not* included here, so you have
   to do that yourself if your program requires any of those operations. */

using primitives, matrices, records, strings;

/* ..

   Basic Combinators
   -----------------

   .. _combinators:
   .. _$:
   .. _.:

   The most important function combinators are ``$`` (right-associative
   application) and ``.`` (function composition), which are also defined as
   macros so that saturated calls of these are eliminated automatically.
   Examples::

     > foo $ bar 99;
     foo (bar 99)
     > (foo.bar) 99;
     foo (bar 99)

   .. _id:
   .. _cst:

   The customary identity and constant combinators from the combinatorial
   calculus are also available, in Pure these are named ``id`` and ``cst``,
   respectively::

     > map id (1..5);
     [1,2,3,4,5]
     > map (cst 0) (1..5);
     [0,0,0,0,0]

   .. _void:

   There's also a combinator ``void`` which is basically equivalent to ``cst
   ()``, but with the special twist that it is also defined as a macro
   optimizing the case of "throwaway" list and matrix comprehensions. This is
   useful if a comprehension is evaluated solely for its side effects. E.g.::

     > using system;
     > extern int rand();
     > foo = void [printf "%d\n" rand | _ = 1..3];
     > show foo
     foo = do (\_ -> printf "%d\n" rand) (1..3);
     > foo;
     1714636915
     1957747793
     424238335
     ()

   Note that the above list comprehension is actually implemented using |do|_
   (instead of |map|_, which would normally be the case), so that the
   intermediate list value of the comprehension is never constructed. This is
   described in more detail in section `Optimization Rules`_ of the Pure
   Manual.

   .. |do| replace:: ``do``
   .. |map| replace:: ``map``
   .. _Optimization Rules: pure.html#optimization-rules

*/

f $ x		= f x;
(f . g) x	= f (g x);

void _		= ();
id x		= x;
cst x y		= x;

/* ..

   In addition, Pure also provides the following combinators adopted from
   Haskell:

   .. _flip:

   * ``flip f`` swaps arguments of a binary function ``f``, e.g.::

       > map (flip (/) 2) (1..3);
       [0.5,1.0,1.5]

     This combinator is also used by the compiler to implement right operator
     sections, which allows you to write the above simply as::

       > map (/2) (1..3);
       [0.5,1.0,1.5]

   .. _curry:

   * ``curry f`` turns a function ``f`` expecting a pair of values into a
     curried function of two arguments::

       > using system;
       > dowith (curry (printf "%d: %g\n")) (0..2) [0.0,2.718,3.14];
       0: 0
       1: 2.718
       2: 3.14
       ()

   .. _uncurry:

   * Conversely, ``uncurry f`` turns a curried function ``f`` expecting two
     arguments into a function processing a single pair argument::

       > map (uncurry (*)) [(2,3),(4,5),(6,7)];
       [6,20,42]

   .. _curry3:
   .. _uncurry3:

   * ``curry3`` and ``uncurry3`` are defined analogously, but are used to work
     with ternary functions.

*/

flip f x y	= f y x;
curry f x y	= f (x,y);
curry3 f x y z	= f (x,y,z);
uncurry f (x,y)	= f x y;
uncurry3 f (x,y,z)
		= f x y z;

/* .. _fix:

   * The (normal order) fixed point combinator ``fix`` allows you to create
     recursive anonymous functions. It takes another function ``f`` as its
     argument and applies ``f`` to ``fix f`` itself::

       > let fact = fix (\f n -> if n<=0 then 1 else n*f (n-1));
       > map fact (1..5);
       [1,2,6,24,120]

     See |fixpoint|_ at Wikipedia for an explanation of how this magic works.
     Just like in Haskell, ``fix`` can be used to produce least fixed points
     of arbitrary functions. For instance::

       > fix (cst bar);
       bar
       > let xs = fix (1:);
       > xs;
       1:#<thunk 0x7fe537fe2f90>
       > xs!!(0..10);
       [1,1,1,1,1,1,1,1,1,1,1]

   .. |fixpoint| replace:: Fixed point combinator
   .. _fixpoint: http://en.wikipedia.org/wiki/Fixed_point_combinator

*/

fix f = f (fix f&);

/* Some convenient optimization rules which eliminate saturated calls of the
   function composition combinators. */

def f $ x	= f x;
def (f . g) x	= f (g x);

/* The following rules are always valid and optimize the case of "throwaway"
   list comprehensions (useful if a list comprehension is evaluated solely for
   its side effects). */

def void (catmap f x) = do f x;
def void (listmap f x) = do f x;

/* ..

   Lists and Tuples
   ----------------

   .. _lists:
   .. _tuples:
   .. _list size:
   .. _tuple size:
   .. _null:
   .. _reverse:
   .. _#:
   .. _\::
   .. _,:
   .. _!:
   .. _!!:

   The prelude defines the list and tuple constructors (``x:y``, ``x,y``), as
   well as equality (``==``) and inequality (``~=``) on these structures. (The
   latter compare two lists or tuples by recursively comparing their members,
   so ``==`` must be defined on the list or tuple members if you want to use
   these operations.) It also provides the predicate ``null x`` which tests
   whether ``x`` is the empty list or tuple, the function ``reverse x`` which
   reverses a list or tuple, and the operators ``#x`` (size of a list or
   tuple), ``x!i`` (indexing), ``x!!is`` (slicing) and ``x+y`` (list
   concatenation). Note that there isn't a separate operation for
   concatenating tuples, since the pairing operator already does this::

     > (1,2,3),(10,9,8);
     1,2,3,10,9,8

   This works because the ``(,)`` constructor is associative in Pure and will
   always produce right-recursive pairs. This also implies that tuples are
   always flat in Pure and can't be nested; if you need this, you should use
   lists instead. Also note that the empty tuple ``()`` acts as a neutral
   element with respect to ``(,)``::

     > (),(a,b,c);
     a,b,c
     > (a,b,c),();
     a,b,c

   .. _key:
   .. _val:

   The prelude also provides another special kind of pairs called "hash
   pairs", which take the form ``key=>value``. These are used in various
   contexts to denote key-value associations. The only operations on hash
   pairs provided by the prelude are equality testing (which recursively
   compares the components) and the functions ``key`` and ``val`` which
   extract the components of a hash pair::

     > ("foo"=>99) == ("bar"=>99);
     0
     > key ("foo"=>99), val ("foo"=>99);
     "foo",99

   Note that in difference to the tuple operator ``(,)``, the "hash rocket"
   ``(=>)`` is non-associative, so nested applications *must* be
   parenthesized, and ``(x=>y)=>z`` is generally *not* the same as
   ``x=>(y=>z)``. Also note that ``(,)`` has lower precedence than ``(=>)``,
   so to include a tuple as key or value in a hash pair, the tuple must be
   parenthesized, as in ``"foo"=>(1,2)`` (whereas ``"foo"=>1,2`` denotes a
   tuple whose first element happens to be a hash pair).

   .. _list concatenation:
   .. _+ (list):

   Lists are the usual right-recursive aggregates, pretty much the same as in
   Lisp or Prolog except that they use a Haskell-like syntax. In difference to
   Haskell, list concatenation is denoted ``+``, and lists may contain an
   arbitrary mixture of arguments, i.e., they are fully polymorphic::

     > 1:2:3:[];
     [1,2,3]
     > [1,2,3]+[u,v,w]+[3.14];
     [1,2,3,u,v,w,3.14]

   Lists are `eager` in Pure by default, but they can also be made `lazy`, see
   section `Lazy Evaluation and Streams`_ in the Pure Manual.

   .. _Lazy Evaluation and Streams: pure.html#lazy-evaluation-and-streams

   .. _arithmetic sequences:
   .. _..:

   Arithmetic sequences can be constructed with the infix ``..`` operator::

     > 1..5;
     [1,2,3,4,5]
     > 1:3..11;
     [1,3,5,7,9,11]

   Note that the Pure syntax differs from Haskell in that there are no
   brackets around the construct and a step width is indicated by specifying
   the first two elements as ``x:y`` instead of ``x,y``. Also, to specify
   infinite sequences you have to use an infinite upper bound (``inf`` or
   ``-inf``)::

     > 1:3..inf;
     1:#<thunk 0x7f696cd2dbd8>
     > -1:-3..-inf;
     -1:#<thunk 0x7f696cd2fde8>

   The lower bounds of an arithmetic sequence must always be finite.

   .. _sort:

   Non-lazy lists can be sorted using the ``sort`` function, which provides an
   interface to the C ``qsort()`` routine, please see your local qsort(3)
   documentation for details. An order predicate ``p`` is specified as the
   first argument, which must return a nonzero integer to indicate that its
   first argument is "less than" its second argument. Example::

     > sort (>) (1..10);
     [10,9,8,7,6,5,4,3,2,1]
     > sort (<) ans;
     [1,2,3,4,5,6,7,8,9,10]

   .. _list:
   .. _tuple:

   You can convert between (finite) lists and tuples using the ``list`` and
   ``tuple`` operations::

     > tuple (1..5);
     1,2,3,4,5
     > list (a,b,c);
     [a,b,c]

   The ``list`` function can also be used to turn a finite lazy list into an
   eager one::

     > list $ take 10 (-1:-3..-inf);
     [-1,-3,-5,-7,-9,-11,-13,-15,-17,-19]

   You can also achieve the same effect somewhat more conveniently by slicing
   a finite part from a stream (see below)::

     > (-1:-3..-inf)!!(0..9);
     [-1,-3,-5,-7,-9,-11,-13,-15,-17,-19]

   .. _stream:

   Conversely, it is also possible to convert a list to a stream::

     > stream (1..10);
     1:#<thunk 0x7fe537fe2b58>

   This might appear a bit useless at first sight, since all elements of the
   stream are in fact already known. However, this operation then allows you
   to apply other functions to the list and have them evaluated in a lazy
   fashion.

   .. _list indexing:
   .. _tuple indexing:
   .. _! (indexing):

   Indexing of lists and tuples is always zero-based (i.e., indices run from
   ``0`` to ``#x-1``), and an exception will be raised if the index is out of
   bounds::

     > [1,2,3]!2;
     3
     > [1,2,3]!4;
     <stdin>, line 34: unhandled exception 'out_of_bounds' while evaluating
     '[1,2,3]!4'

   .. _list slicing:
   .. _tuple slicing:
   .. _!! (slicing):

   The slicing operator ``!!`` takes a list or tuple and a list of indices and
   returns the list or tuple of the corresponding elements, respectively.
   Indices which are out of the valid range are silently ignored::

     > (1..5)!!(3..10);
     [4,5]
     > (1,2,3,4,5)!!(3..10);
     4,5

   Indices can actually be specified in any order, so that you can retrieve
   any permutation of the members, also with duplicates. E.g.::

     > (1..5)!![2,4,4,1];
     [3,5,5,2]

   This is less efficient than the case of contiguous index ranges (which is
   optimized so that it always works in linear time), because it requires
   repeated traversals of the list for each index. For larger lists you should
   hence use vectors or matrices instead, to avoid the quadratic complexity.

   .. |catmap| replace:: ``catmap``

   (The prelude actually implements the slicing operation in a fairly generic
   way, so that it works with any kind of container data structure which
   defines ``!`` in such a manner that it throws an exception when the index
   is out of bounds. It also works with any kind of index container that
   implements the |catmap|_ operation.) */

/* The hash rocket. This constructor is declared here so that it can be used
   in other standard library modules to denote special kinds of pairs which
   map keys to values. Here we only define equality of such pairs, as well as
   the key and val operations for extracting the components of a hash pair. */

(x=>v)==(y=>w)	= x==y && v==w;
(x=>v)~=(y=>w)	= x~=y || v~=w;

key (x=>v)	= x;
val (x=>v)	= v;

/* Poor man's tuples(TM). These are constructed with the pairing operator ',',
   are always flat and associate to the right. The empty tuple, denoted (), is
   neutral with respect to ','. Operations are provided to test for equality/
   inequality and emptiness, to determine the size of a tuple, for zero-based
   indexing and slicing, and to reverse a tuple. */

x,()		= x;
(),y		= y;
(x,y),z		= x,(y,z);

()==()		= 1;
(x,xs)==(y,ys)	= x==y && xs==ys;
(x,xs)==_	|
()==_		|
_==(x,xs)	|
_==()		= 0;

()~=()		= 0;
(x,xs)~=(y,ys)	= x~=y || xs~=ys;
(x,xs)~=_	|
()~=_		|
_~=(x,xs)	|
_~=()		= 1;

null ()		= 1;
null (x,xs)	= 0;

#()		= 0;
#(x,xs)		= accum 1 xs with
  accum n::int (x,xs)	= accum (n+1) xs;
  accum n::int x	= n+1;
end;

(x,xs)!n::int	= throw out_of_bounds if n<0;
(x,xs)!0	= x;
(x,y,xs)!n::int	= (y,xs)!(n-1);
(x,y)!1		= y;
(x,y)!n::int	|
()!n::int	= throw out_of_bounds;

xs@()!!ns	|
xs@(_,_)!!ns	= tuple (list xs!!ns);

reverse ()	= ();
reverse (x,xs)	= accum x xs with
  accum ys (x,xs)	= accum (x,ys) xs;
  accum ys x		= x,ys;
end;

/* Lists are the usual "conses" written using the infix ':' operator. '[]'
   denotes the empty list. Moreover, the parser provides the customary sugar
   for proper list values [x] where x is any singleton or tuple (in the latter
   case you'll get a list made from all the elements of x). The usual basic
   operations are provided to test for equality/inequality and emptiness, to
   compute the size of a list, for indexing, slicing and concatenation, and
   for reversing a list. */

[]==[]		= 1;
(x:xs)==[]	= 0;
[]==(x:xs)	= 0;
(x:xs)==(y:ys)	= x==y && xs==ys;

[]~=[]		= 0;
(x:xs)~=[]	= 1;
[]~=(x:xs)	= 1;
(x:xs)~=(y:ys)	= x~=y || xs~=ys;

null []		= 1;
null (x:xs)	= 0;

#[]		= 0;
#(x:xs)		= accum 1 xs with
  accum n::int (x:xs)	= accum (n+1) xs;
  accum n::int []	= n;
  accum	n::int xs	= n+#xs;
end;

[]!n::int	= throw out_of_bounds;
(x:xs)!0	= x;
(x:xs)!n::int	= xs!(n-1) if n>0;
		= throw out_of_bounds otherwise;

/* Slicing. xs!!ns returns the list of xs!n for all members n of the index
   list ns which are in the valid index range. This is a generic fallback
   definition which works with any kind of container data structure which
   defines (!) in such a manner that it throws an exception when the index is
   out of bounds. It also works with any kind of index container that
   implements the catmap operation. Moreover, the special case of finite
   contiguous list slices is optimized using 'take' and 'drop' so that it
   works in linear time. */

xs!!ns		= ys if ok ys when
		    ys = case ns of
		           ns@(n::int:_) = list $ take (count ns) (drop n xs)
		                             if listnp xs && cont ns;
		           _ = catmap (nth xs) ns;
		         end;
		  end with
		    ok (catmap (nth _) _) = 0;
		    ok _ = 1;
		    nth xs n = catch (cst []) [xs!n];
		    count ns = #dropwhile (\n::int->n<0) ns;
		    cont (n::int:ns) = ~thunkp ns &&
		    (case ns of
		       [] = 1;
		       m::int:_ = cont ns if m==n+1;
		       _ = 0 otherwise;
		     end);
		  end;

/* List concatenation. For a robust implementation which works with both
   ordinary lists and streams, we want this to be tail-recursive *and*
   non-strict. So we first walk down the list, popping elements from the first
   operand until we find an empty or thunked tail ('tick'), then walk back up
   again, pushing elements in front of the result list ('tack'). */

[]+ys		= ys;
xs@(_:_)+ys	= tick [] xs ys
with
  tick zs (x:xs) ys	= tack (x:zs) ((xs+ys)&) if thunkp xs;
			= tick (x:zs) xs ys;
  tick zs [] ys		= tack zs ys;
  /* Handle an improper list tail (xs+ys is in normal form here). */
  tick zs xs ys		= tack zs (xs+ys);
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

/* List reversal. This is a strict operation, of course, so it will loop on
   infinite lists. Also, this is one of the few list operations which throws
   an exception for improper lists, since in that case there really isn't any
   meaningful value to return. */

reverse []	= [];
reverse (x:xs)	= accum [x] xs with
  accum ys (x:xs)	= accum (x:ys) xs;
  accum ys []		= ys;
  accum	ys xs		= throw (bad_list_value xs);
end;

/* Conversions between lists, tuples and streams. */

list ()		= [];
list (x,xs)	= accum [x] xs with
  accum ys (x,xs)	= accum (x:ys) xs;
  accum ys x		= reverse (x:ys);
end;

tuple []	= ();
tuple (x:xs)	= accum (t x) xs with
  accum ys (x:xs)	= accum (t x,ys) xs;
  accum ys []		= t ys;
  accum	ys xs		= throw (bad_list_value xs);
  t x@(_,_)		= reverse x;
  t x			= x;
end;

tuple x@() | tuple x@(_,_) = x;

list []		= [];
list (x:xs)	= accum [x] xs with
  accum ys (x:xs)	= accum (x:ys) xs;
  accum ys []		= reverse ys;
  accum	ys xs		= throw (bad_list_value xs);
end;

stream []	= [];
stream (x:xs)	= x:xs if thunkp xs;
		= x:stream xs& otherwise;

stream ()	= [];
stream xs@(_,_)	= stream (list xs);

/* Arithmetic sequences. */

public iterate iterwhile; // see below for these

n1:n2..m	= if m===s then iterate (+k) n1
		  else if m===-s then []
		  else iterwhile (p m) (+k) n1
		  when s,p = if k>0 then inf,(>=) else -inf,(<=) end
		  if realp k && k~=0 && ~infp n1 && ~infp n2
		  when k = n2-n1 end;
n..m		= if m===inf then iterate (+1) n
		  else if m===-inf then []
		  else iterwhile ((>=) m) (+1) n
		  if ~listnp n && ~infp n;

/* ..

   List Functions
   --------------

   This mostly comes straight from the Q prelude which in turn was based on
   the first edition of the Bird/Wadler book, and is very similar to what you
   can find in the Haskell prelude. Some functions have slightly different
   names, though, and of course everything is typed dynamically.

   Common List Functions
   ~~~~~~~~~~~~~~~~~~~~~

   .. _any:

   ``any p xs``
     tests whether the predicate ``p`` holds for any of the members of ``xs``

   .. _all:

   ``all p xs``
     tests whether the predicate ``p`` holds for all of the members of ``xs``

   .. _cat:
   .. |cat| replace:: ``cat``

   ``cat xs``
     concatenate a list of lists

   .. _catmap:

   ``catmap f xs``
     convenience function which combines |cat|_ and |map|_; this is also used
     to implement list comprehensions

   .. _do:

   ``do f xs``
     apply ``f`` to all members of ``xs``, like |map|_, but throw away all
     intermediate results and return ``()``

   .. _drop:

   ``drop n xs``
     remove ``n`` elements from the front of ``xs``

   .. _dropwhile:

   ``dropwhile p xs``
     remove elements from the front of ``xs`` while the predicate ``p`` is
     satisfied

   .. _filter:

   ``filter p xs``
     return the list of all members of ``xs`` satisfying the predicate ``p``

   .. _foldl:

   ``foldl f a xs``
     accumulate the binary function ``f`` over all members of ``xs``,
     starting from the initial value ``a`` and working from the front of the
     list towards its end

   .. _foldl1:

   ``foldl1 f xs``
     accumulate the binary function ``f`` over all members of ``xs``,
     starting from the value ``head xs`` and working from the front of the
     list towards its end; ``xs`` must be nonempty

   .. _foldr:

   ``foldr f a xs``
     accumulate the binary function ``f`` over all members of ``xs``,
     starting from the initial value ``a`` and working from the end of the
     list towards its front

   .. _foldr1:

   ``foldr1 f xs``
     accumulate the binary function ``f`` over all members of ``xs``,
     starting from the value ``last xs`` and working from the end of the
     list towards its front; ``xs`` must be nonempty

   .. _head:

   ``head xs``
     return the first element of ``xs``; ``xs`` must be nonempty

   .. _index:

   ``index xs x``
     search for an occurrence of ``x`` in ``xs`` and return the index of the
     first occurrence, if any, ``-1`` otherwise

     Note: This uses equality (``==``) to decide whether a member of ``xs`` is
     an occurrence of ``x``, so ``==`` must have an appropriate definition on
     the list members.

   .. _init:

   ``init xs``
     return all but the last element of ``xs``; ``xs`` must be nonempty

   .. _last:

   ``last xs``
     return the last element of ``xs``; ``xs`` must be nonempty

   .. _listmap:

   ``listmap f xs``
     convenience function which works like |map|_, but also deals with matrix
     and string arguments while ensuring that the result is always a list;
     this is primarily used to implement list comprehensions

   .. _map:

   ``map f xs``
     apply ``f`` to each member of ``xs``

   .. _scanl:

   ``scanl f a xs``
     accumulate the binary function ``f`` over all members of ``xs``,
     as with ``foldl``, but return all intermediate results as a list

   .. _scanl1:

   ``scanl1 f xs``
     accumulate the binary function ``f`` over all members of ``xs``,
     as with ``foldl1``, but return all intermediate results as a list

   .. _scanr:

   ``scanr f a xs``
     accumulate the binary function ``f`` over all members of ``xs``,
     as with ``foldr``, but return all intermediate results as a list

   .. _scanr1:

   ``scanr1 f xs``
     accumulate the binary function ``f`` over all members of ``xs``,
     as with ``foldr1``, but return all intermediate results as a list

   .. _sort (list):

   ``sort p xs``
     Sorts the elements of the list ``xs`` in ascending order according to the
     given predicate ``p``, using the C ``qsort`` function. The predicate
     ``p`` is invoked with two arguments and should return a truth value
     indicating whether the first argument is "less than" the second. (An
     exception is raised if the result of a comparison is not a machine
     integer.)

   .. _tail:

   ``tail xs``
     return all but the first element of ``xs``; ``xs`` must be nonempty

   .. _take:

   ``take n xs``
     take ``n`` elements from the front of ``xs``

   .. _takewhile:

   ``takewhile p xs``
     take elements from the front of ``xs`` while the predicate ``p`` is
     satisfied

*/

/* Some of the definitions aren't exactly pretty, but they are like that
   because we want them to be both efficient and robust. In particular, we
   require that they do all the necessary argument checking, are
   tail-recursive and handle lazy lists as gracefully as possible. */

all p []		= 1;
all p (x:xs)		= p x && all p xs;

any p []		= 0;
any p (x:xs)		= p x || any p xs;

do f []			= ();
do f (x:xs)		= f x $$ do f xs;

drop n::int []		= [];
drop n::int ys@(x:xs)	= drop (n-1) xs if n>1;
			= xs if n==1;
			= ys otherwise;

dropwhile p []		= [];
dropwhile p ys@(x:xs)	= dropwhile p xs if p x;
			= ys otherwise;

filter p []		= [];
filter p xs@(_:_)	= tick [] xs
with
  add p x xs		= if p x then x:xs else xs;
  tick zs (x:xs)	= tack (add p x zs) (filter p xs&) if thunkp xs;
			= tick (add p x zs) xs;
  tick zs []		= tack zs [];
  tick _ xs		= throw (bad_list_value xs);
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

foldl f a []		= a;
foldl f a (x:xs)	= foldl f (f a x) xs;

foldl1 f (x:xs)		= foldl f x xs;

foldr f a []		= a;
foldr f a xs@(_:_)	= tick [] xs
with
  tick zs (x:xs)	= tack (x:zs) (foldr f a xs&) if thunkp xs;
			= tick (x:zs) xs;
  tick zs []		= tack zs a;
  tick zs xs		= tack zs (foldr f a xs);
  tack (x:xs) y		= tack xs (f x y);
  tack [] y		= y;
end;

foldr1 f [x]		= x;
foldr1 f xs@(_:_)	= tick [] xs
with
  /* Do the thunkp check first, before probing the tail. Note that the first
     foldr1 rule above ensures that the topmost tail is already evaluated, so
     that we always make some progress here. */
  tick zs ys@(_:xs)	= tack zs (foldr1 f ys&) if thunkp xs;
  tick zs xs		= case xs of
			    [x]  = tack zs x;
			    x:xs = tick (x:zs) xs;
			    _    = tack zs (foldr1 f xs);
			  end;
  tack (x:xs) y		= tack xs (f x y);
  tack [] y		= y;
end;

head (x:xs)		= x;

init [x]		= [];
init xs@(_:_)		= tick [] xs
with
  tick zs ys@(_:xs)	= tack zs (init ys&) if thunkp xs;
  tick zs xs		= case xs of
			    [x]  = tack zs [];
			    x:xs = tick (x:zs) xs;
			    _    = tack zs (init xs);
			  end;
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

last [x]		= x;
last (x:xs)		= last xs;

map f []		= [];
map f xs@(_:_)		= tick [] xs
with
  tick zs (x:xs)	= tack (f x:zs) (map f xs&) if thunkp xs;
			= tick (f x:zs) xs;
  tick zs []		= tack zs [];
  tick zs xs		= tack zs (map f xs);
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

scanl f a []		= [a];
scanl f a xs@(_:_)	= tick a [] xs
with
  tick a zs (x:xs)	= tack (a:zs) (scanl f (f a x) xs&) if thunkp xs;
			= tick (f a x) (a:zs) xs;
  tick a zs []		= tack zs [a];
  tick a zs xs		= tack zs (scanl f a xs);
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

scanl1 f []		= [];
scanl1 f (x:xs)		= scanl f x xs;

scanr f a []		= [a];
scanr f a xs@(_:_)	= tick [] xs
with
  /* Hack around with thunks to make these matches irrefutable. */
  tick zs (x:xs)	= tack zs us when
			    ys = scanr f a xs&;
			    y  = (case ys of
				    y:_ = y;
				    scanr _ _ ys = throw (bad_list_value ys);
				    _ = throw (bad_list_value ys);
				  end)&;
			    us = f x y : ys;
			  end if thunkp xs;
  tick zs (x:xs)	= tack zs (f x (y when y:_ = ys end)&:ys
				   when ys = scanr f a xs& end) if thunkp xs;
			= tick (x:zs) xs;
  tick zs []		= tack zs [a];
  tick zs xs		= throw (bad_list_value xs);
  tack (x:xs) ys	= tack xs (f x y:ys) when y:_ = ys end;
  tack [] ys		= ys;
end;

scanr1 f []		= [];
scanr1 f [x]		= [x];
scanr1 f xs@(_:_)	= tick [] xs
with
  tick zs (x:xs)	= tack zs us when
			    ys = scanr1 f xs&;
			    y  = (case ys of
				    y:_ = y;
				    scanr1 _ ys = throw (bad_list_value ys);
				    _ = throw (bad_list_value ys);
				  end)&;
			    us = f x y : ys;
			  end if thunkp xs;
  tick zs xs		= case xs of
			    [x]  = tack zs [x];
			    x:xs = tick (x:zs) xs;
			    _    = throw (bad_list_value xs);
			  end;
  tack (x:xs) ys	= tack xs (f x y:ys) when y:_ = ys end;
  tack [] ys		= ys;
end;

tail (x:xs)		= xs;

take n::int []		= [];
take n::int xs@(_:_)	= tick n [] xs
with
  tick n::int zs xs	= tack zs [] if n<=0;
			= tack zs (take n xs&) if thunkp xs;
			= case xs of
			    []   = tack zs [];
			    x:xs = tick (n-1) (x:zs) xs;
			    _    = tack zs (take n xs);
			  end;
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

takewhile p []	= [];
takewhile p xs@(_:_)	= tick [] xs
with
  tick zs xs		= tack zs (takewhile p xs&) if thunkp xs;
			= case xs of
			    []   = tack zs [];
			    x:xs = tick (x:zs) xs if p x;
			         = tack zs [];
			    _    = tack zs (takewhile p xs);
			  end;
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
end;

/* Concatenate a list of lists. */

cat []			= [];
cat xs@(_:_)		= foldr (tick []) [] xs
with
  /* Unfortunately, the global list concatenation operator (+) isn't fully
     lazy in Pure, because it's also used for arithmetic operations. Using it
     here would make foldr (and hence cat) eager. Therefore we use our own
     concatenation operation here, which properly deals with the case that ys
     is an infinite stream when applied recursively. */
  tick zs (x:xs) ys	= tack (x:zs) (tick [] xs ys&) if thunkp xs;
			= tick (x:zs) xs ys;
  tick zs [] ys		= tack zs ys;
  tick zs xs ys		= tack zs (xs+ys);
  tack (x:xs) ys	= tack xs (x:ys);
  tack [] ys		= ys;
  /* We also use a slightly modified foldr function here, so that we can
     handle the case that xs is an improper list more gracefully. */
  foldr f a []		= a;
  foldr f a xs@(_:_)	= tick [] xs
  with
    tick zs (x:xs)	= tack (x:zs) (foldr f a xs&) if thunkp xs;
			= tick (x:zs) xs;
    tick zs []		= tack zs a;
    tick zs xs		= tack zs (foldr f a xs);
    tack (x:xs) y	= tack xs (f x y);
    tack [] y		= y;
  end;
  foldr (tick _) [] x	= cat x;
end;

/* Map a function to a list and concatenate the results. This is used by list
   comprehensions. */

catmap f []		= [];
catmap f xs@(_:_)	= cat (map f xs);

/* NOTE: This definition (from the Haskell prelude) is better, but doesn't
   preserve left-to-right execution order. */
//catmap f xs@(_:_)	= foldr ((+).f) [] xs;

/* Map a function to a list, like map, but first promote the argument to a
   list if possible. This is used by list comprehensions. */

listmap f []		= [];
listmap f xs@(_:_)	= map f xs;

/* Search an element in a list. Returns -1 if not found, index of first
   occurrence otherwise. */

index [] _		= -1;
index (x:xs) y		= search 0 (x:xs) with
  search _ []		= -1;
  search n::int (x:xs)	= n if x==y;
			= search (n+1) xs;
  search _ xs		= index xs y;
end;

/* ..

   List Generators
   ~~~~~~~~~~~~~~~

   Some useful (infinite) list generators, as well as some finite (and eager)
   variations of these. The latter work like a combination of ``take`` or
   ``takewhile`` and the former, but are implemented directly for better
   efficiency.

   .. _cycle:

   ``cycle xs``
     cycles through the elements of the nonempty list ``xs``, ad infinitum

   .. _cyclen:

   ``cyclen n xs``
     eager version of ``cycle``, returns the first ``n`` elements of
     ``cycle xs``

   .. _iterate:

   ``iterate f x``
     returns the stream containing ``x``, ``f x``, ``f (f x)``, etc.,
     ad infinitum

   .. _iteraten:

   ``iteraten n f x``
     eager version of ``iterate``, returns the first ``n`` elements of
     ``iterate f x``

   .. _iterwhile:

   ``iterwhile p f x``
     another eager version of ``iterate``, returns the list of all elements
     from the front of ``iterate f x`` for which the predicate ``p`` holds

   .. _repeat:

   ``repeat x``
     returns an infinite stream of ``x``\ s

   .. _repeatn:

   ``repeatn n x``
     eager version of ``repeat``, returns a list with ``n`` ``x``\ s

*/

/* Some useful (infinite) list generators. */

iterate f x		= x : iterate f (f x)&;
repeat x		= x : repeat x&;
cycle ys@(x:xs)		= x : (xs+cycle ys)&;

/* Some finite (and strict) generators. These work like the a combination of
   takewhile/take and the above, but are implemented directly for maximum
   efficiency. */

iterwhile p f x		= accum [] p f x with
			    accum xs p f x = accum (x:xs) p f (f x) if p x;
				           = reverse xs otherwise;
			  end;

iteraten n::int f x	= [] if n<=0;
			= accum [] n f x
with
  accum xs n::int f x	= reverse (x:xs) if n==1;
			= accum (x:xs) (n-1) f (f x);
end;

repeatn n::int x	= accum [] n x with
  accum xs n::int x	= xs if n<=0;
			= accum (x:xs) (n-1) x;
end;

cyclen n::int (x:xs)	= [] if n<=0;
			= accum [] n with
			    accum ys n::int = cat ys+take n xs if n<=m;
			                    = accum (xs:ys) (n-m) otherwise;
			  end when xs = x:xs; m::int = #xs end if listp xs;

/* ..

   Zip and Friends
   ~~~~~~~~~~~~~~~

   .. _unzip:

   ``unzip xys``
     takes a list of pairs to a pair of lists of corresponding elements

   .. _unzip3:

   ``unzip3 xyzs``
     ``unzip`` with triples

   .. _zip:

   ``zip xs ys``
     return the list of corresponding pairs ``(x,y)`` where ``x`` runs
     through the elements of ``xs`` and ``y`` runs through the elements
     of ``y``

   .. _zip3:

   ``zip3 xs ys zs``
     ``zip`` with three lists, returns a list of triples

   .. _zipwith:

   ``zipwith f xs ys``
     apply the binary function ``f`` to corresponding elements of ``xs``
     and ``ys``

   .. _zipwith3:

   ``zipwith3 f xs ys zs``
     apply the ternary function ``f`` to corresponding elements of ``xs``,
     ``ys`` and ``zs``

   Pure also has the following variations of ``zipwith``/``zipwith3`` which
   throw away all intermediate results and return ``()``. That is, these work
   like |do|_ but pull arguments from two or three lists, respectively:

   .. _dowith:

   ``dowith f xs ys``
     apply the binary function ``f`` to corresponding elements of ``xs``
     and ``ys``, return ``()``

   .. _dowith3:

   ``dowith3 f xs ys zs``
     apply the ternary function ``f`` to corresponding elements of ``xs``,
     ``ys`` and ``zs``, return ``()``

*/

zip [] _		|
zip _ []		= [];
zip xs@(_:_) ys@(_:_)	= tick [] xs ys
with
  tick us (x:xs) (y:ys)	= tack ((x,y):us) (zip xs ys&)
			    if thunkp xs || thunkp ys;
			= tick ((x,y):us) xs ys;
  tick us [] _		|
  tick us _ []		= tack us [];
  tick us xs ys		= tack us (zip xs ys);
  tack (u:us) vs	= tack us (u:vs);
  tack [] vs		= vs;
end;

zip3 [] _ _		|
zip3 _ [] _		|
zip3 _ _ []		= [];
zip3 xs@(_:_) ys@(_:_) zs@(_:_)
			= tick [] xs ys zs
with
  tick us (x:xs) (y:ys) (z:zs)
			= tack ((x,y,z):us) (zip3 xs ys zs&)
			    if thunkp xs || thunkp ys || thunkp zs;
			= tick ((x,y,z):us) xs ys zs;
  tick us [] _ _	|
  tick us _ [] _	|
  tick us _ _ []	= tack us [];
  tick us xs ys zs	= tack us (zip3 xs ys zs);
  tack (u:us) vs	= tack us (u:vs);
  tack [] vs		= vs;
end;

zipwith f [] _		|
zipwith f _ []		= [];
zipwith f xs@(_:_) ys@(_:_)
			= tick [] xs ys
with
  tick us (x:xs) (y:ys)	= tack (f x y:us) (zipwith f xs ys&)
			    if thunkp xs || thunkp ys;
			= tick (f x y:us) xs ys;
  tick us [] _		|
  tick us _ []		= tack us [];
  tick us xs ys		= tack us (zipwith f xs ys);
  tack (u:us) vs	= tack us (u:vs);
  tack [] vs		= vs;
end;

zipwith3 f [] _ _		|
zipwith3 f _ [] _		|
zipwith3 f _ _ []		= [];
zipwith3 f xs@(_:_) ys@(_:_) zs@(_:_)
			= tick [] xs ys zs
with
  tick us (x:xs) (y:ys) (z:zs)
			= tack (f x y z:us) (zipwith3 f xs ys zs&)
			    if thunkp xs || thunkp ys || thunkp zs;
			= tick (f x y z:us) xs ys zs;
  tick us [] _ _	|
  tick us _ [] _	|
  tick us _ _ []	= tack us [];
  tick us xs ys zs	= tack us (zipwith3 f xs ys zs);
  tack (u:us) vs	= tack us (u:vs);
  tack [] vs		= vs;
end;

dowith f (x:xs) (y:ys)	= f x y $$ dowith f xs ys;
dowith f _ _		= () otherwise;

dowith3 f (x:xs) (y:ys) (z:zs)
			= f x y z $$ dowith3 f xs ys zs;
dowith3 f _ _ _		= () otherwise;

unzip []		= [],[];
unzip us@(_:_)		= foldr accum ([],[]) us
with
  accum u@(x,y) us	= x:(xs when xs,_ = check us end)&,
			  y:(ys when _,ys = check us end)& if thunkp us;
			= x:xs,y:ys when xs,ys = check us end;
  accum u _		= throw (bad_tuple_value u);
  check us@(_,_)	= us;
  check (foldr _ _ us)	= throw (bad_list_value us);
  check us		= throw (bad_tuple_value us);
end;

unzip3 []		= [],[],[];
unzip3 us@(_:_)		= foldr accum ([],[],[]) us
with
  accum u@(x,y,z) us	= x:(xs when xs,_,_ = check us end)&,
			  y:(ys when _,ys,_ = check us end)&,
			  z:(zs when _,_,zs = check us end)& if thunkp us;
			= x:xs,y:ys,z:zs when xs,ys,zs = check us end;
  accum u _		= throw (bad_tuple_value u);
  check us@(_,_,_)	= us;
  check (foldr _ _ us)	= throw (bad_list_value us);
  check us		= throw (bad_tuple_value us);
end;
