
/* Basic string functions. */

/* Copyright (c) 2008 by Albert Graef <Dr.Graef@t-online.de>.

   This file is part of the Pure programming language and system.

   Pure is free software: you can redistribute it and/or modify it under the
   terms of the GNU General Public License as published by the Free Software
   Foundation, either version 3 of the License, or (at your option) any later
   version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
   details.

   You should have received a copy of the GNU General Public License along
   with this program.  If not, see <http://www.gnu.org/licenses/>. */

using namespace C;

/* ..

   String Functions
   ----------------

   .. _strings:

   Pure strings are null-terminated character strings encoded in UTF-8, see
   the `Pure Manual`_ for details. The prelude provides various operations on
   strings, including a complete set of list-like operations, so that strings
   can be used mostly as if they were lists, although they are really
   implemented as C character arrays for reasons of efficiency.

   Basic String Functions
   ~~~~~~~~~~~~~~~~~~~~~~

   .. _string concatenation:
   .. _string indexing:
   .. _string slicing:
   .. _+ (string):
   .. _! (string):
   .. _!! (string):

   Concatenation, indexing and slicing works just like with lists::

     > "abc"+"xyz";
     "abcxyz"
     > let s = "The quick brown fox jumps over the lazy dog.";
     > s!5;
     "u"
     > s!!(20..24);
     "jumps"

   .. _string size:
   .. _null (string):
   .. _# (string):

   Checking for empty strings and determining the size of a string also works
   as expected::

     > null "";
     1
     > null s;
     0
     > #s;
     44

   You can search for the location of a substring in a string, and extract a
   substring of a given length:

   .. _index (string):

   ``index s u``
     Returns the (zero-based) index of the first occurrence of the substring
     ``u`` in ``s``, or -1 if ``u`` is not found in ``s``.

   .. _substr:

   ``substr s i n``
     Extracts a substring of (at most) ``n`` characters at position ``i`` in
     ``s``. This takes care of all corner cases, adjusting index and number of
     characters so that the index range stays confined to the source string.

   Example::

     > index s "jumps";
     20
     > substr s 20 10;
     "jumps over"

   Note that Pure doesn't have a separate type for individual characters.
   Instead, these are represented as strings ``c`` containing exactly one
   (UTF-8) character (i.e., ``#c==1``). It is possible to convert such single
   character strings to the corresponding integer character codes, and vice
   versa:

   .. _ord:

   ``ord c``
     Ordinal number of a single character string ``c``. This is the
     character's code point in the Unicode character set.

   .. _chr:

   ``chr n``
     Converts an integer back to the character with the corresponding code
     point.

   .. _character arithmetic:

   In addition, the usual character arithmetic works, including arithmetic
   sequences of characters, so that you can write stuff like the following::

     > "a"-"A";
     32
     > "u"-32;
     "U"
     > "a".."k";
     ["a","b","c","d","e","f","g","h","i","j","k"]

   Strings are also ordered lexicographically based on their character codes::

     > "awe">"awesome";
     0
     > "foo">="bar";
     1

   For convenience, the prelude provides the following functions to convert
   between strings and lists (or other aggregates) of characters.

   .. _chars:
   .. _list (string):

   ``chars s``, ``list s``
     Convert a string ``s`` to a list of characters.

   .. _tuple (string):
   .. _matrix (string):

   ``tuple s``, ``matrix s``
     Convert a string ``s`` to a tuple or (symbolic) matrix of characters,
     respectively.

   .. _strcat:

   ``strcat xs``
     Concatenate a list ``xs`` of strings (in particular, this converts a
     list of characters back to a string).

   .. _string:

   ``string xs``
     Convert a list, tuple or (symbolic) matrix of strings to a string.
     In the case of a list, this is synonymous with strcat_, but it also
     works with the other types of aggregates.

   For instance::

     > list "abc";
     ["a","b","c"]
     > string ("a".."z");
     "abcdefghijklmnopqrstuvwxyz"

   The following functions are provided to deal with strings of "tokens"
   separated by a given delimiter string.

   .. _split:

   ``split delim s``
     Splits ``s`` into a list of substrings delimited by ``delim``.

   .. _join:

   ``join delim xs``
     Joins the list of strings ``xs`` to a single string, interpolating the
     given ``delim`` string.

   Example::

     > let xs = split " " s; xs;
     ["The","quick","brown","fox","jumps","over","the","lazy","dog."]
     > join ":" xs;
     "The:quick:brown:fox:jumps:over:the:lazy:dog."

   We mention in passing here that more elaborate string matching, splitting
   and replacement operations based on regular expressions are provided by the
   system module, see `System Interface`_.

   If that isn't enough already, most generic list operations carry over to
   strings in the obvious way, treating the string like a list of
   characters. For instance::

     > filter (\x->x>="k") s;
     "qukrownoxumpsovrtlzyo"
     > map pred ["i","b","m"];
     ["h","a","l"]

   This also provides for list comprehensions drawing values from strings::

     > string [x+1 | x="HAL"];
     "IBM"

   Eval and Friends
   ~~~~~~~~~~~~~~~~

   Pure provides some rather powerful operations to convert between Pure
   expressions and their string representation. This is useful for
   metaprogramming purposes. It also provides a convenient means to serialize
   Pure expressions, e.g., when they are transferred from/to persistant
   storage or transmitted over a socket. (Note, however, that this has its
   limitations. Specifically, some objects like pointers and local or
   anonymous functions do not have a parseable string representation.)

   .. _str:

   ``str x``
     Yields the print representation of an expression in Pure syntax, as a
     string.

   .. _eval:

   ``eval x``
     Parses an expression, specified as a string in Pure syntax, and returns
     its value. In fact, ``eval`` can also parse and execute arbitrary Pure
     code. In that case it will return the last computed expression, if any.

     Alternatively, ``eval`` can also be invoked on a (quoted) Pure
     expression, which is recompiled and then evaluated. (If the expression
     cannot be compiled for some reason then ``eval`` just returns it as
     is. Also, exceptions during evaluation are reported back to the
     caller.) */

namespace C;
extern void* str(expr*) = pure_str;
namespace;

extern expr* eval(expr*); // IMPURE!

str x			= cstring (pure_str x);

/* .. _evalcmd:

   ``evalcmd x``
     Like eval_, but allows execution of interactive commands and returns
     their captured output as a string. No other results are returned, so this
     operation is most useful for executing Pure definitions and interactive
     commands for their side-effects. (At this time, only the regular output
     of a few commands can be captured, most notably ``clear``, ``save`` and
     ``show``; otherwise the result string will be empty.) */

extern expr* evalcmd(expr*); // IMPURE!

/* .. _lasterr:

   ``lasterr``
     Reports errors in eval_ and evalcmd_. This string value will be nonempty
     iff a compilation or execution error was encountered during the most
     recent invokation of ``eval`` and ``evalcmd``. In that case each reported
     error message is terminated with a newline character.

   Examples::

     > str (1/3);
     "0.333333333333333"
     > eval "1/3";
     0.333333333333333
     > eval (quote (1/3));
     0.333333333333333
     > evalcmd "show evalcmd";
     "extern expr* evalcmd(expr*);\n"
     > eval "1/3)";
     eval "1/3)"
     > lasterr;
     "<stdin>, line 1: syntax error, unexpected ')', expecting '=' or '|'\n"

*/

extern char* lasterr();

/* Convert between Unicode character codes and single character strings. */

namespace C;
extern expr* string_chr(int);
extern expr* string_ord(void*);
namespace;

chr n::int		= c if stringp c when c = string_chr n end;
ord s::string		= n if intp n when n = string_ord s end;

/* ..

   Low-Level Operations
   ~~~~~~~~~~~~~~~~~~~~

   The following routines are provided by the runtime to turn raw C ``char*``
   pointers (also called `byte strings` in Pure parlance, to distinguish them
   from Pure's "cooked" UTF-8 string values) into corresponding Pure
   strings. Normally you don't have to worry about this, because the C
   interface already takes care of the necessary marshalling, but in some
   low-level code these operations are useful. Also note that here and in the
   following, the ``cstring`` routines also convert the string between the
   system encoding and Pure's internal UTF-8 representation.

   .. _string (pointer):
   .. _cstring:

   ``string s``, ``cstring s``
     Convert a pointer ``s`` to a Pure string. ``s`` must point to a
     null-terminated C string. These routines take ownership of the original
     string value, assuming it to be ``malloc``\ ed, so you should only use
     these for C strings which are specifically intended to be freed by the
     user.

   .. _string_dup:
   .. _cstring_dup:

   ``string_dup s``, ``cstring_dup s``
     Convert a pointer ``s`` to a Pure string. Like above, but these functions
     take a copy of the string, leaving the original C string untouched. */

namespace C;
extern expr* pure_string(void* s);
extern expr* pure_cstring(void* s);
extern expr* pure_string_dup(void* s);
extern expr* pure_cstring_dup(void* s);
namespace;

string s::pointer	= pure_string s;
cstring s::pointer	= pure_cstring s;
string_dup s::pointer	= pure_string_dup s;
cstring_dup s::pointer	= pure_cstring_dup s;

/* ..

   The reverse transformations are also provided. These take a Pure string to
   a byte string (raw ``char*``).

   .. _byte_string:
   .. _byte_cstring:

   ``byte_string s``, ``byte_cstring s``
     Construct a byte string from a Pure string ``s``. The result is a raw
     pointer object pointing to the converted string. The original Pure string
     is always copied (and, in the case of ``byte_cstring``, converted to the
     system encoding). The resulting byte string is a ``malloc``\ ed pointer
     which can be used like a C ``char*``, and has to be freed explicitly by
     the caller when no longer needed. */

namespace C;
extern expr* pure_byte_string(void *s);
extern expr* pure_byte_cstring(void *s);
namespace;

byte_string s::string	= pure_byte_string s;
byte_cstring s::string	= pure_byte_cstring s;

/* ..

   Finally, it is also possible to convert Pure string lists to byte string
   vectors and vice versa. These are useful if you need to pass an
   ``argv``-like string vector (i.e., a ``char**`` or ``char*[]``) to C
   routines. The computed C vectors are ``malloc``\ ed pointers which have an
   extra ``NULL`` pointer as the last entry, and should thus be usable for
   almost any purpose which requires such a string vector in C. They also take
   care of garbage-collecting themselves. The original string data is always
   copied. As usual, the ``cstring`` variants do automatic conversions to the
   system encoding.

   .. _byte_string_pointer:
   .. _byte_cstring_pointer:

   ``byte_string_pointer xs``, ``byte_cstring_pointer xs``
     Convert a list of Pure strings to a C ``char**``. */

byte_string_pointer xs	= if null p then throw malloc_error
			  else make_pointer (map byte_string xs)
with
  make_pointer xs = sentry free_pointer p when
    dowith (\i x -> put_pointer (p+i*SIZEOF_POINTER) x) (0..n-1) xs;
  end;
  free_pointer p = free p when
    do (\i -> free (get_pointer (p+i*SIZEOF_POINTER))) (0..n-1);
  end;
end
when
  n = #xs; p = calloc (n+1) SIZEOF_POINTER;
end if listp xs && all stringp xs;

byte_cstring_pointer xs	= if null p then throw malloc_error
			  else make_pointer (map byte_cstring xs)
with
  make_pointer xs = sentry free_pointer p when
    dowith (\i x -> put_pointer (p+i*SIZEOF_POINTER) x) (0..n-1) xs;
  end;
  free_pointer p = free p when
    do (\i -> free (get_pointer (p+i*SIZEOF_POINTER))) (0..n-1);
  end;
end
when
  n = #xs; p = calloc (n+1) SIZEOF_POINTER;
end if listp xs && all stringp xs;

/* .. _string_list:
   .. _cstring_list:

   ``string_list n p``, ``cstring_list n p``
     Convert a C ``char**`` to a list of Pure strings.

   Note that the back conversions take an additional first argument which
   denotes the number of strings to retrieve. If you know that the vector is
   ``NULL``-terminated then this can also be an infinite value (``inf``) in
   which case the number of elements will be figured out automatically.
   Processing always stops at the first ``NULL`` pointer encountered. */

string_list n p::pointer = list $ takewhile stringp [p!i | i = 0..n-1]
with
  p!i = if null q then q else string_dup q
	when q = get_pointer (p+i*SIZEOF_POINTER) end;
end if ~null p && (intp n || infp n);

cstring_list n p::pointer = list $ takewhile stringp [p!i | i = 0..n-1]
with
  p!i = if null q then q else cstring_dup q
	when q = get_pointer (p+i*SIZEOF_POINTER) end;
end if ~null p && (intp n || infp n);

/* Character arithmetic. This allows single-character strings to be used,
   e.g., in arithmetic sequences like "a".."z". */

c::string+n::int	= chr (ord c+n) if #c==1;
c::string-n::int	= chr (ord c-n) if #c==1 && ord c>=n;
c::string-d::string	= ord c-ord d if #c==1 && #d==1;

/* Basic string operations: size, indexing, and concatenation. These properly
   deal with multibyte characters. Therefore indexing every character in a
   string takes quadratic time; as a remedy, we also offer a linear-time
   operation to determine the list of all characters of a string in one go. */

namespace C;
extern bool string_null(void*);
extern int string_size(void*);
extern expr* string_concat(void*, void*);
extern expr* string_char_at(void*, int);
extern expr* string_chars(void*);
namespace;

null s::string		= string_null s;
#s::string		= string_size s;
s::string!n::int	= string_char_at s n if n>=0 && n<#s;
			= throw out_of_bounds otherwise;
s::string+t::string	= string_concat s t;
chars s::string		= string_chars s if varp (:);
/* For the sake of efficiency, string_chars takes some shortcuts when creating
   the output list. This is ok as long as (:) doesn't have any constructor
   equations, but in the (unlikely) case that there are, we need to force
   these to be applied now. */
			= list (string_chars s);

/* Lexicographic string comparison. */

namespace C;
extern int strcmp(void*, void*);
namespace;

x::string<y::string	= strcmp x y < 0;
x::string>y::string	= strcmp x y > 0;
x::string<=y::string	= strcmp x y <= 0;
x::string>=y::string	= strcmp x y >= 0;
x::string==y::string	= strcmp x y == 0;
x::string~=y::string	= strcmp x y ~= 0;

/* Compute and find substrings of a string. */

namespace C;
extern expr* string_substr(void*, int, int);
extern int string_index(void*, void*);
namespace;

substr s::string pos::int size::int
			= string_substr s (max 0 pos) (max 0 size)
			  with max x y = if x>=y then x else y end;
index s::string u::string
			= string_index s u;

/* String slices. The case of contiguous and monotonous ranges is optimized by
   making good use of the 'substr' operation above. */

s::string!!ns		= case ns of
			    ns@(n:_) = substr s n (count ns) if cont ns;
			    _ = string (chars s!!ns);
			  end with
			    cont [n::int] = 1;
			    cont (n::int:ns@(m::int:_)) = cont ns if m==n+1;
			    cont _ = 0 otherwise;
			    count ns = #dropwhile (\n::int->n<0) ns;
			  end;

/* Concatenate a list of strings. */

namespace C;
extern expr* string_concat_list(expr*);
namespace;
strcat xs		= string_concat_list xs if listp xs && all stringp xs;

/* Concatenate a list of strings, interpolating a given delimiter. */

join delim::string []	= "";
join delim::string (x::string:xs)
			= x + strcat [delim+x | x = xs]
			    if listp xs && all stringp xs;

/* Split a string into parts delimited by the given (nonempty) string. */

split delim::string s::string
			= if null s then [] else split1 delim s
with
  split1 delim s	= case index s delim of
			    n = take n s : split1 delim (drop (n+m) s) if n>=0;
			      = [s] otherwise;
			  end;
end when m = #delim end if ~null delim;

/* Conversions between between strings and lists, streams and tuples. */

list s::string		= chars s;
stream s::string	= stream (chars s);
tuple s::string		= tuple (chars s);

string []		= "";
string xs@(_::string:_)	= strcat xs if all stringp xs;

string ()		= "";
string xs@(_::string,_)	= strcat xs if all stringp xs when xs = list xs end;

/* Conversions between strings and matrices. */

matrix s::string	= matrix (chars s);
string x::matrix	= string (list x) if all stringp x;

/* Define the customary list operations on strings, so that these can mostly
   be used as if they were lists. */

s::string+[]		= chars s;
s::string+xs@(_:_)	= chars s+xs;
[]+s::string+[]		= chars s;
xs@(_:_)+s::string	= xs+chars s;

reverse s::string	= strcat (reverse (chars s));
catmap f s::string	= catmap f (chars s);
rowcatmap f s::string	= rowcatmap f (chars s);
colcatmap f s::string	= colcatmap f (chars s);
listmap f s::string	= map f (chars s);
rowmap f s::string	= rowmap f (chars s);
colmap f s::string	= colmap f (chars s);

cycle s::string		= cycle (chars s);
cyclen n::int s::string	= cyclen n (chars s) if ~null s;

all p s::string		= all p (chars s);
any p s::string		= any p (chars s);
do f s::string		= do f (chars s);
drop n::int s::string	= substr s n (#s-n);
dropwhile p s::string	= strcat (dropwhile p (chars s));
filter p s::string	= strcat (filter p (chars s));
foldl f a s::string	= foldl f a (chars s);
foldl1 f s::string	= foldl1 f (chars s);
foldr f a s::string	= foldr f a (chars s);
foldr1 f s::string	= foldr1 f (chars s);
head s::string		= s!0 if ~null s;
init s::string		= substr s 0 (#s-1) if ~null s;
last s::string		= s!(#s-1) if ~null s;
map f s::string		= map f (chars s);
scanl f a s::string	= scanl f a (chars s);
scanl1 f s::string	= scanl1 f (chars s);
scanr f a s::string	= scanr f a (chars s);
scanr1 f s::string	= scanr1 f (chars s);
take n::int s::string	= substr s 0 n;
takewhile p s::string	= strcat (takewhile p (chars s));
tail s::string		= substr s 1 (#s-1) if ~null s;
zip s::string t::string	= zip (chars s) (chars t);
zip3 s::string t::string u::string
			= zip3 (chars s) (chars t) (chars u);
zipwith f s::string t::string
			= zipwith f (chars s) (chars t);
zipwith3 f s::string t::string u::string
			= zipwith3 f (chars s) (chars t) (chars u);
dowith f s::string t::string
			= dowith f (chars s) (chars t);
dowith3 f s::string t::string u::string
			= dowith3 f (chars s) (chars t) (chars u);
