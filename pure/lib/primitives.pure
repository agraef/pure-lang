
/* Pure primitives. These operations are implemented either directly by
   machine instructions or by C functions provided in the runtime. */

/* Copyright (c) 2008 by Albert Graef <Dr.Graef@t-online.de>.

   This file is part of the Pure programming language and system.

   Pure is free software: you can redistribute it and/or modify it under the
   terms of the GNU General Public License as published by the Free Software
   Foundation, either version 3 of the License, or (at your option) any later
   version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
   details.

   You should have received a copy of the GNU General Public License along
   with this program.  If not, see <http://www.gnu.org/licenses/>. */

using namespace C;

/* ..

   Primitives
   ----------

   This prelude module is a collection of various lowlevel operations, which
   are implemented either directly by machine instructions or by C functions
   provided in the runtime. In particular, this module defines the basic
   arithmetic and logic operations on machine integers, bigints and floating
   point numbers, as well as various type checking predicates and conversions
   between different types. Some low-level pointer operations are also
   provided, as well as "sentries" (Pure's flavour of object finalizers) and
   "references" (mutable expression pointers).

   Arithmetic
   ~~~~~~~~~~

   The basic arithmetic and logic operations provided by this module are
   summarized in the following table:

   .. _+:
   .. _-:
   .. _*:
   .. _/:
   .. _div:
   .. _mod:
   .. _^:
   .. _==:
   .. _~=:
   .. _<:
   .. _>:
   .. _<=:
   .. _>=:
   .. _~:
   .. _&&:
   .. _||:
   .. _not:
   .. _and:
   .. _or:
   .. _<<:
   .. _>>:

   ===========  ===============  =========================================
   Kind         Operator         Meaning
   ===========  ===============  =========================================
   Arithmetic   ``+`` ``-``      addition, subtraction (also unary minus),
                ``*`` ``/``      multiplication, division (inexact),
                ``div`` ``mod``  exact int/bigint division/modulus,
                ``^``            exponentiation (inexact)
   Comparisons  ``==`` ``~=``    equality, inequality,
                ``<`` ``>``      less than, greater than,
                ``<=`` ``>=``    less than or equal, greater than or equal
   Logic        ``~``            logical not,
                ``&&`` ``||``    and, or (short-circuit)
   Bitwise      ``not``          bitwise not,
                ``and`` ``or``   and, or,
                ``<<`` ``>>``    bit shifts
   ===========  ===============  =========================================

   Precedence and and associativity of the operators can be found in the
   operators_ table at the beginning of this section.

   The names of some operations are at odds with C. Note, in particular, that
   logical negation is denoted ``~`` instead of ``!`` (and, consequently,
   ``~=`` denotes inequality, rather than ``!=``), and the bitwise operations
   are named differently. This is necessary because Pure uses ``!``, ``&`` and
   ``|`` for other purposes. Also, ``/`` always denotes inexact (double)
   division in Pure, whereas the integer division operators are called ``div``
   and ``mod``. (``%``, which is not defined by this module, also has a
   different meaning in Pure; it's the exact division operator, see `Rational
   Numbers`_.)

   The above operations are implemented for int, bigint and, where
   appropriate, double and pointer operands. (Pointer arithmetic comprises
   ``+`` and ``-`` and works in the usual way, i.e., ``p-q`` returns the byte
   offset between two pointers ``p`` and ``q``, and ``p+n`` or ``p-n`` offsets
   a pointer ``p`` by the given integer ``n`` denoting the amount of bytes.) 
   The math module (see `Mathematical Functions`_) also provides
   implementations of the arithmetic and comparison operators for rational,
   complex and complex rational numbers.

   Note that the logical operations are actually implemented as special forms
   in order to provide for short-circuit evaluation. This needs special
   support from the compiler to work. The primitives module still provides
   definitions for these, as well as other special forms like ``quote`` and
   the thunking operator ``&`` so that they may be used as function values and
   in partial applications, but when used in this manner they lose all their
   special call-by-name properties; see `Special Forms`_ in the Pure Manual
   for details.

   The constants ``inf`` and ``nan`` are defined as the usual IEEE floating
   point infinities and NaNs, and the predicates ``infp`` and ``nanp`` are
   provided to check for these kinds of values.

   In addition, the following arithmetic and numeric functions are provided:

   .. _abs:
   .. _sgn:

   ``abs x``, ``sgn x``
     Absolute value and sign of a number.

   .. _min:
   .. _max:

   ``min x y``, ``max x y``
     Minimum and maximum of two values. This works with any kind of values
     which have the ordering relations defined on them.

   .. _succ:
   .. _pred:

   ``succ x``, ``pred x``
     Successor (``+1``) and predecessor (``-1``) functions.

   .. _gcd:
   .. _lcd:

   ``gcd x y``, ``lcd x y``
     The greatest common divisor and least common multiple functions from the
     GMP library. These return a bigint if at least one of the arguments is a
     bigint, a machine int otherwise.

   .. _pow:

   ``pow x y``
     Computes exact powers of ints and bigints. The result is always a
     bigint. Note that ``y`` must always be nonnegative here, but see the math
     module (`Mathematical Functions`_) which deals with the case ``y<0``
     using rational numbers.

   Conversions
   ~~~~~~~~~~~

   These operations convert between various types of Pure values.

   .. _hash:

   ``hash x``
     Compute a 32 bit hash code of a Pure expression.

   .. _int:
   .. _bigint:
   .. _double:
   .. _pointer:

   ``int x``, ``bigint x``, ``double x``, ``pointer x``
     Conversions between the different numeric and pointer types.

   .. _ubyte:
   .. _ushort:
   .. _uint:
   .. _ulong:

   ``ubyte x``, ``ushort x``, ``uint x``, ``ulong x``
     Convert signed (8/16/32/64) bit integers to the corresponding unsigned
     quantities. These functions behave as if the value was "cast" to the
     corresponding unsigned C type, and are most useful for dealing with
     unsigned integers returned by external C routines. The routines always
     use the smallest Pure int type capable of holding the result: ``int`` for
     ``ubyte`` and ``ushort``, ``bigint`` for ``uint`` and ``ulong``. (Note
     that in the case of 64 bit values the C interface returns a bigint,
     that's why ``ulong`` takes a bigint parameter. The other routines all
     take an int as input.)

   The following _`rounding functions` work with all kinds of numbers:

   .. _floor:
   .. _ceil:

   ``floor x``, ``ceil x``
     Floor and ceil.

   .. _round:
   .. _trunc:

   ``round x``, ``trunc x``
     Round or truncate to an integer.

   .. _frac:

   ``frac x``
     Fractional part (``x-trunc x``).

   Predicates
   ~~~~~~~~~~

   A syntactic equality test is provided, as well as various type checking
   predicates.

   .. _same:
   .. _===:
   .. _~==:

   ``x===y``, ``x~==y``, ``same x y``
     Syntactic equality. In difference to ``==`` and ``~=`` this is defined on
     all Pure expressions. Basically, two expressions are syntactically equal
     if they print out the same in the interpreter. In the special case of
     pointer objects and closures, which do not have a syntactic
     representation in Pure, ``x`` and ``y`` must be the same object (same
     pointer value or function).

   .. _intp:
   .. _bigintp:
   .. _doublep:
   .. _stringp:
   .. _pointerp:
   .. _matrixp:

   ``intp x``, ``bigintp x``, ``doublep x``, ``stringp x``, ``pointerp x``, ``matrixp x``
     Predicates to check for the built-in types.

   .. _charp:

   ``charp x``
     Single character string predicate.

   .. _numberp:
   .. _complexp:
   .. _realp:
   .. _rationalp:
   .. _integerp:

   ``numberp x``, ``complexp x``, ``realp x``, ``rationalp x``, ``integerp x``
     Additional number predicates.

   .. _exactp:
   .. _inexactp:

   ``exactp x``, ``inexactp x``
     Check whether a number is exact (i.e., doesn't contain any double
     components).

   .. _applp:
   .. _listp:
   .. _listnp:
   .. _tuplep:

   ``applp x``, ``listp x``, ``listnp x``, ``tuplep x``
     Predicates to check for function applications, proper lists, list nodes
     and proper tuples.

   .. _funp:
   .. _lambdap:
   .. _thunkp:
   .. _varp:

   ``funp x``, ``lambdap x``, ``thunkp x``, ``varp x``
     Predicates to check for function objects (named, anonymous or thunk) and
     global (unbound) variables.

   Specials
   ~~~~~~~~

   Some special operations to deal with exceptions and function objects.

   .. _throw:

   ``throw x``
     Throw an exception, cf. `Exception Handling`_.

   .. _Exception Handling: pure.html#exception-handling

   ``force x``
     Force a thunk (``x&``), cf. `Special Forms`_. This usually happens
     automagically when the value of a thunk is needed.

   .. _Special Forms: pure.html#special-forms

   .. _arity:

   ``arity f``
     Get the arity of a function object, i.e., the number of arguments it
     expects. Returns 0 for thunks and saturated applications, -1 for
     over-saturated applications and non-functions.

   Note that only closures (i.e., named and anonymous functions and thunks)
   have a defined arity in Pure, otherwise ``arity`` returns -1 indicating an
   unknown argument count. Partial applications of closures return the number
   of remaining arguments, which may be zero to indicate a `saturated` (but
   unevaluated) application, or -1 for `over-saturated` and constructor
   applications. (Note that in Pure a saturated application may also remain
   unevaluated because there is no definition for the given combination of
   arguments and thus the expression is in normal form, or because the
   application was quoted. If such a normal form application is then applied
   to some "extra" arguments it becomes over-saturated.)

   The value returned by ``arity`` always denotes the `semantic arity` of the
   given function, not the declared `syntactic arity` if the function also
   happens to be an operator symbol. Usually these will coincide (as, e.g., in
   the case of ``+`` which is a binary operator and also expects two
   arguments). But this is not necessarily the case, as shown in the following
   example of a binary operator which actually takes *three* arguments::

     > infix 0 oops;
     > (oops) x y z = x*z+y;
     > arity (oops);
     3
     > arity (5 oops 8);
     1
     > map (5 oops 8) (1..5);
     [13,18,23,28,33]

   Also note that the arity of a *named* function will be the actual number of
   arguments, as given in the function definition::

     > foo x y = x*y;
     > arity foo;
     2
     > arity (foo x);
     1

   In contrast, *anonymous* functions (lambdas) always yield an arity of 1,
   because a multi-argument lambda like ``\x y -> x*y`` is in fact just a
   shorthand for several nested 1-argument lambdas, ``\x -> \y -> x*y`` in
   this example. Hence::

     > bar = \x y -> x*y;
     > arity bar;
     1
     > arity (bar x);
     1

   Note that in either case the arity becomes zero for an unevaluated
   saturated application::

     > arity (foo x y);
     0
     > arity (bar x y);
     0

   Unevaluated thunks, being parameterless closures, yield a zero arity, too::

     > arity (x&);
     0

   By adding extra arguments you then get an over-saturated application::

     > arity (foo x y z);
     -1
     > arity (bar x y z);
     -1
     > arity ((x&) y);
     -1

   Finally, the value -1 is also returned for non-function objects (including
   pure constructors) and their applications::

     > arity 99;
     -1
     > arity (force (x&));
     -1
     > arity (foo 1 2);
     -1
     > arity (baz a b);
     -1
     > arity (x:y);
     -1
     > arity (:);
     -1

*/

extern void pure_throw(expr*) = throw; // IMPURE!

extern expr* pure_force(expr*) = force;

/* Syntactic equality. */

extern bool same(expr* x, expr* y);
x === y		= same x y;
x ~== y		= ~same x y;

/* Predicates to check for the built-in types. */

intp x		= case x of _::int     = 1; _ = 0 end;
bigintp x	= case x of _::bigint  = 1; _ = 0 end;
doublep x	= case x of _::double  = 1; _ = 0 end;
stringp x	= case x of _::string  = 1; _ = 0 end;
pointerp x	= case x of _::pointer = 1; _ = 0 end;
matrixp x	= case x of _::matrix  = 1; _ = 0 end;

/* Additional single character predicate. Note that this implementation is in
   general *much* faster than the naive solution 'stringp x && #x==1', because
   it's guaranteed to run in constant time. */

charp x		= case x of _::string  = intp (ord x); _ = 0 end;

/* Additional number predicates. */

numberp x	= realp x || complexp x;
complexp x	= case x of x+:y | x<:y = realp x && realp y; _ = 0 end;
realp x		= case x of _::int | _::bigint | _::double = 1;
		            x%y = realp x && realp y; _ = 0 end;
rationalp x	= case x of x%y = integerp x && integerp y; _ = 0 end;
integerp x	= case x of _::int | _::bigint = 1; _ = 0 end;

/* Check whether a number is exact (i.e., doesn't contain any double
   components. */

exactp x	= numberp x &&
		  (case x of
		     x+:y = ~doublep x && ~doublep y;
		     x<:y = ~doublep x && ~doublep y;
		     x%y  = ~doublep x && ~doublep y;
		     _ = ~doublep x;
		   end);
inexactp x      = numberp x &&
		  (case x of
		     x+:y = doublep x || doublep y;
		     x<:y = doublep x || doublep y;
		     x%y  = doublep x || doublep y;
		     _ = doublep x;
		   end);

/* Predicates to check for function objects (named, anonymous or thunk) and
   global (unbound) variables. */

extern bool funp(expr*), bool lambdap(expr*), bool thunkp(expr*);
extern bool varp(expr*);

/* Get the arity of a function object, i.e., the number of arguments it
   expects. Returns 0 for thunks and saturated applications, -1 for
   over-saturated applications and non-functions. */

extern expr *arity(expr *x);
arity x@(_ _)	= count 0 x
with
  count n::int (x@_ y)	= count (n+1) x;
  count n::int x	= max (-1) (m-n) if intp m when m = arity x end;
			= -1 otherwise;
end;
arity _		= -1 otherwise;

/* Predicates to check for function applications, proper lists, list nodes and
   proper tuples. */

applp (_ _)	= 1;
applp _		= 0 otherwise;

listp []	= 1;
listp (x:xs)	= listp xs;
listp _		= 0 otherwise;

listnp []	= 1;
listnp (x:xs)	= 1;
listnp _	= 0 otherwise;

tuplep ()	= 1;
tuplep (x,xs)	= 1;
tuplep _	= 0 otherwise;

/* Compute a 32 bit hash code of a Pure expression. */

extern int hash(expr*);

/* Conversions between the different numeric and pointer types. */

namespace C;
extern expr* pure_intval(expr*), expr* pure_dblval(expr*),
  expr* pure_bigintval(expr*), expr* pure_pointerval(expr*);
namespace;

int x::int		= x;
int x::bigint		|
int x::double		|
int x::pointer		= pure_intval x;

bigint x::bigint	= x;
bigint x::int		|
bigint x::double	|
bigint x::pointer	= pure_bigintval x;

double x::double	= x;
double x::int		|
double x::bigint	= pure_dblval x;

pointer x::pointer	= x;
pointer x::int		|
pointer x::bigint	|
pointer x::double	|
pointer x::string	= pure_pointerval x;

/* Convert signed (8/16/32/64) bit integers to the corresponding unsigned
   quantities. These functions behave as if the value was "cast" to the
   corresponding unsigned C type, and are most useful for dealing with
   unsigned integers returned by external C routines. The routines always use
   the smallest Pure int type capable of holding the result: int for ubyte and
   ushort, bigint for uint and ulong. (Note that in the case of 64 bit values
   the C interface returns a bigint, that's why ulong takes a bigint
   parameter. The other routines all take an int as input.)  */

ubyte x::int		= if x>=0 then x else x+0x100;
ushort x::int		= if x>=0 then x else x+0x10000;
uint x::int		= if x>=0 then bigint x else x+0x100000000L;
ulong x::bigint		= if x>=0 then x else x+0x10000000000000000L;

/* Rounding functions. */

extern double floor(double), double ceil(double);
extern double __round(double) = round, double __trunc(double) = trunc;

floor x::int | floor x::bigint = x;
ceil x::int | ceil x::bigint = x;
round x::int | round x::bigint = x;
trunc x::int | trunc x::bigint = x;

// Fractional part of x.
frac x::int | frac x::bigint | frac x::double = x-trunc x;

/* Absolute value and sign of a number. Note that these don't distinguish
   between IEEE 754 positive and negative zeros; abs always returns 0.0, sgn 0
   for these. The real sign bit of a floating point zero can be obtained with
   sgn (1/x). */

abs x::int | abs x::bigint | abs x::double
			= if x>0 then x else -x;
sgn x::int | sgn x::bigint | sgn x::double
			= if x>0 then 1 else if x<0 then -1 else 0;

/* Generic min and max functions. */

min x y			= if x<=y then x else y;
max x y			= if x>=y then x else y;

/* Generic succ and pred functions. */

succ x			= x+1;
pred x			= x-1;

/* Basic int and double arithmetic. The Pure compiler already knows how to
   handle these, we just need to supply rules with the right type tags. */

-x::int			= -x;
~x::int			= ~x;
not x::int		= not x;

x::int<<y::int		= x<<y;
x::int>>y::int		= x>>y;

x::int+y::int		= x+y;
x::int-y::int		= x-y;
x::int*y::int		= x*y;
x::int/y::int		= x/y;
x::int div y::int	= x div y;
x::int mod y::int	= x mod y;
x::int or y::int	= x or y;
x::int and y::int	= x and y;

x::int<y::int		= x<y;
x::int>y::int		= x>y;
x::int<=y::int		= x<=y;
x::int>=y::int		= x>=y;
x::int==y::int		= x==y;
x::int~=y::int		= x~=y;

-x::double		= -x;

x::double+y::double	= x+y;
x::double-y::double	= x-y;
x::double*y::double	= x*y;
x::double/y::double	= x/y;

x::double<y::double	= x<y;
x::double>y::double	= x>y;
x::double<=y::double	= x<=y;
x::double>=y::double	= x>=y;
x::double==y::double	= x==y;
x::double~=y::double	= x~=y;

// mixed operands

x::int+y::double	= x+y;
x::int-y::double	= x-y;
x::int*y::double	= x*y;
x::int/y::double	= x/y;

x::int<y::double	= x<y;
x::int>y::double	= x>y;
x::int<=y::double	= x<=y;
x::int>=y::double	= x>=y;
x::int==y::double	= x==y;
x::int~=y::double	= x~=y;

x::double+y::int	= x+y;
x::double-y::int	= x-y;
x::double*y::int	= x*y;
x::double/y::int	= x/y;

x::double<y::int	= x<y;
x::double>y::int	= x>y;
x::double<=y::int	= x<=y;
x::double>=y::int	= x>=y;
x::double==y::int	= x==y;
x::double~=y::int	= x~=y;

/* Built-in special forms. Please note that these enjoy call-by-name and
   short-circuit evaluation only as explicit calls! But we still want them to
   work if they are applied partially, so we add these rules here. */

x::int&&y::int		= x&&y;
x::int||y::int		= x||y;
x$$y			= y;
x&			= x;
quote x			= x;

/* Bigint arithmetic. */

namespace C;
extern expr* bigint_neg(void*);
extern expr* bigint_not(void*);
extern expr* bigint_add(void*, void*);
extern expr* bigint_sub(void*, void*);
extern expr* bigint_mul(void*, void*);
extern expr* bigint_div(void*, void*);
extern expr* bigint_mod(void*, void*);
extern expr* bigint_shl(void*, int);
extern expr* bigint_shr(void*, int);
extern expr* bigint_and(void*, void*);
extern expr* bigint_or(void*, void*);
extern int bigint_cmp(void*, void*);
namespace;

-x::bigint		= bigint_neg x;
not x::bigint		= bigint_not x;

x::bigint<<y::int	= bigint_shl x y if y>=0;
			= bigint_shr x (-y);
x::bigint>>y::int	= bigint_shr x y if y>=0;
			= bigint_shl x (-y);

x::bigint+y::bigint	= bigint_add x y;
x::bigint-y::bigint	= bigint_sub x y;
x::bigint*y::bigint	= bigint_mul x y;
x::bigint/y::bigint	= double x / double y;
x::bigint div y::bigint	= bigint_div x y;
x::bigint mod y::bigint	= bigint_mod x y;
x::bigint or y::bigint	= bigint_or x y;
x::bigint and y::bigint	= bigint_and x y;

x::bigint<y::bigint	= bigint_cmp x y < 0;
x::bigint>y::bigint	= bigint_cmp x y > 0;
x::bigint<=y::bigint	= bigint_cmp x y <= 0;
x::bigint>=y::bigint	= bigint_cmp x y >= 0;
x::bigint==y::bigint	= bigint_cmp x y == 0;
x::bigint~=y::bigint	= bigint_cmp x y ~= 0;

// mixed int/bigint (promote int to bigint)

x::int+y::bigint	= bigint x+y;
x::int-y::bigint	= bigint x-y;
x::int*y::bigint	= bigint x*y;
x::int/y::bigint	= double x/y;
x::int div y::bigint	= bigint x div y;
x::int mod y::bigint	= bigint x mod y;
x::int or y::bigint	= bigint x or y;
x::int and y::bigint	= bigint x and y;

x::int<y::bigint	= bigint x<y;
x::int>y::bigint	= bigint x>y;
x::int<=y::bigint	= bigint x<=y;
x::int>=y::bigint	= bigint x>=y;
x::int==y::bigint	= bigint x==y;
x::int~=y::bigint	= bigint x~=y;

x::bigint+y::int	= x+bigint y;
x::bigint-y::int	= x-bigint y;
x::bigint*y::int	= x*bigint y;
x::bigint/y::int	= x/double y;
x::bigint div y::int	= x div bigint y;
x::bigint mod y::int	= x mod bigint y;
x::bigint or y::int	= x or bigint y;
x::bigint and y::int	= x and bigint y;

x::bigint<y::int	= x<bigint y;
x::bigint>y::int	= x>bigint y;
x::bigint<=y::int	= x<=bigint y;
x::bigint>=y::int	= x>=bigint y;
x::bigint==y::int	= x==bigint y;
x::bigint~=y::int	= x~=bigint y;

// mixed double/bigint (promote bigint to double)

x::bigint+y::double	= double x+y;
x::bigint-y::double	= double x-y;
x::bigint*y::double	= double x*y;
x::bigint/y::double	= double x/y;

x::bigint<y::double	= double x<y;
x::bigint>y::double	= double x>y;
x::bigint<=y::double	= double x<=y;
x::bigint>=y::double	= double x>=y;
x::bigint==y::double	= double x==y;
x::bigint~=y::double	= double x~=y;

x::double+y::bigint	= x+double y;
x::double-y::bigint	= x-double y;
x::double*y::bigint	= x*double y;
x::double/y::bigint	= x/double y;

x::double<y::bigint	= x<double y;
x::double>y::bigint	= x>double y;
x::double<=y::bigint	= x<=double y;
x::double>=y::bigint	= x>=double y;
x::double==y::bigint	= x==double y;
x::double~=y::bigint	= x~=double y;

/* The gcd and lcm functions from the GMP library. These return a bigint if at
   least one of the arguments is a bigint, a machine int otherwise. */

namespace C;
extern expr* bigint_gcd(void*, void*);
extern expr* bigint_lcm(void*, void*);
namespace;

gcd x::bigint y::bigint	= bigint_gcd x y;
lcm x::bigint y::bigint	= bigint_lcm x y;

gcd x::int y::bigint	= bigint_gcd (bigint x) y;
gcd x::bigint y::int	= bigint_gcd x (bigint y);
gcd x::int y::int	= int (bigint_gcd (bigint x) (bigint y));

lcm x::int y::bigint	= bigint_lcm (bigint x) y;
lcm x::bigint y::int	= bigint_lcm x (bigint y);
lcm x::int y::int	= int (bigint_lcm (bigint x) (bigint y));

/* The pow function. Computes exact powers of ints and bigints. The result is
   always a bigint. Note that y must always be nonnegative here, but see
   math.pure which deals with the case y<0 using rational numbers. */

namespace C;
extern expr* bigint_pow(void*, int);
namespace;

pow x::int y::int	= bigint_pow (bigint x) y if y>=0;
pow x::bigint y::bigint	= bigint_pow x y if y>=0;

// mixed int/bigint
pow x::int y::bigint	= bigint_pow (bigint x) y if y>=0;
pow x::bigint y::int	= bigint_pow x y if y>=0;

/* The ^ operator. Computes inexact powers for any combination of int, bigint
   and double operands. The result is always a double. */

namespace C;
extern double pow(double, double);
namespace;

x::double^y::double	= C::pow x y;
x::int^y::int		|
x::bigint^y::bigint	|
x::int^y::bigint	|
x::bigint^y::int	= C::pow (double x) (double y);
x::double^y::int	|
x::double^y::bigint	= C::pow x (double y);
x::int^y::double	|
x::bigint^y::double	= C::pow (double x) y;

/* Pointer arithmetic. We do this using bigints, so that the code is portable
   to 64 bit systems. */

const NULL = pointer 0; // the null pointer

null x::pointer		= bigint x==0;

x::pointer-y::pointer	= bigint x-bigint y;
x::pointer+y::int	= pointer (bigint x+y);
x::pointer+y::bigint	= pointer (bigint x+y);

x::pointer<y::pointer	= bigint x <  bigint y;
x::pointer>y::pointer	= bigint x >  bigint y;
x::pointer<=y::pointer	= bigint x <= bigint y;
x::pointer>=y::pointer	= bigint x >= bigint y;
x::pointer==y::pointer	= bigint x == bigint y;
x::pointer~=y::pointer	= bigint x ~= bigint y;

/* IEEE floating point infinities and NaNs. Place these after the definitions
   of the built-in operators so that the double arithmetic works. */

const inf = 1.0e307 * 1.0e307; const nan = inf-inf;

/* Predicates to check for inf and nan values. */

infp x		= case x of x::double = x==inf || x==-inf; _ = 0 end;
nanp x		= case x of x::double = ~(x==x); _ = 0 end;

/* Some common special cases of finite arithmetic sequences are implemented
   here using the runtime for better performance. */

namespace C;
extern expr* pure_int_seq(int from, int to, int step);
extern expr* pure_double_seq(double from, double to, double step);
namespace;

n::int..m::int		= C::pure_int_seq n m 1;
n1::int:n2::int..m::int	= C::pure_int_seq n1 m (n2-n1) if n1~=n2;

n::double..m::double	= C::pure_double_seq n m 1.0 if ~infp n && ~infp m;
n::int..m::double	= C::pure_double_seq (double n) m 1.0 if ~infp m;
n::double..m::int	= C::pure_double_seq n (double m) 1.0 if ~infp n;

n1::double:n2::double..m::double
			= C::pure_double_seq n1 m (n2-n1)
			    if ~infp n1 && ~infp m && n1~=n2;
n1::int:n2::double..m::double
			= C::pure_double_seq (double n1) m (n2-n1)
			    if ~infp m && n1~=n2;
n1::double:n2::int..m::double
			= C::pure_double_seq n1 m (n2-n1)
			    if ~infp n1 && ~infp m && n1~=n2;
n1::double:n2::double..m::int
			= C::pure_double_seq n1 (double m) (n2-n1)
			    if ~infp n1 && n1~=n2;
n1::int:n2::int..m::double
			= C::pure_double_seq (double n1) m (double (n2-n1))
			    if ~infp m && n1~=n2;
n1::int:n2::double..m::int
			= C::pure_double_seq (double n1) (double m) (n2-n1)
			    if n1~=n2;
n1::double:n2::int..m::int
			= C::pure_double_seq n1 (double m) (n2-n1)
			    if ~infp n1 && n1~=n2;

/* ..

   Pointer Operations
   ~~~~~~~~~~~~~~~~~~

   These are lowlevel operations dealing with pointer values. The usual
   caveats apply, so *only* use these directly if you know what you're doing!

   .. _addr:

   ``addr symbol``
     Get the address of a C symbol (given as a string) at runtime. The library
     containing the symbol must already be loaded. Note that this can in fact
     be any kind of externally visible C symbol, so it's also possible to get
     the addresses of global variables. The result is returned as a
     pointer. The function fails if the symbol was not found. */

extern expr *pure_addr(char *s) = addr;

/* .. _calloc:
   .. _malloc:
   .. _realloc:
   .. _free:

   ``calloc nmembers size``, ``malloc size``, ``realloc ptr size``, ``free ptr``
     Interface to ``malloc``, ``free`` and friends. These let you allocate
     dynamic buffers (represented as Pure pointer values) for various nasty
     purposes. */

extern void* calloc(size_t nmembers, size_t size);
extern void* malloc(size_t size), void* realloc(void* ptr, size_t size);
extern void free(void* ptr);

/* .. _get_byte:
   .. _get_short:
   .. _get_int:
   .. _get_long:
   .. _get_float:
   .. _get_double:
   .. _get_string:
   .. _get_pointer:
   .. _put_byte:
   .. _put_short:
   .. _put_int:
   .. _put_long:
   .. _put_float:
   .. _put_double:
   .. _put_string:
   .. _put_pointer:

   ``get_byte ptr``, ``get_short ptr``, ``get_int ptr``, ``get_long ptr``, ``get_float ptr``, ``get_double ptr``, ``get_string ptr``, ``get_pointer ptr``

   ``put_byte ptr x``, ``put_short ptr x``, ``put_int ptr x``, ``put_long ptr x``, ``put_float ptr x``, ``put_double ptr x``, ``put_string ptr x``, ``put_pointer ptr x``
     Direct memory accesses. Use with care ... or else! */

namespace C;
extern int pointer_get_byte(void *ptr);
extern int pointer_get_short(void *ptr);
extern int pointer_get_int(void *ptr);
extern long pointer_get_long(void *ptr);
extern int64 pointer_get_int64(void *ptr);
extern double pointer_get_float(void *ptr);
extern double pointer_get_double(void *ptr);
extern char *pointer_get_string(void *ptr);
extern void *pointer_get_pointer(void *ptr);
namespace;

get_byte x::pointer = pointer_get_byte x;
get_short x::pointer = pointer_get_short x;
get_int x::pointer = pointer_get_int x;
get_long x::pointer = pointer_get_long x;
get_int64 x::pointer = pointer_get_int64 x;
get_float x::pointer = pointer_get_float x;
get_double x::pointer = pointer_get_double x;
get_string x::pointer = pointer_get_string x;
get_pointer x::pointer = pointer_get_pointer x;

namespace C;
extern void pointer_put_byte(void *ptr, int x); // IMPURE!
extern void pointer_put_short(void *ptr, int x); // IMPURE!
extern void pointer_put_int(void *ptr, int x); // IMPURE!
extern void pointer_put_long(void *ptr, long x); // IMPURE!
extern void pointer_put_int64(void *ptr, int64 x); // IMPURE!
extern void pointer_put_float(void *ptr, double x); // IMPURE!
extern void pointer_put_double(void *ptr, double x); // IMPURE!
extern void pointer_put_string(void *ptr, char *x); // IMPURE!
extern void pointer_put_pointer(void *ptr, void *x); // IMPURE!
namespace;

put_byte x::pointer y::int = pointer_put_byte x y;
put_short x::pointer y::int = pointer_put_short x y;
put_int x::pointer y::int = pointer_put_int x y;
put_long x::pointer y::int = pointer_put_long x y;
put_long x::pointer y::bigint = pointer_put_long x y;
put_int64 x::pointer y::int = pointer_put_int64 x y;
put_int64 x::pointer y::bigint = pointer_put_int64 x y;
put_float x::pointer y::double = pointer_put_float x y;
put_double x::pointer y::double = pointer_put_double x y;
put_string x::pointer y::string = pointer_put_string x y;
put_pointer x::pointer y::string = pointer_put_pointer x y;
put_pointer x::pointer y::pointer = pointer_put_pointer x y;

/* ..

   Sentries
   ~~~~~~~~

   Sentries are Pure's flavour of object `finalizers`. A sentry is simply a
   function which gets applied to the target expression when it is
   garbage-collected. This is useful to perform automatic cleanup actions on
   objects with internal state, such as files. Pure's sentries are *much* more
   useful than finalizers in other garbage-collected languages, since it is
   guaranteed that they are called as soon as an object "goes out of scope",
   i.e., becomes inaccessible.

   Note that in the current implementation sentries can only be placed at
   applications and pointer objects, but the department of fake statistics has
   assured us that this covers 99% of all practical uses. The sentry itself
   can be any type of object (but usually it's a function). There can be only
   one sentry per expression but, building on the operations provided here,
   it's easy to design a scheme where sentries are chained.

   .. _sentry:

   ``sentry f x``
     Places a sentry ``f`` at an expression ``x`` and returns the modified
     expression.

   .. _clear_sentry:

   ``clear_sentry x``
     Removes the sentry from an expression ``x``.

   .. _get_sentry:

   ``get_sentry x``
     Returns the sentry of an expression ``x`` (if any, fails otherwise). */

extern expr* pure_sentry(expr*,expr*) = sentry; // IMPURE!
extern expr* pure_clear_sentry(expr*) = clear_sentry; // IMPURE!
extern expr* pure_get_sentry(expr*) = get_sentry;

/* .. _cooked:
   .. _cookedp:

   ``cooked ptr``, ``cookedp ptr``
     ``cooked`` is a convenience function to create a `cooked` pointer which
     disposes itself after use. This is just a shorthand for ``sentry
     free``. The given pointer ``ptr`` must be malloc_\ ed to make this
     work. There's also a predicate ``cookedp`` to decide whether a given
     pointer is cooked already (we actually assume any pointer to be cooked
     which has a sentry set on it).

   Example::

     > using system;
     > let p = sentry (\p->puts "I'm done for!" $$ free p) (malloc 1024);
     > cookedp p;
     1
     > clear p
     I'm done for!

*/

cooked p::pointer = sentry free p;
cookedp p = case p of
	      _::pointer =
	       case get_sentry p of
	         get_sentry _ = 0;
	         _ = 1;
	       end;
	      _ = 0;
	    end;

/* ..

   Expression References
   ~~~~~~~~~~~~~~~~~~~~~

   Expression references provide a kind of mutable data cells which can hold
   any Pure expression. If you need these, then you're doomed. ;-) However,
   they can be useful as a last resort when you need to keep track of some
   local state or interface to the messy imperative world. Pure's references
   are actually implemented as expression pointers so that you can readily
   pass them as pointers to a C function which expects a ``pure_expr**``
   parameter. This may even be useful at times.

   .. _ref:

   ``ref x``
     Create a reference pointing to ``x`` initially.

   .. _put:

   ``put r x``
     Set a new value ``x``, and return that value.

   .. _get:

   ``get r``
     Retrieve the current value ``r`` points to.

   .. _unref:

   ``unref r``
     Purge the referenced object and turn the reference into a dangling
     pointer. (This is used as a sentry on reference objects and shouldn't
     normally be called directly.)

   .. _refp:

   ``refp x``
     Predicate to check for reference values.

   Note that manually removing the ``unref`` sentry of a reference turns the
   reference into just a normal pointer object and renders it unusable as a
   reference. Doing this will also leak memory, so don't! */

namespace C;
extern expr* pure_new(expr*), expr* pure_expr_pointer();
extern void pure_free(expr*);
extern expr* pointer_get_expr(void*), void pointer_put_expr(void*, expr*);
namespace;

ref x = pointer_put_expr r (pure_new x) $$
	sentry unref r when r::pointer = pure_expr_pointer end;

unref r::pointer = pure_free (pointer_get_expr r) $$
		   clear_sentry r if refp r;

put r::pointer x = pure_free (pointer_get_expr r) $$
		   pointer_put_expr r (pure_new x) $$ x if refp r;

get r::pointer = pointer_get_expr r if refp r;

refp r = case r of _::pointer = get_sentry r===unref; _ = 0 end;
