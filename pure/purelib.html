<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4: http://docutils.sourceforge.net/" />
<title>Pure Library Manual</title>
<meta name="author" content="Albert Graef &lt;Dr.Graef&#64;t-online.de&gt;" />
<meta name="copyright" content="Copyright (c) 2009" />
<meta name="date" content="2009-03-13" />
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:Date: $Date: 2005-12-18 01:56:14 +0100 (Sun, 18 Dec 2005) $
:Revision: $Revision: 4224 $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

tt.docutils {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="pure-library-manual">
<h1 class="title">Pure Library Manual</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Albert Graef &lt;<a class="reference" href="mailto:Dr.Graef&#64;t-online.de">Dr.Graef&#64;t-online.de</a>&gt;</td></tr>
<tr><th class="docinfo-name">Copyright:</th>
<td>Copyright (c) 2009</td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>2009-03-13</td></tr>
</tbody>
</table>
<!-- We use docutils to produce the documentation. Docstrings are extracted -->
<!-- with pure-doc. Please see the pure-doc documentation for details. -->
<!-- This module is always the first in the library docs, so produce the -->
<!-- title here. -->
<!-- Add all pertaining author and copyright information here. -->
<!-- Add all global docutils declarations here. -->
<p>This document is available under the <a class="reference" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License</a>.</p>
<p>This manual describes the operations in the standard Pure library,
including the prelude and the other library modules which come bundled with
the interpreter. It is woefully incomplete right now, but this is being
worked on.</p>
<p>There is a companion to this manual, the <a class="reference" href="pure.html">Pure Manual</a> which describes the
Pure language and the operation of the Pure interpreter.</p>
<!-- Table of contents, switch on section numbering. -->
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="auto-toc simple">
<li><a class="reference" href="#prelude" id="id48" name="id48">1&nbsp;&nbsp;&nbsp;Prelude</a><ul class="auto-toc">
<li><a class="reference" href="#basic-combinators" id="id49" name="id49">1.1&nbsp;&nbsp;&nbsp;Basic Combinators</a></li>
<li><a class="reference" href="#quasiquote" id="id50" name="id50">1.2&nbsp;&nbsp;&nbsp;Quasiquote</a></li>
<li><a class="reference" href="#lists-and-tuples" id="id51" name="id51">1.3&nbsp;&nbsp;&nbsp;Lists and Tuples</a></li>
<li><a class="reference" href="#list-functions" id="id52" name="id52">1.4&nbsp;&nbsp;&nbsp;List Functions</a><ul class="auto-toc">
<li><a class="reference" href="#common-list-functions" id="id53" name="id53">1.4.1&nbsp;&nbsp;&nbsp;Common List Functions</a></li>
<li><a class="reference" href="#list-generators" id="id54" name="id54">1.4.2&nbsp;&nbsp;&nbsp;List Generators</a></li>
<li><a class="reference" href="#zip-and-friends" id="id55" name="id55">1.4.3&nbsp;&nbsp;&nbsp;Zip and Friends</a></li>
</ul>
</li>
<li><a class="reference" href="#string-functions" id="id56" name="id56">1.5&nbsp;&nbsp;&nbsp;String Functions</a><ul class="auto-toc">
<li><a class="reference" href="#basic-string-functions" id="id57" name="id57">1.5.1&nbsp;&nbsp;&nbsp;Basic String Functions</a></li>
<li><a class="reference" href="#eval-and-friends" id="id58" name="id58">1.5.2&nbsp;&nbsp;&nbsp;Eval and Friends</a></li>
<li><a class="reference" href="#low-level-operations" id="id59" name="id59">1.5.3&nbsp;&nbsp;&nbsp;Low-Level Operations</a></li>
</ul>
</li>
<li><a class="reference" href="#matrix-functions" id="id60" name="id60">1.6&nbsp;&nbsp;&nbsp;Matrix Functions</a></li>
<li><a class="reference" href="#primitives" id="id61" name="id61">1.7&nbsp;&nbsp;&nbsp;Primitives</a><ul class="auto-toc">
<li><a class="reference" href="#arithmetic" id="id62" name="id62">1.7.1&nbsp;&nbsp;&nbsp;Arithmetic</a></li>
<li><a class="reference" href="#conversions" id="id63" name="id63">1.7.2&nbsp;&nbsp;&nbsp;Conversions</a></li>
<li><a class="reference" href="#predicates" id="id64" name="id64">1.7.3&nbsp;&nbsp;&nbsp;Predicates</a></li>
<li><a class="reference" href="#specials" id="id65" name="id65">1.7.4&nbsp;&nbsp;&nbsp;Specials</a></li>
<li><a class="reference" href="#pointer-operations" id="id66" name="id66">1.7.5&nbsp;&nbsp;&nbsp;Pointer Operations</a></li>
<li><a class="reference" href="#sentries" id="id67" name="id67">1.7.6&nbsp;&nbsp;&nbsp;Sentries</a></li>
<li><a class="reference" href="#expression-references" id="id68" name="id68">1.7.7&nbsp;&nbsp;&nbsp;Expression References</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#mathematical-functions" id="id69" name="id69">2&nbsp;&nbsp;&nbsp;Mathematical Functions</a></li>
<li><a class="reference" href="#container-types" id="id70" name="id70">3&nbsp;&nbsp;&nbsp;Container Types</a><ul class="auto-toc">
<li><a class="reference" href="#arrays" id="id71" name="id71">3.1&nbsp;&nbsp;&nbsp;Arrays</a><ul class="auto-toc">
<li><a class="reference" href="#imports" id="id72" name="id72">3.1.1&nbsp;&nbsp;&nbsp;Imports</a></li>
<li><a class="reference" href="#operations" id="id73" name="id73">3.1.2&nbsp;&nbsp;&nbsp;Operations</a></li>
<li><a class="reference" href="#examples" id="id74" name="id74">3.1.3&nbsp;&nbsp;&nbsp;Examples</a></li>
</ul>
</li>
<li><a class="reference" href="#heaps" id="id75" name="id75">3.2&nbsp;&nbsp;&nbsp;Heaps</a><ul class="auto-toc">
<li><a class="reference" href="#id21" id="id76" name="id76">3.2.1&nbsp;&nbsp;&nbsp;Imports</a></li>
<li><a class="reference" href="#id22" id="id77" name="id77">3.2.2&nbsp;&nbsp;&nbsp;Operations</a></li>
<li><a class="reference" href="#id24" id="id78" name="id78">3.2.3&nbsp;&nbsp;&nbsp;Examples</a></li>
</ul>
</li>
<li><a class="reference" href="#dictionaries" id="id79" name="id79">3.3&nbsp;&nbsp;&nbsp;Dictionaries</a><ul class="auto-toc">
<li><a class="reference" href="#id25" id="id80" name="id80">3.3.1&nbsp;&nbsp;&nbsp;Imports</a></li>
<li><a class="reference" href="#data-structure" id="id81" name="id81">3.3.2&nbsp;&nbsp;&nbsp;Data Structure</a></li>
<li><a class="reference" href="#id26" id="id82" name="id82">3.3.3&nbsp;&nbsp;&nbsp;Operations</a></li>
<li><a class="reference" href="#id31" id="id83" name="id83">3.3.4&nbsp;&nbsp;&nbsp;Examples</a></li>
</ul>
</li>
<li><a class="reference" href="#sets-and-bags" id="id84" name="id84">3.4&nbsp;&nbsp;&nbsp;Sets and Bags</a><ul class="auto-toc">
<li><a class="reference" href="#id32" id="id85" name="id85">3.4.1&nbsp;&nbsp;&nbsp;Imports</a></li>
<li><a class="reference" href="#id33" id="id86" name="id86">3.4.2&nbsp;&nbsp;&nbsp;Data Structure</a></li>
<li><a class="reference" href="#id34" id="id87" name="id87">3.4.3&nbsp;&nbsp;&nbsp;Operations</a></li>
<li><a class="reference" href="#id43" id="id88" name="id88">3.4.4&nbsp;&nbsp;&nbsp;Examples</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#system-interface" id="id89" name="id89">4&nbsp;&nbsp;&nbsp;System Interface</a></li>
<li><a class="reference" href="#getopt" id="id90" name="id90">5&nbsp;&nbsp;&nbsp;Getopt</a><ul class="auto-toc">
<li><a class="reference" href="#id44" id="id91" name="id91">5.1&nbsp;&nbsp;&nbsp;Imports</a></li>
<li><a class="reference" href="#id45" id="id92" name="id92">5.2&nbsp;&nbsp;&nbsp;Operations</a></li>
<li><a class="reference" href="#id46" id="id93" name="id93">5.3&nbsp;&nbsp;&nbsp;Examples</a></li>
</ul>
</li>
<li><a class="reference" href="#id47" id="id94" name="id94">6&nbsp;&nbsp;&nbsp;Index</a></li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id48" id="prelude" name="prelude">1&nbsp;&nbsp;&nbsp;Prelude</a></h1>
<p>The prelude defines the basic operations of the Pure language. This
includes the basic arithmetic and logical operations, string, list and
matrix functions, as well as the support operations required to implement
list and matrix comprehensions. (The string and matrix operations are in
separate modules string.pure and matrix.pure, the primitive arithmetic and
logical operations can be found in primitives.pure.)</p>
<p>The prelude also declares a signature of commonly used constant and
operator symbols. This comprises:</p>
<a name="failed_cond"><a name="failed_match"><a name="stack_fault"><a name="bad_matrix_value"><ul class="simple" id="bad-matrix-value">
<span id="stack-fault"></span><span id="failed-match"></span><span id="failed-cond"></span><li>The built-in exception values <tt class="docutils literal"><span class="pre">failed_cond</span></tt> (failed conditional in
guard or if-then-else), <tt class="docutils literal"><span class="pre">failed_match</span></tt> (failed pattern match in lambda,
<tt class="docutils literal"><span class="pre">case</span></tt> expression, etc.), <tt class="docutils literal"><span class="pre">stack_fault</span></tt> (not enough stack space,
<tt class="docutils literal"><span class="pre">PURE_STACK</span></tt> limit exceeded) and <tt class="docutils literal"><span class="pre">bad_matrix_value</span> <span class="pre">x</span></tt> (error in
matrix construction).</li>
</ul>
<a name="bad_list_value"><a name="bad_tuple_value"><a name="out_of_bounds"><a name="malloc_error"><ul class="simple" id="malloc-error">
<span id="out-of-bounds"></span><span id="bad-tuple-value"></span><span id="bad-list-value"></span><li>Other predefined exceptions: <tt class="docutils literal"><span class="pre">bad_list_value</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">bad_tuple_value</span> <span class="pre">x</span></tt>
(which are thrown by some list and tuple operations when they fail to
find an expected list or tuple value), <tt class="docutils literal"><span class="pre">out_of_bounds</span></tt> (which is thrown
by the index operator <tt class="docutils literal"><span class="pre">!</span></tt> if a list, tuple or matrix index is out of
bounds), and <tt class="docutils literal"><span class="pre">malloc_error</span></tt> which indicates a memory allocation error.</li>
</ul>
<a name="true"><a name="false"><ul class="simple" id="false">
<span id="true"></span><li>The truth values <tt class="docutils literal"><span class="pre">true</span></tt> and <tt class="docutils literal"><span class="pre">false</span></tt>. These are actually just integers
in Pure, but sometimes it's convenient to refer to them using these
symbolic constants. Note that if you also want to use these on the
left-hand side of equations, you still have to declare them as
<tt class="docutils literal"><span class="pre">nullary</span></tt> symbols yourself, using a declaration like: <tt class="docutils literal"><span class="pre">nullary</span> <span class="pre">false</span>
<span class="pre">true;</span></tt></li>
</ul>
<a name="operators"><p id="operators">Here's the list of predefined operator symbols. Note that the parser will
automagically give unary minus the same precedence level as the
corresponding binary operator. Also note that the &quot;mapsto&quot; operator
a.k.a. &quot;hash rocket&quot; <tt class="docutils literal"><span class="pre">=&gt;</span></tt> doesn't have a predefined meaning in Pure; the
prelude only implements the relations <tt class="docutils literal"><span class="pre">==</span></tt> and <tt class="docutils literal"><span class="pre">~=</span></tt> to check such &quot;hash
pairs&quot; <tt class="docutils literal"><span class="pre">x=&gt;y</span></tt> for equality and inequality. The hash rocket is used in
several libraries, however, which usually employ it to denote some kind of
key-value associations. See, e.g., <a class="reference" href="#dictionaries">Dictionaries</a> for an example.</p>
<pre class="literal-block">
infixl  0   $$ ;                // sequence operator
infixr  0   $ ;                 // right-associative application
infixr  1   , ;                 // pair (tuple)
infix   2   .. ;                // arithmetic sequences
infix   2   =&gt; ;                // mapsto constructor
infixr  2   || ;                // logical or (short-circuit)
infixr  3   &amp;&amp; ;                // logical and (short-circuit)
prefix  3   ~ ;                 // logical negation
infix   4   &lt; &gt; &lt;= &gt;= == ~= ;   // relations
infix   4   === ~== ;           // syntactic equality
infixr  4   : ;                 // list cons
infix   5   +: &lt;: ;             // complex numbers (cf. math.pure)
infixl  5   &lt;&lt; &gt;&gt; ;             // bit shifts
infixl  6   + - or ;            // addition, bitwise or
infixl  7   * / div mod and ;   // multiplication, bitwise and
infixl  7   % ;                 // exact division (cf. math.pure)
prefix  7   not ;               // bitwise not
postfix 7   ' ;                 // matrix transposition
infixr  8   ^ ;                 // exponentiation
prefix  8   # ;                 // size operator
infixl  9   ! !! ;              // indexing, slicing
infixr  9   . ;                 // function composition
postfix 9   &amp; ;                 // thunk
</pre>
<!--  -->
<div class="section">
<h2><a class="toc-backref" href="#id49" id="basic-combinators" name="basic-combinators">1.1&nbsp;&nbsp;&nbsp;Basic Combinators</a></h2>
<a name="combinators"><a name="$"><a name="."><p id="id2"><span id="id1"></span><span id="combinators"></span>The most important function combinators are <tt class="docutils literal"><span class="pre">$</span></tt> (right-associative
application) and <tt class="docutils literal"><span class="pre">.</span></tt> (function composition), which are also defined as
macros so that saturated calls of these are eliminated automatically.
Examples:</p>
<pre class="literal-block">
&gt; foo $ bar 99;
foo (bar 99)
&gt; (foo.bar) 99;
foo (bar 99)
</pre>
<a name="id"><a name="cst"><p id="cst"><span id="id"></span>The customary identity and constant combinators from the combinatorial
calculus are also available, in Pure these are named <tt class="docutils literal"><span class="pre">id</span></tt> and <tt class="docutils literal"><span class="pre">cst</span></tt>,
respectively:</p>
<pre class="literal-block">
&gt; map id (1..5);
[1,2,3,4,5]
&gt; map (cst 0) (1..5);
[0,0,0,0,0]
</pre>
<a name="void"><p id="void">There's also a combinator <tt class="docutils literal"><span class="pre">void</span></tt> which is basically equivalent to <tt class="docutils literal"><span class="pre">cst</span>
<span class="pre">()</span></tt>, but with the special twist that it is also defined as a macro
optimizing the case of &quot;throwaway&quot; list and matrix comprehensions. This is
useful if a comprehension is evaluated solely for its side effects. E.g.:</p>
<pre class="literal-block">
&gt; using system;
&gt; extern int rand();
&gt; foo = void [printf &quot;%d\n&quot; rand | _ = 1..3];
&gt; show foo
foo = do (\_ -&gt; printf &quot;%d\n&quot; rand) (1..3);
&gt; foo;
1714636915
1957747793
424238335
()
</pre>
<p>Note that the above list comprehension is actually implemented using <a class="reference" href="#do">do</a>
(instead of <a class="reference" href="#map">map</a>, which would normally be the case), so that the
intermediate list value of the comprehension is never constructed. This is
described in more detail in section <a class="reference" href="pure.html#optimization-rules">Optimization Rules</a> of the Pure
Manual.</p>
<!--  -->
<p>In addition, Pure also provides the following combinators adopted from
Haskell:</p>
<a name="flip"><ul id="flip">
<li><p class="first"><tt class="docutils literal"><span class="pre">flip</span> <span class="pre">f</span></tt> swaps arguments of a binary function <tt class="docutils literal"><span class="pre">f</span></tt>, e.g.:</p>
<pre class="literal-block">
&gt; map (flip (/) 2) (1..3);
[0.5,1.0,1.5]
</pre>
<p>This idiom is used much more frequently in Pure than in Haskell because
Pure doesn't have Haskell's operator sections. Note, however, that the
same effect can also be achieved with a lambda:</p>
<pre class="literal-block">
&gt; map (\x -&gt; x/2) (1..3);
[0.5,1.0,1.5]
</pre>
</li>
</ul>
<a name="curry"><ul id="curry">
<li><p class="first"><tt class="docutils literal"><span class="pre">curry</span> <span class="pre">f</span></tt> turns a function <tt class="docutils literal"><span class="pre">f</span></tt> expecting a pair of values into a
curried function of two arguments:</p>
<pre class="literal-block">
&gt; using system;
&gt; dowith (curry (printf &quot;%d: %g\n&quot;)) (0..2) [0.0,2.718,3.14];
0: 0
1: 2.718
2: 3.14
()
</pre>
</li>
</ul>
<a name="uncurry"><ul id="uncurry">
<li><p class="first">Conversely, <tt class="docutils literal"><span class="pre">uncurry</span> <span class="pre">f</span></tt> turns a curried function <tt class="docutils literal"><span class="pre">f</span></tt> expecting two
arguments into a function processing a single pair argument:</p>
<pre class="literal-block">
&gt; map (uncurry (*)) [(2,3),(4,5),(6,7)];
[6,20,42]
</pre>
</li>
</ul>
<a name="curry3"><a name="uncurry3"><ul class="simple" id="uncurry3">
<span id="curry3"></span><li><tt class="docutils literal"><span class="pre">curry3</span></tt> and <tt class="docutils literal"><span class="pre">uncurry3</span></tt> work analogously, but are used to work with
ternary functions.</li>
</ul>
<a name="fix"><ul id="fix">
<li><p class="first">The (normal order) fixed point combinator <tt class="docutils literal"><span class="pre">fix</span></tt> allows you to create
recursive anonymous functions. It takes another function <tt class="docutils literal"><span class="pre">f</span></tt> as its
argument and applies <tt class="docutils literal"><span class="pre">f</span></tt> to <tt class="docutils literal"><span class="pre">fix</span> <span class="pre">f</span></tt> itself:</p>
<pre class="literal-block">
&gt; let fact = fix (\f n -&gt; if n&lt;=0 then 1 else n*f (n-1));
&gt; map fact (1..5);
[1,2,6,24,120]
</pre>
</li>
</ul>
<blockquote>
<p>See <a class="reference" href="http://en.wikipedia.org/wiki/Fixed_point_combinator">Fixed point combinator</a> for an explanation of how this magic
works. Just like in Haskell, <tt class="docutils literal"><span class="pre">fix</span></tt> can be used to produce least fixed
points of arbitrary functions. For instance:</p>
<pre class="literal-block">
&gt; fix (cst bar);
bar
&gt; let xs = fix (\x -&gt; 1:x);
&gt; xs;
1:#&lt;thunk 0x7fe537fe2f90&gt;
&gt; xs!!(0..10);
[1,1,1,1,1,1,1,1,1,1,1]
</pre>
</blockquote>
<!--  -->
</div>
<div class="section">
<h2><a class="toc-backref" href="#id50" id="quasiquote" name="quasiquote">1.2&nbsp;&nbsp;&nbsp;Quasiquote</a></h2>
<p>The prelude also defines a general Lisp-like <tt class="docutils literal"><span class="pre">quasiquote</span></tt> macro which is
used to construct quoted expressions by unquoting and splicing subterms
indicated with the <tt class="docutils literal"><span class="pre">unquote</span></tt> and <tt class="docutils literal"><span class="pre">splice</span></tt> constructors. For instance:</p>
<pre class="literal-block">
&gt; quasiquote (2*42+unquote (2^12));
2*42+4096.0
&gt; quasiquote (foo 1 2 (splice [2/3,3/4]) (5/6));
foo 1 2 (2/3) (3/4) (5/6)
</pre>
<p>Lisp weenies might want to add some syntactic sugar for convenience. This
isn't in the prelude, so you'll have to define it yourself. Also note that
we cannot have <tt class="docutils literal"><span class="pre">,</span></tt> for unquoting, so we use <tt class="docutils literal"><span class="pre">,,</span></tt> instead:</p>
<pre class="literal-block">
prefix 9 ` ,, ,&#64; ;
def â€˜x = quasiquote x; def ,,x = unquote x; def ,&#64;x = splice x;
</pre>
<p>Examples:</p>
<pre class="literal-block">
&gt; `(2*42+2^12);
2*42+2^12
&gt; `(2*42+,,(2^12));
2*42+4096.0
&gt; `foo 1 2 (,&#64;[2/3,3/4]) (5/6);
foo 1 2 (2/3) (3/4) (5/6)
&gt; `foo 1 2 (,&#64;args) (5/6) when args = quote [2/3,3/4] end;
foo 1 2 (2/3) (3/4) (5/6)
</pre>
<p>This is discussed in more detail in section <a class="reference" href="pure.html#recursive-macros">Recursive Macros</a> of the Pure
Manual.</p>
<!--  -->
</div>
<div class="section">
<h2><a class="toc-backref" href="#id51" id="lists-and-tuples" name="lists-and-tuples">1.3&nbsp;&nbsp;&nbsp;Lists and Tuples</a></h2>
<a name="lists"><a name="tuples"><a name="list size"><a name="tuple size"><a name="null"><a name="reverse"><a name="#"><a name="\:"><a name=","><p id="id5"><span id="id4"></span><span id="id3"></span><span id="reverse"></span><span id="null"></span><span id="tuple-size"></span><span id="list-size"></span><span id="tuples"></span><span id="lists"></span>The prelude defines the list and tuple constructors (<tt class="docutils literal"><span class="pre">x:y</span></tt>, <tt class="docutils literal"><span class="pre">x,y</span></tt>), as
well as equality (<tt class="docutils literal"><span class="pre">==</span></tt>) and inequality (<tt class="docutils literal"><span class="pre">~=</span></tt>) on these structures. It
also provides the predicate <tt class="docutils literal"><span class="pre">null</span> <span class="pre">x</span></tt> which tests whether <tt class="docutils literal"><span class="pre">x</span></tt> is the
empty list or tuple, the function <tt class="docutils literal"><span class="pre">reverse</span> <span class="pre">x</span></tt> which reverses a list or
tuple, and the operators <tt class="docutils literal"><span class="pre">#x</span></tt> (size of a list or tuple), <tt class="docutils literal"><span class="pre">x!i</span></tt>
(indexing), <tt class="docutils literal"><span class="pre">x!!is</span></tt> (slicing) and <tt class="docutils literal"><span class="pre">x+y</span></tt> (list concatenation).</p>
<p>Note that list and tuple equality use the equality of their members to
decide equality of lists and tuples, so <tt class="docutils literal"><span class="pre">==</span></tt> must be defined on the list
or tuple members.</p>
<p>Also note that there isn't a separate operation for concatenating tuples,
since the pairing operator already does this:</p>
<pre class="literal-block">
&gt; (1,2,3),(10,9,8);
1,2,3,10,9,8
</pre>
<p>This works because the <tt class="docutils literal"><span class="pre">(,)</span></tt> constructor is associative in Pure and will
always produce right-recursive pairs. This also implies that tuples are
always flat in Pure and can't be nested; if you need this, you should use
lists instead. Also note that the empty tuple <tt class="docutils literal"><span class="pre">()</span></tt> acts as a neutral
element with respect to <tt class="docutils literal"><span class="pre">(,)</span></tt>:</p>
<pre class="literal-block">
&gt; (),(a,b,c);
a,b,c
&gt; (a,b,c),();
a,b,c
</pre>
<a name="list concatenation"><a name="+ (list)"><p id="list"><span id="list-concatenation"></span>Lists are the usual right-recursive aggregates, pretty much the same as in
Lisp or Prolog except that they use a Haskell-like syntax. In difference to
Haskell, list concatenation is denoted <tt class="docutils literal"><span class="pre">+</span></tt>, and lists may contain an
arbitrary mixture of arguments, i.e., they are fully polymorphic:</p>
<pre class="literal-block">
&gt; 1:2:3:[];
[1,2,3]
&gt; [1,2,3]+[u,v,w]+[3.14];
[1,2,3,u,v,w,3.14]
</pre>
<p>Lists are <strong>eager</strong> in Pure by default, but they can also be made <strong>lazy</strong>, see
section <a class="reference" href="pure.html#lazy-evaluation-and-streams">Lazy Evaluation and Streams</a> in the Pure Manual.</p>
<a name="arithmetic sequences"><a name=".."><p id="id6"><span id="arithmetic-sequences"></span>Arithmetic sequences can be constructed with the infix <tt class="docutils literal"><span class="pre">..</span></tt> operator:</p>
<pre class="literal-block">
&gt; 1..5;
[1,2,3,4,5]
&gt; 1:3..11;
[1,3,5,7,9,11]
</pre>
<p>Note that the Pure syntax differs slightly from Haskell in that a step
width is indicated by specifying the first two elements as <tt class="docutils literal"><span class="pre">x:y</span></tt> instead
of <tt class="docutils literal"><span class="pre">x,y</span></tt>. Also, to specify infinite sequences you have to use an infinite
upper bound (<tt class="docutils literal"><span class="pre">inf</span></tt> or <tt class="docutils literal"><span class="pre">-inf</span></tt>):</p>
<pre class="literal-block">
&gt; 1:3..inf;
1:#&lt;thunk 0x7f696cd2dbd8&gt;
&gt; -1:-3..-inf;
-1:#&lt;thunk 0x7f696cd2fde8&gt;
</pre>
<a name="list"><a name="tuple"><p id="tuple"><span id="id7"></span>You can convert between (finite) lists and tuples using the <tt class="docutils literal"><span class="pre">list</span></tt> and
<tt class="docutils literal"><span class="pre">tuple</span></tt> operations:</p>
<pre class="literal-block">
&gt; tuple (1..5);
1,2,3,4,5
&gt; list (a,b,c);
[a,b,c]
</pre>
<p>The <tt class="docutils literal"><span class="pre">list</span></tt> function can also be used to turn a finite lazy list into an
eager one:</p>
<pre class="literal-block">
&gt; list $ take 10 (-1:-3..-inf);
[-1,-3,-5,-7,-9,-11,-13,-15,-17,-19]
</pre>
<p>You can also achieve the same effect somewhat more conveniently by slicing
a finite part from a stream (see below):</p>
<pre class="literal-block">
&gt; (-1:-3..-inf)!!(0..9);
[-1,-3,-5,-7,-9,-11,-13,-15,-17,-19]
</pre>
<a name="stream"><p id="stream">Conversely, it is also possible to convert a list to a stream:</p>
<pre class="literal-block">
&gt; stream (1..10);
1:#&lt;thunk 0x7fe537fe2b58&gt;
</pre>
<p>This might appear a bit useless at first sight, since all elements of the
stream are in fact already known. However, this operation then allows you
to apply other functions to the list and have them evaluated in a lazy
fashion.</p>
<a name="list indexing"><a name="tuple indexing"><a name="!"><p id="id8"><span id="tuple-indexing"></span><span id="list-indexing"></span>Indexing of lists and tuples is always zero-based (i.e., indices run from
<tt class="docutils literal"><span class="pre">0</span></tt> to <tt class="docutils literal"><span class="pre">#x-1</span></tt>), and an exception will be raised if the index is out of
bounds:</p>
<pre class="literal-block">
&gt; [1,2,3]!2;
3
&gt; [1,2,3]!4;
&lt;stdin&gt;, line 34: unhandled exception 'out_of_bounds' while evaluating
'[1,2,3]!4'
</pre>
<a name="list slicing"><a name="tuple slicing"><a name="!!"><p id="id9"><span id="tuple-slicing"></span><span id="list-slicing"></span>The slicing operator <tt class="docutils literal"><span class="pre">!!</span></tt> takes a list or tuple and a list of indices and
returns the list or tuple of the corresponding elements, respectively.
Indices which are out of the valid range are silently ignored:</p>
<pre class="literal-block">
&gt; (1..5)!!(3..10);
[4,5]
&gt; (1,2,3,4,5)!!(3..10);
4,5
</pre>
<p>Indices can actually be specified in any order, so that you can retrieve
any permutation of the members, also with duplicates. E.g.:</p>
<pre class="literal-block">
&gt; (1..5)!![2,4,4,1];
[3,5,5,2]
</pre>
<p>This is less efficient than the case of contiguous index ranges (which is
optimized so that it always works in linear time), because it requires
repeated traversals of the list for each index. For larger lists you should
hence use vectors or matrices instead, to avoid the quadratic complexity.</p>
<p>(The prelude actually implements the slicing operation in a fairly generic
way, so that it works with any kind of container data structure which
defines <tt class="docutils literal"><span class="pre">!</span></tt> in such a manner that it throws an exception when the index
is out of bounds. It also works with any kind of index container that
implements the <a class="reference" href="#catmap">catmap</a> operation.)</p>
<!--  -->
</div>
<div class="section">
<h2><a class="toc-backref" href="#id52" id="list-functions" name="list-functions">1.4&nbsp;&nbsp;&nbsp;List Functions</a></h2>
<p>This mostly comes straight from the Q prelude which in turn was based on
the first edition of the Bird/Wadler book, and is very similar to what you
can find in the Haskell prelude. Some functions have slightly different
names, though, and of course everything is typed dynamically.</p>
<div class="section">
<h3><a class="toc-backref" href="#id53" id="common-list-functions" name="common-list-functions">1.4.1&nbsp;&nbsp;&nbsp;Common List Functions</a></h3>
<a name="any"><dl class="docutils" id="any">
<dt><tt class="docutils literal"><span class="pre">any</span> <span class="pre">p</span> <span class="pre">xs</span></tt></dt>
<dd>tests whether the predicate <tt class="docutils literal"><span class="pre">p</span></tt> holds for any of the members of <tt class="docutils literal"><span class="pre">xs</span></tt></dd>
</dl>
<a name="all"><dl class="docutils" id="all">
<dt><tt class="docutils literal"><span class="pre">all</span> <span class="pre">p</span> <span class="pre">xs</span></tt></dt>
<dd>tests whether the predicate <tt class="docutils literal"><span class="pre">p</span></tt> holds for all of the members of <tt class="docutils literal"><span class="pre">xs</span></tt></dd>
</dl>
<a name="cat"><dl class="docutils" id="cat">
<dt><tt class="docutils literal"><span class="pre">cat</span> <span class="pre">xs</span></tt></dt>
<dd>concatenate a list of lists</dd>
</dl>
<a name="catmap"><dl class="docutils" id="catmap">
<dt><tt class="docutils literal"><span class="pre">catmap</span> <span class="pre">f</span> <span class="pre">xs</span></tt></dt>
<dd>convenience function which combines <a class="reference" href="#cat">cat</a> and <a class="reference" href="#map">map</a>; this is also used
to implement list comprehensions</dd>
</dl>
<a name="do"><dl class="docutils" id="do">
<dt><tt class="docutils literal"><span class="pre">do</span> <span class="pre">f</span> <span class="pre">xs</span></tt></dt>
<dd>apply <tt class="docutils literal"><span class="pre">f</span></tt> to all members of <tt class="docutils literal"><span class="pre">xs</span></tt>, like <a class="reference" href="#map">map</a>, but throw away all
intermediate results and return <tt class="docutils literal"><span class="pre">()</span></tt></dd>
</dl>
<a name="drop"><dl class="docutils" id="drop">
<dt><tt class="docutils literal"><span class="pre">drop</span> <span class="pre">n</span> <span class="pre">xs</span></tt></dt>
<dd>remove <tt class="docutils literal"><span class="pre">n</span></tt> elements from the front of <tt class="docutils literal"><span class="pre">xs</span></tt></dd>
</dl>
<a name="dropwhile"><dl class="docutils" id="dropwhile">
<dt><tt class="docutils literal"><span class="pre">dropwhile</span> <span class="pre">p</span> <span class="pre">xs</span></tt></dt>
<dd>remove elements from the front of <tt class="docutils literal"><span class="pre">xs</span></tt> while the predicate <tt class="docutils literal"><span class="pre">p</span></tt> is
satisfied</dd>
</dl>
<a name="filter"><dl class="docutils" id="filter">
<dt><tt class="docutils literal"><span class="pre">filter</span> <span class="pre">p</span> <span class="pre">xs</span></tt></dt>
<dd>return the list of all members of <tt class="docutils literal"><span class="pre">xs</span></tt> satisfying the predicate <tt class="docutils literal"><span class="pre">p</span></tt></dd>
</dl>
<a name="foldl"><dl class="docutils" id="foldl">
<dt><tt class="docutils literal"><span class="pre">foldl</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">xs</span></tt></dt>
<dd>accumulate the binary function <tt class="docutils literal"><span class="pre">f</span></tt> over all members of <tt class="docutils literal"><span class="pre">xs</span></tt>,
starting from the initial value <tt class="docutils literal"><span class="pre">a</span></tt> and working from the front of the
list towards its end</dd>
</dl>
<a name="foldl1"><dl class="docutils" id="foldl1">
<dt><tt class="docutils literal"><span class="pre">foldl1</span> <span class="pre">f</span> <span class="pre">xs</span></tt></dt>
<dd>accumulate the binary function <tt class="docutils literal"><span class="pre">f</span></tt> over all members of <tt class="docutils literal"><span class="pre">xs</span></tt>,
starting from the value <tt class="docutils literal"><span class="pre">head</span> <span class="pre">xs</span></tt> and working from the front of the
list towards its end; <tt class="docutils literal"><span class="pre">xs</span></tt> must be nonempty</dd>
</dl>
<a name="foldr"><dl class="docutils" id="foldr">
<dt><tt class="docutils literal"><span class="pre">foldr</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">xs</span></tt></dt>
<dd>accumulate the binary function <tt class="docutils literal"><span class="pre">f</span></tt> over all members of <tt class="docutils literal"><span class="pre">xs</span></tt>,
starting from the initial value <tt class="docutils literal"><span class="pre">a</span></tt> and working from the end of the
list towards its front</dd>
</dl>
<a name="foldr1"><dl class="docutils" id="foldr1">
<dt><tt class="docutils literal"><span class="pre">foldr1</span> <span class="pre">f</span> <span class="pre">xs</span></tt></dt>
<dd>accumulate the binary function <tt class="docutils literal"><span class="pre">f</span></tt> over all members of <tt class="docutils literal"><span class="pre">xs</span></tt>,
starting from the value <tt class="docutils literal"><span class="pre">last</span> <span class="pre">xs</span></tt> and working from the end of the
list towards its front; <tt class="docutils literal"><span class="pre">xs</span></tt> must be nonempty</dd>
</dl>
<a name="head"><dl class="docutils" id="head">
<dt><tt class="docutils literal"><span class="pre">head</span> <span class="pre">xs</span></tt></dt>
<dd>return the first element of <tt class="docutils literal"><span class="pre">xs</span></tt>; <tt class="docutils literal"><span class="pre">xs</span></tt> must be nonempty</dd>
</dl>
<a name="index"><dl class="docutils" id="index">
<dt><tt class="docutils literal"><span class="pre">index</span> <span class="pre">xs</span> <span class="pre">x</span></tt></dt>
<dd><p class="first">search for an occurrence of <tt class="docutils literal"><span class="pre">x</span></tt> in <tt class="docutils literal"><span class="pre">xs</span></tt> and return the index of the
first occurrence, if any, <tt class="docutils literal"><span class="pre">-1</span></tt> otherwise</p>
<p class="last">Note: This uses equality (<tt class="docutils literal"><span class="pre">==</span></tt>) to decide whether a member of <tt class="docutils literal"><span class="pre">xs</span></tt> is
an occurrence of <tt class="docutils literal"><span class="pre">x</span></tt>, so <tt class="docutils literal"><span class="pre">==</span></tt> must have an appropriate definition on
the list members.</p>
</dd>
</dl>
<a name="init"><dl class="docutils" id="init">
<dt><tt class="docutils literal"><span class="pre">init</span> <span class="pre">xs</span></tt></dt>
<dd>return all but the last element of <tt class="docutils literal"><span class="pre">xs</span></tt>; <tt class="docutils literal"><span class="pre">xs</span></tt> must be nonempty</dd>
</dl>
<a name="last"><dl class="docutils" id="last">
<dt><tt class="docutils literal"><span class="pre">last</span> <span class="pre">xs</span></tt></dt>
<dd>return the last element of <tt class="docutils literal"><span class="pre">xs</span></tt>; <tt class="docutils literal"><span class="pre">xs</span></tt> must be nonempty</dd>
</dl>
<a name="listmap"><dl class="docutils" id="listmap">
<dt><tt class="docutils literal"><span class="pre">listmap</span> <span class="pre">f</span> <span class="pre">xs</span></tt></dt>
<dd>convenience function which works like <a class="reference" href="#map">map</a>, but also deals with matrix
and string arguments while ensuring that the result is always a list;
this is primarily used to implement list comprehensions</dd>
</dl>
<a name="map"><dl class="docutils" id="map">
<dt><tt class="docutils literal"><span class="pre">map</span> <span class="pre">f</span> <span class="pre">xs</span></tt></dt>
<dd>apply <tt class="docutils literal"><span class="pre">f</span></tt> to each member of <tt class="docutils literal"><span class="pre">xs</span></tt></dd>
</dl>
<a name="scanl"><dl class="docutils" id="scanl">
<dt><tt class="docutils literal"><span class="pre">scanl</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">xs</span></tt></dt>
<dd>accumulate the binary function <tt class="docutils literal"><span class="pre">f</span></tt> over all members of <tt class="docutils literal"><span class="pre">xs</span></tt>,
as with <tt class="docutils literal"><span class="pre">foldl</span></tt>, but return all intermediate results as a list</dd>
</dl>
<a name="scanl1"><dl class="docutils" id="scanl1">
<dt><tt class="docutils literal"><span class="pre">scanl1</span> <span class="pre">f</span> <span class="pre">xs</span></tt></dt>
<dd>accumulate the binary function <tt class="docutils literal"><span class="pre">f</span></tt> over all members of <tt class="docutils literal"><span class="pre">xs</span></tt>,
as with <tt class="docutils literal"><span class="pre">foldl1</span></tt>, but return all intermediate results as a list</dd>
</dl>
<a name="scanr"><dl class="docutils" id="scanr">
<dt><tt class="docutils literal"><span class="pre">scanr</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">xs</span></tt></dt>
<dd>accumulate the binary function <tt class="docutils literal"><span class="pre">f</span></tt> over all members of <tt class="docutils literal"><span class="pre">xs</span></tt>,
as with <tt class="docutils literal"><span class="pre">foldr</span></tt>, but return all intermediate results as a list</dd>
</dl>
<a name="scanr1"><dl class="docutils" id="scanr1">
<dt><tt class="docutils literal"><span class="pre">scanr1</span> <span class="pre">f</span> <span class="pre">xs</span></tt></dt>
<dd>accumulate the binary function <tt class="docutils literal"><span class="pre">f</span></tt> over all members of <tt class="docutils literal"><span class="pre">xs</span></tt>,
as with <tt class="docutils literal"><span class="pre">foldr1</span></tt>, but return all intermediate results as a list</dd>
</dl>
<a name="tail"><dl class="docutils" id="tail">
<dt><tt class="docutils literal"><span class="pre">tail</span> <span class="pre">xs</span></tt></dt>
<dd>return all but the first element of <tt class="docutils literal"><span class="pre">xs</span></tt>; <tt class="docutils literal"><span class="pre">xs</span></tt> must be nonempty</dd>
</dl>
<a name="take"><dl class="docutils" id="take">
<dt><tt class="docutils literal"><span class="pre">take</span> <span class="pre">n</span> <span class="pre">xs</span></tt></dt>
<dd>take <tt class="docutils literal"><span class="pre">n</span></tt> elements from the front of <tt class="docutils literal"><span class="pre">xs</span></tt></dd>
</dl>
<a name="takewhile"><dl class="docutils" id="takewhile">
<dt><tt class="docutils literal"><span class="pre">takewhile</span> <span class="pre">p</span> <span class="pre">xs</span></tt></dt>
<dd>take elements from the front of <tt class="docutils literal"><span class="pre">xs</span></tt> while the predicate <tt class="docutils literal"><span class="pre">p</span></tt> is
satisfied</dd>
</dl>
<!--  -->
</div>
<div class="section">
<h3><a class="toc-backref" href="#id54" id="list-generators" name="list-generators">1.4.2&nbsp;&nbsp;&nbsp;List Generators</a></h3>
<a name="cycle"><dl class="docutils" id="cycle">
<dt><tt class="docutils literal"><span class="pre">cycle</span> <span class="pre">xs</span></tt></dt>
<dd>cycles through the elements of the nonempty list <tt class="docutils literal"><span class="pre">xs</span></tt>, ad infinitum</dd>
</dl>
<a name="cyclen"><dl class="docutils" id="cyclen">
<dt><tt class="docutils literal"><span class="pre">cyclen</span> <span class="pre">n</span> <span class="pre">xs</span></tt></dt>
<dd>eager version of <tt class="docutils literal"><span class="pre">cycle</span></tt>, returns the first <tt class="docutils literal"><span class="pre">n</span></tt> elements of
<tt class="docutils literal"><span class="pre">cycle</span> <span class="pre">xs</span></tt></dd>
</dl>
<a name="iterate"><dl class="docutils" id="iterate">
<dt><tt class="docutils literal"><span class="pre">iterate</span> <span class="pre">f</span> <span class="pre">x</span></tt></dt>
<dd>returns the stream containing <tt class="docutils literal"><span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">f</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">f</span> <span class="pre">(f</span> <span class="pre">x)</span></tt>, etc.,
ad infinitum</dd>
</dl>
<a name="repeat"><dl class="docutils" id="repeat">
<dt><tt class="docutils literal"><span class="pre">repeat</span> <span class="pre">x</span></tt></dt>
<dd>returns an infinite stream of <tt class="docutils literal"><span class="pre">x</span></tt>s</dd>
</dl>
<a name="repeatn"><dl class="docutils" id="repeatn">
<dt><tt class="docutils literal"><span class="pre">repeatn</span> <span class="pre">n</span> <span class="pre">x</span></tt></dt>
<dd>eager version of <tt class="docutils literal"><span class="pre">repeat</span></tt>, returns a list with <tt class="docutils literal"><span class="pre">n</span></tt> <tt class="docutils literal"><span class="pre">x</span></tt>s</dd>
</dl>
<a name="while"><dl class="docutils" id="while">
<dt><tt class="docutils literal"><span class="pre">while</span> <span class="pre">p</span> <span class="pre">f</span> <span class="pre">x</span></tt></dt>
<dd>eager version of <tt class="docutils literal"><span class="pre">iterate</span></tt>, returns the list of all elements from
the front of <tt class="docutils literal"><span class="pre">iterate</span> <span class="pre">f</span> <span class="pre">xs</span></tt> for which the predicate <tt class="docutils literal"><span class="pre">p</span></tt> holds</dd>
</dl>
<!--  -->
</div>
<div class="section">
<h3><a class="toc-backref" href="#id55" id="zip-and-friends" name="zip-and-friends">1.4.3&nbsp;&nbsp;&nbsp;Zip and Friends</a></h3>
<a name="unzip"><dl class="docutils" id="unzip">
<dt><tt class="docutils literal"><span class="pre">unzip</span> <span class="pre">xys</span></tt></dt>
<dd>takes a list of pairs to a pair of lists of corresponding elements</dd>
</dl>
<a name="unzip3"><dl class="docutils" id="unzip3">
<dt><tt class="docutils literal"><span class="pre">unzip3</span> <span class="pre">xyzs</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">unzip</span></tt> with triples</dd>
</dl>
<a name="zip"><dl class="docutils" id="zip">
<dt><tt class="docutils literal"><span class="pre">zip</span> <span class="pre">xs</span> <span class="pre">ys</span></tt></dt>
<dd>return the list of corresponding pairs <tt class="docutils literal"><span class="pre">(x,y)</span></tt> where <tt class="docutils literal"><span class="pre">x</span></tt> runs
through the elements of <tt class="docutils literal"><span class="pre">xs</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> runs through the elements
of <tt class="docutils literal"><span class="pre">y</span></tt></dd>
</dl>
<a name="zip3"><dl class="docutils" id="zip3">
<dt><tt class="docutils literal"><span class="pre">zip3</span> <span class="pre">xs</span> <span class="pre">ys</span> <span class="pre">zs</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">zip</span></tt> with three lists, returns a list of triples</dd>
</dl>
<a name="zipwith"><dl class="docutils" id="zipwith">
<dt><tt class="docutils literal"><span class="pre">zipwith</span> <span class="pre">f</span> <span class="pre">xs</span> <span class="pre">ys</span></tt></dt>
<dd>apply the binary function <tt class="docutils literal"><span class="pre">f</span></tt> to corresponding elements of <tt class="docutils literal"><span class="pre">xs</span></tt>
and <tt class="docutils literal"><span class="pre">ys</span></tt></dd>
</dl>
<a name="zipwith3"><dl class="docutils" id="zipwith3">
<dt><tt class="docutils literal"><span class="pre">zipwith3</span> <span class="pre">f</span> <span class="pre">xs</span> <span class="pre">ys</span> <span class="pre">zs</span></tt></dt>
<dd>apply the ternary function <tt class="docutils literal"><span class="pre">f</span></tt> to corresponding elements of <tt class="docutils literal"><span class="pre">xs</span></tt>,
<tt class="docutils literal"><span class="pre">ys</span></tt> and <tt class="docutils literal"><span class="pre">zs</span></tt></dd>
</dl>
<p>Pure also has the following variations of <tt class="docutils literal"><span class="pre">zipwith</span></tt>/<tt class="docutils literal"><span class="pre">zipwith3</span></tt> which
throw away all intermediate results and return <tt class="docutils literal"><span class="pre">()</span></tt>. That is, these work
like <a class="reference" href="#do">do</a> but pull arguments from two or three lists, respectively:</p>
<a name="dowith"><dl class="docutils" id="dowith">
<dt><tt class="docutils literal"><span class="pre">dowith</span> <span class="pre">f</span> <span class="pre">xs</span> <span class="pre">ys</span></tt></dt>
<dd>apply the binary function <tt class="docutils literal"><span class="pre">f</span></tt> to corresponding elements of <tt class="docutils literal"><span class="pre">xs</span></tt>
and <tt class="docutils literal"><span class="pre">ys</span></tt>, return <tt class="docutils literal"><span class="pre">()</span></tt></dd>
</dl>
<a name="dowith3"><dl class="docutils" id="dowith3">
<dt><tt class="docutils literal"><span class="pre">dowith3</span> <span class="pre">f</span> <span class="pre">xs</span> <span class="pre">ys</span> <span class="pre">zs</span></tt></dt>
<dd>apply the ternary function <tt class="docutils literal"><span class="pre">f</span></tt> to corresponding elements of <tt class="docutils literal"><span class="pre">xs</span></tt>,
<tt class="docutils literal"><span class="pre">ys</span></tt> and <tt class="docutils literal"><span class="pre">zs</span></tt>, return <tt class="docutils literal"><span class="pre">()</span></tt></dd>
</dl>
<!--  -->
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id56" id="string-functions" name="string-functions">1.5&nbsp;&nbsp;&nbsp;String Functions</a></h2>
<a name="strings"><p id="strings">Pure strings are null-terminated character strings encoded in UTF-8, see
the <a class="reference" href="pure.html">Pure Manual</a> for details. The prelude provides various operations on
strings, including a complete set of list-like operations, so that strings
can be used mostly as if they were lists, although they are really
implemented as C character arrays for reasons of efficiency.</p>
<div class="section">
<h3><a class="toc-backref" href="#id57" id="basic-string-functions" name="basic-string-functions">1.5.1&nbsp;&nbsp;&nbsp;Basic String Functions</a></h3>
<a name="string concatenation"><a name="string indexing"><a name="string slicing"><a name="+ (string)"><a name="! (string)"><a name="!! (string)"><p id="id11"><span id="id10"></span><span id="string"></span><span id="string-slicing"></span><span id="string-indexing"></span><span id="string-concatenation"></span>Concatenation, indexing and slicing works just like with lists:</p>
<pre class="literal-block">
&gt; &quot;abc&quot;+&quot;xyz&quot;;
&quot;abcxyz&quot;
&gt; let s = &quot;The quick brown fox jumps over the lazy dog.&quot;;
&gt; s!5;
&quot;u&quot;
&gt; s!!(20..24);
&quot;jumps&quot;
</pre>
<a name="string size"><a name="null (string)"><a name="# (string)"><p id="id12"><span id="null-string"></span><span id="string-size"></span>Checking for empty strings and determining the size of a string also works
as expected:</p>
<pre class="literal-block">
&gt; null &quot;&quot;;
1
&gt; null s;
0
&gt; #s;
44
</pre>
<p>You can search for the location of a substring in a string, and extract a
substring of a given length:</p>
<a name="index (string)"><dl class="docutils" id="index-string">
<dt><tt class="docutils literal"><span class="pre">index</span> <span class="pre">s</span> <span class="pre">u</span></tt></dt>
<dd>Returns the (zero-based) index of the first occurrence of the substring
<tt class="docutils literal"><span class="pre">u</span></tt> in <tt class="docutils literal"><span class="pre">s</span></tt>, or -1 if <tt class="docutils literal"><span class="pre">u</span></tt> is not found in <tt class="docutils literal"><span class="pre">s</span></tt>.</dd>
</dl>
<a name="substr"><dl class="docutils" id="substr">
<dt><tt class="docutils literal"><span class="pre">substr</span> <span class="pre">s</span> <span class="pre">i</span> <span class="pre">n</span></tt></dt>
<dd>Extracts a substring of (at most) <tt class="docutils literal"><span class="pre">n</span></tt> characters at position <tt class="docutils literal"><span class="pre">i</span></tt> in
<tt class="docutils literal"><span class="pre">s</span></tt>. This takes care of all corner cases, adjusting index and number of
characters so that the index range stays confined to the source string.</dd>
</dl>
<p>Example:</p>
<pre class="literal-block">
&gt; index s &quot;jumps&quot;;
20
&gt; substr s 20 10;
&quot;jumps over&quot;
</pre>
<p>Note that Pure doesn't have a separate type for individual characters.
Instead, these are represented as strings <tt class="docutils literal"><span class="pre">c</span></tt> containing exactly one
(UTF-8) character (i.e., <tt class="docutils literal"><span class="pre">#c==1</span></tt>). It is possible to convert such single
character strings to the corresponding integer character codes, and vice
versa:</p>
<a name="ord"><dl class="docutils" id="ord">
<dt><tt class="docutils literal"><span class="pre">ord</span> <span class="pre">c</span></tt></dt>
<dd>Ordinal number of a single character string <tt class="docutils literal"><span class="pre">c</span></tt>. This is the
character's code point in the Unicode character set.</dd>
</dl>
<a name="chr"><dl class="docutils" id="chr">
<dt><tt class="docutils literal"><span class="pre">chr</span> <span class="pre">n</span></tt></dt>
<dd>Converts an integer back to the character with the corresponding code
point.</dd>
</dl>
<a name="character arithmetic"><p id="character-arithmetic">In addition, the usual character arithmetic works, including arithmetic
sequences of characters, so that you can write stuff like the following:</p>
<pre class="literal-block">
&gt; &quot;a&quot;-&quot;A&quot;;
32
&gt; &quot;u&quot;-32;
&quot;U&quot;
&gt; &quot;a&quot;..&quot;k&quot;;
[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;i&quot;,&quot;j&quot;,&quot;k&quot;]
</pre>
<p>Strings are also ordered lexicographically based on their character codes:</p>
<pre class="literal-block">
&gt; &quot;awe&quot;&gt;&quot;awesome&quot;;
0
&gt; &quot;foo&quot;&gt;=&quot;bar&quot;;
1
</pre>
<p>For convenience, the prelude provides the following functions to convert
between strings and lists (or other aggregates) of characters.</p>
<a name="chars"><a name="list (string)"><dl class="docutils" id="list-string">
<span id="chars"></span><dt><tt class="docutils literal"><span class="pre">chars</span> <span class="pre">s</span></tt>, <tt class="docutils literal"><span class="pre">list</span> <span class="pre">s</span></tt></dt>
<dd>Convert a string <tt class="docutils literal"><span class="pre">s</span></tt> to a list of characters.</dd>
</dl>
<a name="tuple (string)"><a name="matrix (string)"><dl class="docutils" id="matrix-string">
<span id="tuple-string"></span><dt><tt class="docutils literal"><span class="pre">tuple</span> <span class="pre">s</span></tt>, <tt class="docutils literal"><span class="pre">matrix</span> <span class="pre">s</span></tt></dt>
<dd>Convert a string <tt class="docutils literal"><span class="pre">s</span></tt> to a tuple or (symbolic) matrix of characters,
respectively.</dd>
</dl>
<a name="strcat"><dl class="docutils" id="strcat">
<dt><tt class="docutils literal"><span class="pre">strcat</span> <span class="pre">xs</span></tt></dt>
<dd>Concatenate a list <tt class="docutils literal"><span class="pre">xs</span></tt> of strings (in particular, this converts a
list of characters back to a string).</dd>
</dl>
<a name="string"><dl class="docutils" id="id13">
<dt><tt class="docutils literal"><span class="pre">string</span> <span class="pre">xs</span></tt></dt>
<dd>Convert a list, tuple or (symbolic) matrix of strings to a string.
In the case of a list, this is synonymous with <a class="reference" href="#strcat">strcat</a>, but it also
works with the other types of aggregates.</dd>
</dl>
<p>For instance:</p>
<pre class="literal-block">
&gt; list &quot;abc&quot;;
[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
&gt; string (&quot;a&quot;..&quot;z&quot;);
&quot;abcdefghijklmnopqrstuvwxyz&quot;
</pre>
<p>The following functions are provided to deal with strings of &quot;tokens&quot;
separated by a given delimiter string.</p>
<a name="split"><dl class="docutils" id="split">
<dt><tt class="docutils literal"><span class="pre">split</span> <span class="pre">delim</span> <span class="pre">s</span></tt></dt>
<dd>Splits <tt class="docutils literal"><span class="pre">s</span></tt> into a list of substrings delimited by <tt class="docutils literal"><span class="pre">delim</span></tt>.</dd>
</dl>
<a name="join"><dl class="docutils" id="join">
<dt><tt class="docutils literal"><span class="pre">join</span> <span class="pre">delim</span> <span class="pre">xs</span></tt></dt>
<dd>Joins the list of strings <tt class="docutils literal"><span class="pre">xs</span></tt> to a single string, interpolating the
given <tt class="docutils literal"><span class="pre">delim</span></tt> string.</dd>
</dl>
<p>Example:</p>
<pre class="literal-block">
&gt; let xs = split &quot; &quot; s; xs;
[&quot;The&quot;,&quot;quick&quot;,&quot;brown&quot;,&quot;fox&quot;,&quot;jumps&quot;,&quot;over&quot;,&quot;the&quot;,&quot;lazy&quot;,&quot;dog.&quot;]
&gt; join &quot;:&quot; xs;
&quot;The:quick:brown:fox:jumps:over:the:lazy:dog.&quot;
</pre>
<p>We mention in passing here that more elaborate string matching, splitting
and replacement operations based on regular expressions are provided by the
system module, see <a class="reference" href="#system-interface">System Interface</a>.</p>
<p>If that isn't enough already, most generic list operations carry over to
strings in the obvious way, treating the string like a list of
characters. For instance:</p>
<pre class="literal-block">
&gt; filter (\x-&gt;x&gt;=&quot;k&quot;) s;
&quot;qukrownoxumpsovrtlzyo&quot;
&gt; map pred [&quot;i&quot;,&quot;b&quot;,&quot;m&quot;];
[&quot;h&quot;,&quot;a&quot;,&quot;l&quot;]
</pre>
<p>This also provides for list comprehensions drawing values from strings:</p>
<pre class="literal-block">
&gt; string [x+1 | x=&quot;HAL&quot;];
&quot;IBM&quot;
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id58" id="eval-and-friends" name="eval-and-friends">1.5.2&nbsp;&nbsp;&nbsp;Eval and Friends</a></h3>
<p>Pure provides some rather powerful operations to convert between Pure
expressions and their string representation. This is useful for
metaprogramming purposes. It also provides a convenient means to serialize
Pure expressions, e.g., when they are transferred from/to persistant
storage or transmitted over a socket. (Note, however, that this has its
limitations. Specifically, some objects like pointers and local or
anonymous functions do not have a parseable string representation.)</p>
<a name="str"><dl class="docutils" id="str">
<dt><tt class="docutils literal"><span class="pre">str</span> <span class="pre">x</span></tt></dt>
<dd>Yields the print representation of an expression in Pure syntax, as a
string.</dd>
</dl>
<a name="eval"><dl class="docutils" id="eval">
<dt><tt class="docutils literal"><span class="pre">eval</span> <span class="pre">x</span></tt></dt>
<dd><p class="first">Parses an expression, specified as a string in Pure syntax, and returns
its value. In fact, <tt class="docutils literal"><span class="pre">eval</span></tt> can also parse and execute arbitrary Pure
code. In that case it will return the last computed expression, if any.</p>
<p class="last">Alternatively, <tt class="docutils literal"><span class="pre">eval</span></tt> can also be invoked on a (quoted) Pure
expression, which is recompiled and then evaluated. (If the expression
cannot be compiled for some reason then <tt class="docutils literal"><span class="pre">eval</span></tt> just returns it as
is. Also, exceptions during evaluation are reported back to the
caller.)</p>
</dd>
</dl>
<a name="evalcmd"><dl class="docutils" id="evalcmd">
<dt><tt class="docutils literal"><span class="pre">evalcmd</span> <span class="pre">x</span></tt></dt>
<dd>Like <a class="reference" href="#eval">eval</a>, but allows execution of interactive commands and returns
their captured output as a string. No other results are returned, so this
operation is most useful for executing Pure definitions and interactive
commands for their side-effects. (At this time, only the regular output
of a few commands can be captured, most notably <tt class="docutils literal"><span class="pre">clear</span></tt>, <tt class="docutils literal"><span class="pre">save</span></tt> and
<tt class="docutils literal"><span class="pre">show</span></tt>; otherwise the result string will be empty.)</dd>
</dl>
<a name="lasterr"><dl class="docutils" id="lasterr">
<dt><tt class="docutils literal"><span class="pre">lasterr</span></tt></dt>
<dd>Reports errors in <a class="reference" href="#eval">eval</a> and <a class="reference" href="#evalcmd">evalcmd</a>. This string value will be nonempty
iff a compilation or execution error was encountered during the most
recent invokation of <tt class="docutils literal"><span class="pre">eval</span></tt> and <tt class="docutils literal"><span class="pre">evalcmd</span></tt>. In that case each reported
error message is terminated with a newline character.</dd>
</dl>
<p>Examples:</p>
<pre class="literal-block">
&gt; str (1/3);
&quot;0.333333333333333&quot;
&gt; eval &quot;1/3&quot;;
0.333333333333333
&gt; eval (quote (1/3));
0.333333333333333
&gt; evalcmd &quot;show evalcmd&quot;;
&quot;extern expr* evalcmd(expr*);\n&quot;
&gt; eval &quot;1/3)&quot;;
eval &quot;1/3)&quot;
&gt; lasterr;
&quot;&lt;stdin&gt;, line 1: syntax error, unexpected ')', expecting '=' or '|'\n&quot;
</pre>
<!--  -->
</div>
<div class="section">
<h3><a class="toc-backref" href="#id59" id="low-level-operations" name="low-level-operations">1.5.3&nbsp;&nbsp;&nbsp;Low-Level Operations</a></h3>
<p>The following routines are provided by the runtime to turn raw C <tt class="docutils literal"><span class="pre">char*</span></tt>
pointers (also called <strong>byte strings</strong> in Pure parlance, to distinguish them
from Pure's &quot;cooked&quot; UTF-8 string values) into corresponding Pure
strings. Normally you don't have to worry about this, because the C
interface already takes care of the necessary marshalling, but in some
low-level code these operations are useful. Also note that here and in the
following, the <tt class="docutils literal"><span class="pre">cstring</span></tt> routines also convert the string between the
system encoding and Pure's internal UTF-8 representation.</p>
<a name="string (pointer)"><a name="cstring"><dl class="docutils" id="cstring">
<span id="string-pointer"></span><dt><tt class="docutils literal"><span class="pre">string</span> <span class="pre">s</span></tt>, <tt class="docutils literal"><span class="pre">cstring</span> <span class="pre">s</span></tt></dt>
<dd>Convert a pointer <tt class="docutils literal"><span class="pre">s</span></tt> to a Pure string. <tt class="docutils literal"><span class="pre">s</span></tt> must point to a
null-terminated C string. These routines take ownership of the original
string value, assuming it to be <tt class="docutils literal"><span class="pre">malloc</span></tt>ed, so you should only use
these for C strings which are specifically intended to be freed by the
user.</dd>
</dl>
<a name="string_dup"><a name="cstring_dup"><dl class="docutils" id="cstring-dup">
<span id="string-dup"></span><dt><tt class="docutils literal"><span class="pre">string_dup</span> <span class="pre">s</span></tt>, <tt class="docutils literal"><span class="pre">cstring_dup</span> <span class="pre">s</span></tt></dt>
<dd>Convert a pointer <tt class="docutils literal"><span class="pre">s</span></tt> to a Pure string. Like above, but these functions
take a copy of the string, leaving the original C string untouched.</dd>
</dl>
<!--  -->
<p>The reverse transformations are also provided. These take a Pure string to
a byte string (raw <tt class="docutils literal"><span class="pre">char*</span></tt>).</p>
<a name="byte_string"><a name="byte_cstring"><dl class="docutils" id="byte-cstring">
<span id="byte-string"></span><dt><tt class="docutils literal"><span class="pre">byte_string</span> <span class="pre">s</span></tt>, <tt class="docutils literal"><span class="pre">byte_cstring</span> <span class="pre">s</span></tt></dt>
<dd>Construct a byte string from a Pure string <tt class="docutils literal"><span class="pre">s</span></tt>. The result is a raw
pointer object pointing to the converted string. The original Pure string
is always copied (and, in the case of <tt class="docutils literal"><span class="pre">byte_cstring</span></tt>, converted to the
system encoding). The resulting byte string is a <tt class="docutils literal"><span class="pre">malloc</span></tt>ed pointer
which can be used like a C <tt class="docutils literal"><span class="pre">char*</span></tt>, and has to be freed explicitly by
the caller when no longer needed.</dd>
</dl>
<!--  -->
<p>Finally, it is also possible to convert Pure string lists to byte string
vectors and vice versa. These are useful if you need to pass an
<tt class="docutils literal"><span class="pre">argv</span></tt>-like string vector (i.e., a <tt class="docutils literal"><span class="pre">char**</span></tt> or <tt class="docutils literal"><span class="pre">char*[]</span></tt>) to C
routines. The computed C vectors are <tt class="docutils literal"><span class="pre">malloc</span></tt>ed pointers which have an
extra <tt class="docutils literal"><span class="pre">NULL</span></tt> pointer as the last entry, and should thus be usable for
almost any purpose which requires such a string vector in C. They also take
care of garbage-collecting themselves. The original string data is always
copied. As usual, the <tt class="docutils literal"><span class="pre">cstring</span></tt> variants do automatic conversions to the
system encoding.</p>
<a name="byte_string_pointer"><a name="byte_cstring_pointer"><dl class="docutils" id="byte-cstring-pointer">
<span id="byte-string-pointer"></span><dt><tt class="docutils literal"><span class="pre">byte_string_pointer</span> <span class="pre">xs</span></tt>, <tt class="docutils literal"><span class="pre">byte_cstring_pointer</span> <span class="pre">xs</span></tt></dt>
<dd>Convert a list of Pure strings to a C <tt class="docutils literal"><span class="pre">char**</span></tt>.</dd>
</dl>
<a name="string_list"><a name="cstring_list"><dl class="docutils" id="cstring-list">
<span id="string-list"></span><dt><tt class="docutils literal"><span class="pre">string_list</span> <span class="pre">n</span> <span class="pre">p</span></tt>, <tt class="docutils literal"><span class="pre">cstring_list</span> <span class="pre">n</span> <span class="pre">p</span></tt></dt>
<dd>Convert a C <tt class="docutils literal"><span class="pre">char**</span></tt> to a list of Pure strings.</dd>
</dl>
<p>Note that the back conversions take an additional first argument which
denotes the number of strings to retrieve. If you know that the vector is
<tt class="docutils literal"><span class="pre">NULL</span></tt>-terminated then this can also be an infinite value (<tt class="docutils literal"><span class="pre">inf</span></tt>) in
which case the number of elements will be figured out automatically.
Processing always stops at the first <tt class="docutils literal"><span class="pre">NULL</span></tt> pointer encountered.</p>
<!--  -->
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id60" id="matrix-functions" name="matrix-functions">1.6&nbsp;&nbsp;&nbsp;Matrix Functions</a></h2>
<p>Most of the generic list operations are implemented on matrices as well,
see <a class="reference" href="#common-list-functions">Common List Functions</a>. Hence stuff like <tt class="docutils literal"><span class="pre">map</span></tt> and <tt class="docutils literal"><span class="pre">zipwith</span></tt>
works as expected:</p>
<pre class="literal-block">
&gt; map succ {1,2,3;4,5,6};
{2,3,4;5,6,7}
&gt; zipwith (+) {1,2,3;4,5,6} {1,0,1;0,2,0};
{2,2,4;4,7,6}
</pre>
<p>The matrix module also provides all the necessary operations for matrix
comprehensions, and to make matrices work in list comprehensions and vice
versa. You can find some examples of these in the <a class="reference" href="pure.html#matrix-computations">Matrix Computations</a>
section of the Pure Manual.</p>
<p>The predicates <tt class="docutils literal"><span class="pre">==</span></tt> and <tt class="docutils literal"><span class="pre">~=</span></tt> are defined, which allow you to check two
matrices for equality.</p>
<a name="matrix size"><a name="matrix dimensions"><a name="# (matrix)"><a name="dim"><p id="dim"><span id="matrix"></span><span id="matrix-dimensions"></span><span id="matrix-size"></span>The size of a matrix (number of elements) can be obtained using <tt class="docutils literal"><span class="pre">#</span></tt>, and
the <tt class="docutils literal"><span class="pre">dim</span></tt> function can be used to return its dimensions (number of rows
and columns):</p>
<pre class="literal-block">
&gt; #{1,2,3;4,5,6};
6
&gt; dim {1,2,3;4,5,6};
2,3
</pre>
<a name="null (matrix)"><p id="null-matrix"><tt class="docutils literal"><span class="pre">null</span> <span class="pre">x</span></tt> can be used to check for empty matrices. Note that there are
various kinds of these, as a matrix may have zero rows or columns, or both.</p>
<a name="matrix transposition"><a name="'"><p id="id14"><span id="matrix-transposition"></span>A matrix can be transposed with the <tt class="docutils literal"><span class="pre">'</span></tt> operator:</p>
<pre class="literal-block">
&gt; {1,2,3;4,5,6}';
{1,4;2,5;3,6}
</pre>
<p>Indexing and slicing works pretty much like in MATLAB and Octave, except
that you use the Pure operators <tt class="docutils literal"><span class="pre">!</span></tt> and <tt class="docutils literal"><span class="pre">!!</span></tt> for that. It is possible
to access elements with a one-dimensional index (in row-major oder):</p>
<pre class="literal-block">
&gt; x!3;
4
</pre>
<p>Or you can specify a pair of row and column index:</p>
<pre class="literal-block">
&gt; x!(1,0);
4
</pre>
<p>Slicing works accordingly. You can either specify a list of (one- or
two-dimensional) indices, in which case the result is always a row vector:</p>
<pre class="literal-block">
&gt; x!!(2..5);
{3,4,5,6}
</pre>
<p>Or you can specify a pair of row and column index lists:</p>
<pre class="literal-block">
&gt; x!!(0..1,1..2);
{2,3;5,6}
</pre>
<p>The following abbreviations are provided to grab a slice from a row or
column:</p>
<pre class="literal-block">
&gt; x!!(1,1..2);
{5,6}
&gt; x!!(0..1,1);
{2;5}
</pre>
<p>The matrix module also implements a bunch of other specialized matrix
operations. The most important operations are briefly summarized below;
please refer to matrix.pure for all the gory details.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">dmatrixp</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">cmatrixp</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">imatrixp</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">smatrixp</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">nmatrixp</span> <span class="pre">x</span></tt></dt>
<dd>Check for different kinds of matrices (double, complex, int, symbolic and
numeric, i.e., non-symbolic).</dd>
<dt><tt class="docutils literal"><span class="pre">vectorp</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">rowvectorp</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">colvectorp</span> <span class="pre">x</span></tt></dt>
<dd>Check for different kinds of vectors (these are just matrices with one
row or column).</dd>
</dl>
<a name="stride"><dl class="docutils" id="stride">
<dt><tt class="docutils literal"><span class="pre">stride</span> <span class="pre">x</span></tt></dt>
<dd>The stride of a matrix denotes the real row size of the underlying C
array, see the description of the <a class="reference" href="#pack">pack</a> function below for further
details. There's little use for this value in Pure, but it may be needed
when interfacing to C.</dd>
</dl>
<a name="row"><a name="col"><dl class="docutils" id="col">
<span id="row"></span><dt><tt class="docutils literal"><span class="pre">row</span> <span class="pre">x</span> <span class="pre">i</span></tt>, <tt class="docutils literal"><span class="pre">col</span> <span class="pre">x</span> <span class="pre">i</span></tt></dt>
<dd>Extract the <tt class="docutils literal"><span class="pre">i</span></tt>th row or column of a matrix.</dd>
</dl>
<a name="rows"><a name="cols"><dl class="docutils" id="cols">
<span id="rows"></span><dt><tt class="docutils literal"><span class="pre">rows</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">cols</span> <span class="pre">x</span></tt></dt>
<dd>Return the list of all rows or columns of a matrix.</dd>
</dl>
<a name="list (matrix)"><a name="list2 (matrix)"><a name="tuple (matrix)"><a name="matrix"><dl class="docutils" id="id15">
<span id="tuple-matrix"></span><span id="list2-matrix"></span><span id="list-matrix"></span><dt><tt class="docutils literal"><span class="pre">list</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">list2</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">tuple</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">matrix</span> <span class="pre">xs</span></tt></dt>
<dd><p class="first">Convert a matrix to a list or tuple, and vice versa. <tt class="docutils literal"><span class="pre">list</span> <span class="pre">x</span></tt> converts
a matrix <tt class="docutils literal"><span class="pre">x</span></tt> to a flat list of its elements, while <tt class="docutils literal"><span class="pre">list2</span></tt> converts
it to a list of lists. Likewise, <tt class="docutils literal"><span class="pre">tuple</span> <span class="pre">x</span></tt> converts the matrix <tt class="docutils literal"><span class="pre">x</span></tt> to
a tuple. Conversely, <tt class="docutils literal"><span class="pre">matrix</span> <span class="pre">xs</span></tt> converts a list or tuple to a
corresponding matrix.</p>
<p class="last">Note that <tt class="docutils literal"><span class="pre">matrix</span></tt> turns a list of lists or matrices specifying the
rows of the matrix to the corresponding rectangular matrix; otherwise,
the result is a row vector. Also note that the matrix function may throw
a <tt class="docutils literal"><span class="pre">bad_matrix_value</span> <span class="pre">x</span></tt> in case of dimension mismatch, where <tt class="docutils literal"><span class="pre">x</span></tt>
denotes the offending submatrix.</p>
</dd>
</dl>
<a name="diag"><a name="subdiag"><a name="supdiag"><dl class="docutils" id="supdiag">
<span id="subdiag"></span><span id="diag"></span><dt><tt class="docutils literal"><span class="pre">diag</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">subdiag</span> <span class="pre">x</span> <span class="pre">k</span></tt>, <tt class="docutils literal"><span class="pre">supdiag</span> <span class="pre">x</span> <span class="pre">k</span></tt>:</dt>
<dd>Extract (sub-,super-) diagonals from a matrix. Sub- and super-diagonals
for <tt class="docutils literal"><span class="pre">k=0</span></tt> return the main diagonal. Indices for sub- and
super-diagonals can also be negative, in which case the corresponding
super- or sub-diagonal is returned instead. In each case the result is a
row vector.</dd>
</dl>
<a name="submat"><dl class="docutils" id="submat">
<dt><tt class="docutils literal"><span class="pre">submat</span> <span class="pre">x</span> <span class="pre">(i,j)</span> <span class="pre">(n,m)</span></tt></dt>
<dd>Extract a submatrix of a given size at a given offset. The result shares
the underlying storage with the input matrix (i.e., matrix elements are
<em>not</em> copied) and so this is a comparatively cheap operation.</dd>
</dl>
<a name="rowcat"><a name="colcat"><dl class="docutils" id="colcat">
<span id="rowcat"></span><dt><tt class="docutils literal"><span class="pre">rowcat</span> <span class="pre">xs</span></tt>, <tt class="docutils literal"><span class="pre">colcat</span> <span class="pre">xs</span></tt></dt>
<dd>Construct matrices from lists of rows and columns. These take either
scalars or submatrices as inputs; corresponding dimensions must match.
<tt class="docutils literal"><span class="pre">rowcat</span></tt> combines submatrices vertically, like <tt class="docutils literal"><span class="pre">{x;y}</span></tt>; <tt class="docutils literal"><span class="pre">colcat</span></tt>
combines them horizontally, like <tt class="docutils literal"><span class="pre">{x,y}</span></tt>. Note: Like the built-in
matrix constructs, these operations may throw a <tt class="docutils literal"><span class="pre">bad_matrix_value</span> <span class="pre">x</span></tt>
exception in case of dimension mismatch, where <tt class="docutils literal"><span class="pre">x</span></tt> denotes the
offending submatrix.</dd>
</dl>
<a name="matcat"><dl class="docutils" id="matcat">
<dt><tt class="docutils literal"><span class="pre">matcat</span> <span class="pre">xs</span></tt></dt>
<dd>Construct a matrix from a (symbolic) matrix of other matrices and/or
scalars. This works like a combination of <tt class="docutils literal"><span class="pre">rowcat</span></tt> and colcat, but
draws its input from a matrix instead of a list of matrices, and
preserves the overall layout of the &quot;host&quot; matrix. The net effect is that
the host matrix is flattened out. If all elements of the input matrix are
scalars already, the input matrix is returned unchanged.</dd>
</dl>
<a name="rowcatmap"><a name="colcatmap"><dl class="docutils" id="colcatmap">
<span id="rowcatmap"></span><dt><tt class="docutils literal"><span class="pre">rowcatmap</span> <span class="pre">f</span> <span class="pre">xs</span></tt>, <tt class="docutils literal"><span class="pre">colcatmap</span> <span class="pre">f</span> <span class="pre">xs</span></tt></dt>
<dd>Combinations of <a class="reference" href="#rowcat">rowcat</a>, <a class="reference" href="#colcat">colcat</a> and <a class="reference" href="#map">map</a>. These are used, in particular,
for implementing matrix comprehensions.</dd>
</dl>
<!--  -->
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">dmatrix</span> <span class="pre">(n,m)</span></tt>, <tt class="docutils literal"><span class="pre">cmatrix</span> <span class="pre">(n,m)</span></tt>, <tt class="docutils literal"><span class="pre">imatrix</span> <span class="pre">(n,m)</span></tt></dt>
<dd>Convenience functions to create zero matrices with the given dimensions
(either a pair denoting the number of rows and columns, or just the row
size in order to create a row vector).</dd>
</dl>
<a name="diagmat"><a name="subdiagmat"><a name="supdiagmat"><dl class="docutils" id="supdiagmat">
<span id="subdiagmat"></span><span id="diagmat"></span><dt><tt class="docutils literal"><span class="pre">diagmat</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">subdiagmat</span> <span class="pre">x</span> <span class="pre">k</span></tt>, <tt class="docutils literal"><span class="pre">supdiagmat</span> <span class="pre">x</span> <span class="pre">k</span></tt></dt>
<dd>Create a (sub-,super-) diagonal matrix from a row vector <tt class="docutils literal"><span class="pre">x</span></tt> of size
<tt class="docutils literal"><span class="pre">n</span></tt>. The result is always a square matrix with dimension <tt class="docutils literal"><span class="pre">(n+k,n+k)</span></tt>,
which is of the same matrix type (double, complex, int, symbolic) as the
input and has the elements of the vector on its <tt class="docutils literal"><span class="pre">k</span></tt>th sub- or
super-diagonal, with all other elements zero. A negative value for <tt class="docutils literal"><span class="pre">k</span></tt>
turns a sub- into a super-diagonal matrix and vice versa.</dd>
</dl>
<a name="dmatrix"><a name="cmatrix"><a name="imatrix"><a name="smatrix"><dl class="docutils" id="smatrix">
<span id="imatrix"></span><span id="cmatrix"></span><span id="dmatrix"></span><dt><tt class="docutils literal"><span class="pre">dmatrix</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">cmatrix</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">imatrix</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">smatrix</span> <span class="pre">x</span></tt></dt>
<dd>Matrix conversions. These convert between different types of numeric and
symbolic matrices. The same operations also convert a list directly to a
row vector; this is usually much faster than the generic <a class="reference" href="#id15">matrix</a>
operation, but requires that the elements already are of the appropriate
type.</dd>
</dl>
<a name="re (matrix)"><a name="im (matrix)"><a name="conj (matrix)"><dl class="docutils" id="conj-matrix">
<span id="im-matrix"></span><span id="re-matrix"></span><dt><tt class="docutils literal"><span class="pre">re</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">im</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">conj</span> <span class="pre">x</span></tt></dt>
<dd>Extract the real and imaginary parts and compute the conjugate of a
numeric matrix.</dd>
</dl>
<a name="pack"><a name="packed"><dl class="docutils" id="packed">
<span id="pack"></span><dt><tt class="docutils literal"><span class="pre">pack</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">packed</span> <span class="pre">x</span></tt></dt>
<dd><p class="first">Pack a matrix. This creates a copy of the matrix which has the data in
contiguous storage. It also frees up extra memory if the matrix was
created as a slice from a bigger matrix (see <a class="reference" href="#submat">submat</a> above) which has
since gone the way of the dodo.</p>
<p class="last">The <tt class="docutils literal"><span class="pre">packed</span></tt> predicate can be used to verify whether a matrix is
already packed. Note that even if a matrix is already packed, <tt class="docutils literal"><span class="pre">pack</span></tt>
will make a copy of it anyway, so this routine also provides a quick way
to copy a matrix, e.g., if you want to pass it as an input/output
parameter to a GSL routine.</p>
</dd>
</dl>
<a name="redim"><dl class="docutils" id="redim">
<dt><tt class="docutils literal"><span class="pre">redim</span> <span class="pre">(n,m)</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">redim</span> <span class="pre">n</span> <span class="pre">x</span></tt></dt>
<dd><p class="first">Change the dimensions of a matrix without changing its size. The total
number of elements must match that of the input matrix. Reuses the
underlying storage of the input matrix if possible (i.e., if the matrix
is <a class="reference" href="#packed">packed</a>).</p>
<p class="last">You can also redim a matrix to a given row size <tt class="docutils literal"><span class="pre">n</span></tt>. In this case the
row size must divide the total size of the matrix.</p>
</dd>
</dl>
<a name="rowvector"><a name="colvector"><dl class="docutils" id="colvector">
<span id="rowvector"></span><dt><tt class="docutils literal"><span class="pre">rowvector</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">colvector</span> <span class="pre">x</span></tt></dt>
<dd>Convenience functions to convert a matrix to a row or column vector.</dd>
</dl>
<a name="rowrev"><a name="colrev"><a name="reverse (matrix)"><dl class="docutils" id="reverse-matrix">
<span id="colrev"></span><span id="rowrev"></span><dt><tt class="docutils literal"><span class="pre">rowrev</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">colrev</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">reverse</span> <span class="pre">x</span></tt></dt>
<dd>Reverse a matrix. <tt class="docutils literal"><span class="pre">rowrev</span></tt> reverses the rows, <tt class="docutils literal"><span class="pre">colrev</span></tt> the columns,
<tt class="docutils literal"><span class="pre">reverse</span></tt> both dimensions.</dd>
</dl>
<!--  -->
</div>
<div class="section">
<h2><a class="toc-backref" href="#id61" id="primitives" name="primitives">1.7&nbsp;&nbsp;&nbsp;Primitives</a></h2>
<p>This prelude module is a collection of various lowlevel operations, which
are implemented either directly by machine instructions or by C functions
provided in the runtime. In particular, this module defines the basic
arithmetic operations on machine integers, bigints and floating point
numbers, as well as various type checking predicates and conversions
between different types. Some low-level pointer operations are also
provided, as well as &quot;sentries&quot; (Pure's flavour of object finalizers) and
&quot;references&quot; (mutable expression pointers).</p>
<div class="section">
<h3><a class="toc-backref" href="#id62" id="arithmetic" name="arithmetic">1.7.1&nbsp;&nbsp;&nbsp;Arithmetic</a></h3>
<p>The arithmetic operations <tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">*</span></tt>, <tt class="docutils literal"><span class="pre">div</span></tt>, <tt class="docutils literal"><span class="pre">mod</span></tt> etc. all do what
you expect, see the <a class="reference" href="#operators">operators</a> table at the beginning of this section for a
complete list of these. The primitives module also defines pointer
arithmetic in the usual way.</p>
<p>The constants <tt class="docutils literal"><span class="pre">inf</span></tt> and <tt class="docutils literal"><span class="pre">nan</span></tt> are defined as the usual IEEE floating
point infinities and NaNs, and the predicates <tt class="docutils literal"><span class="pre">infp</span></tt> and <tt class="docutils literal"><span class="pre">nanp</span></tt> are
provided to check for these kinds of values.</p>
<p>In addition, the following arithmetic and numeric functions are provided:</p>
<a name="abs"><a name="sgn"><dl class="docutils" id="sgn">
<span id="abs"></span><dt><tt class="docutils literal"><span class="pre">abs</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">sgn</span> <span class="pre">x</span></tt></dt>
<dd>Absolute value and sign of a number.</dd>
</dl>
<a name="min"><a name="max"><dl class="docutils" id="max">
<span id="min"></span><dt><tt class="docutils literal"><span class="pre">min</span> <span class="pre">x</span> <span class="pre">y</span></tt>, <tt class="docutils literal"><span class="pre">max</span> <span class="pre">x</span> <span class="pre">y</span></tt></dt>
<dd>Minimum and maximum of two values. This works with any kind of values
which have the ordering relations defined on them.</dd>
</dl>
<a name="succ"><a name="pred"><dl class="docutils" id="pred">
<span id="succ"></span><dt><tt class="docutils literal"><span class="pre">succ</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">pred</span> <span class="pre">x</span></tt></dt>
<dd>Successor (<tt class="docutils literal"><span class="pre">+1</span></tt>) and predecessor (<tt class="docutils literal"><span class="pre">-1</span></tt>) functions.</dd>
</dl>
<a name="gcd"><a name="lcd"><dl class="docutils" id="lcd">
<span id="gcd"></span><dt><tt class="docutils literal"><span class="pre">gcd</span> <span class="pre">x</span> <span class="pre">y</span></tt>, <tt class="docutils literal"><span class="pre">lcd</span> <span class="pre">x</span> <span class="pre">y</span></tt></dt>
<dd>The greatest common divisor and least common multiple functions from the
GMP library. These return a bigint if at least one of the arguments is a
bigint, a machine int otherwise.</dd>
</dl>
<a name="pow"><dl class="docutils" id="pow">
<dt><tt class="docutils literal"><span class="pre">pow</span> <span class="pre">x</span> <span class="pre">y</span></tt></dt>
<dd>Computes exact powers of ints and bigints. The result is always a
bigint. Note that <tt class="docutils literal"><span class="pre">y</span></tt> must always be nonnegative here, but see the math
module (<a class="reference" href="#mathematical-functions">Mathematical Functions</a>) which deals with the case <tt class="docutils literal"><span class="pre">y&lt;0</span></tt>
using rational numbers.</dd>
</dl>
<a name="^"><dl class="docutils" id="id16">
<dt><tt class="docutils literal"><span class="pre">x^y</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">^</span></tt> operator. Computes inexact powers for any combination of int,
bigint and double operands. The result is always a double.</dd>
</dl>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id63" id="conversions" name="conversions">1.7.2&nbsp;&nbsp;&nbsp;Conversions</a></h3>
<a name="hash"><dl class="docutils" id="hash">
<dt><tt class="docutils literal"><span class="pre">hash</span> <span class="pre">x</span></tt></dt>
<dd>Compute a 32 bit hash code of a Pure expression.</dd>
</dl>
<a name="int"><a name="bigint"><a name="double"><a name="pointer"><dl class="docutils" id="pointer">
<span id="double"></span><span id="bigint"></span><span id="int"></span><dt><tt class="docutils literal"><span class="pre">int</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">bigint</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">double</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">pointer</span> <span class="pre">x</span></tt></dt>
<dd>Conversions between the different numeric and pointer types.</dd>
</dl>
<a name="ubyte"><a name="ushort"><a name="uint"><a name="ulong"><dl class="docutils" id="ulong">
<span id="uint"></span><span id="ushort"></span><span id="ubyte"></span><dt><tt class="docutils literal"><span class="pre">ubyte</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">ushort</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">uint</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">ulong</span> <span class="pre">x</span></tt></dt>
<dd>Convert signed (8/16/32/64) bit integers to the corresponding unsigned
quantities. These functions behave as if the value was &quot;cast&quot; to the
corresponding unsigned C type, and are most useful for dealing with
unsigned integers returned by external C routines. The routines always
use the smallest Pure int type capable of holding the result: <tt class="docutils literal"><span class="pre">int</span></tt> for
<tt class="docutils literal"><span class="pre">ubyte</span></tt> and <tt class="docutils literal"><span class="pre">ushort</span></tt>, <tt class="docutils literal"><span class="pre">bigint</span></tt> for <tt class="docutils literal"><span class="pre">uint</span></tt> and <tt class="docutils literal"><span class="pre">ulong</span></tt>. (Note
that in the case of 64 bit values the C interface returns a bigint,
that's why <tt class="docutils literal"><span class="pre">ulong</span></tt> takes a bigint parameter. The other routines all
take an int as input.)</dd>
</dl>
<p>The following rounding functions work with all kinds of numbers:</p>
<a name="floor"><a name="ceil"><dl class="docutils" id="ceil">
<span id="floor"></span><dt><tt class="docutils literal"><span class="pre">floor</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">ceil</span> <span class="pre">x</span></tt></dt>
<dd>Floor and ceil.</dd>
</dl>
<a name="round"><a name="trunc"><dl class="docutils" id="trunc">
<span id="round"></span><dt><tt class="docutils literal"><span class="pre">round</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">trunc</span> <span class="pre">x</span></tt></dt>
<dd>Round or truncate to an integer.</dd>
</dl>
<a name="frac"><dl class="docutils" id="frac">
<dt><tt class="docutils literal"><span class="pre">frac</span> <span class="pre">x</span></tt></dt>
<dd>Fractional part (<tt class="docutils literal"><span class="pre">x-trunc</span> <span class="pre">x</span></tt>).</dd>
</dl>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id64" id="predicates" name="predicates">1.7.3&nbsp;&nbsp;&nbsp;Predicates</a></h3>
<a name="same"><a name="==="><a name="~=="><dl class="docutils" id="id18">
<span id="id17"></span><span id="same"></span><dt><tt class="docutils literal"><span class="pre">x===y</span></tt>, <tt class="docutils literal"><span class="pre">x~==y</span></tt>, <tt class="docutils literal"><span class="pre">same</span> <span class="pre">x</span> <span class="pre">y</span></tt></dt>
<dd>Syntactic equality.</dd>
</dl>
<a name="intp"><a name="bigintp"><a name="doublep"><a name="stringp"><a name="pointerp"><a name="matrixp"><dl class="docutils" id="matrixp">
<span id="pointerp"></span><span id="stringp"></span><span id="doublep"></span><span id="bigintp"></span><span id="intp"></span><dt><tt class="docutils literal"><span class="pre">intp</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">bigintp</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">doublep</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">stringp</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">pointerp</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">matrixp</span> <span class="pre">x</span></tt></dt>
<dd>Predicates to check for the built-in types.</dd>
</dl>
<a name="charp"><dl class="docutils" id="charp">
<dt><tt class="docutils literal"><span class="pre">charp</span> <span class="pre">x</span></tt></dt>
<dd>Single character string predicate.</dd>
</dl>
<a name="numberp"><a name="complexp"><a name="realp"><a name="rationalp"><a name="integerp"><dl class="docutils" id="integerp">
<span id="rationalp"></span><span id="realp"></span><span id="complexp"></span><span id="numberp"></span><dt><tt class="docutils literal"><span class="pre">numberp</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">complexp</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">realp</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">rationalp</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">integerp</span> <span class="pre">x</span></tt></dt>
<dd>Additional number predicates.</dd>
</dl>
<a name="exactp"><a name="inexactp"><dl class="docutils" id="inexactp">
<span id="exactp"></span><dt><tt class="docutils literal"><span class="pre">exactp</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">inexactp</span> <span class="pre">x</span></tt></dt>
<dd>Check whether a number is exact (i.e., doesn't contain any double
components).</dd>
</dl>
<a name="applp"><a name="listp"><a name="listnp"><a name="tuplep"><dl class="docutils" id="tuplep">
<span id="listnp"></span><span id="listp"></span><span id="applp"></span><dt><tt class="docutils literal"><span class="pre">applp</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">listp</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">listnp</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">tuplep</span> <span class="pre">x</span></tt></dt>
<dd>Predicates to check for function applications, proper lists, list nodes
and proper tuples.</dd>
</dl>
<a name="funp"><a name="lambdap"><a name="thunkp"><a name="varp"><dl class="docutils" id="varp">
<span id="thunkp"></span><span id="lambdap"></span><span id="funp"></span><dt><tt class="docutils literal"><span class="pre">funp</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">lambdap</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">thunkp</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">varp</span> <span class="pre">x</span></tt></dt>
<dd>Predicates to check for function objects (named, anonymous or thunk) and
global (unbound) variables.</dd>
</dl>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id65" id="specials" name="specials">1.7.4&nbsp;&nbsp;&nbsp;Specials</a></h3>
<a name="throw"><dl class="docutils" id="throw">
<dt><tt class="docutils literal"><span class="pre">throw</span> <span class="pre">x</span></tt></dt>
<dd>Throw an exception, cf. <a class="reference" href="pure.html#exception-handling">Exception Handling</a>.</dd>
</dl>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">force</span> <span class="pre">x</span></tt></dt>
<dd>Force a thunk (<tt class="docutils literal"><span class="pre">x&amp;</span></tt>), cf. <a class="reference" href="pure.html#special-forms">Special Forms</a>. This usually happens
automagically when the value of a thunk is needed.</dd>
</dl>
<a name="arity"><dl class="docutils" id="arity">
<dt><tt class="docutils literal"><span class="pre">arity</span> <span class="pre">f</span></tt></dt>
<dd>Get the arity of a closure (named, anonymous or thunk) or a function
application, i.e., the number of arguments it expects.</dd>
</dl>
<p>Note that the arity of a function will be the actual number of arguments
for named functions, as given in the function definition. Thunks, being
parameterless closures, always yield a zero count. Anonymous functions
(lambdas) <em>always</em> yield an arity of 1, because a multi-argument lambda
like <tt class="docutils literal"><span class="pre">\x</span> <span class="pre">y</span> <span class="pre">-&gt;</span> <span class="pre">x*y</span></tt> is in fact just a shorthand for several nested
1-argument lambdas, <tt class="docutils literal"><span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">\y</span> <span class="pre">-&gt;</span> <span class="pre">x*y</span></tt> in this example. Hence:</p>
<pre class="literal-block">
&gt; foo = \x y -&gt; x*y;
&gt; arity foo;
1
&gt; arity (foo 1);
1
</pre>
<p>In contrast:</p>
<pre class="literal-block">
&gt; bar x y = x*y;
&gt; arity bar;
2
&gt; arity (bar 1);
1
</pre>
<!--  -->
</div>
<div class="section">
<h3><a class="toc-backref" href="#id66" id="pointer-operations" name="pointer-operations">1.7.5&nbsp;&nbsp;&nbsp;Pointer Operations</a></h3>
<p>The usual caveats apply, so <em>only</em> use these directly if you know what
you're doing!</p>
<a name="addr"><dl class="docutils" id="addr">
<dt><tt class="docutils literal"><span class="pre">addr</span> <span class="pre">symbol</span></tt></dt>
<dd>Get the address of a C symbol (given as a string) at runtime. The library
containing the symbol must already be loaded. Note that this can in fact
be any kind of externally visible C symbol, so it's also possible to get
the addresses of global variables. The result is returned as a
pointer. The function fails if the symbol was not found.</dd>
</dl>
<a name="calloc"><a name="malloc"><a name="realloc"><a name="free"><dl class="docutils" id="free">
<span id="realloc"></span><span id="malloc"></span><span id="calloc"></span><dt><tt class="docutils literal"><span class="pre">calloc</span> <span class="pre">nmembers</span> <span class="pre">size</span></tt>, <tt class="docutils literal"><span class="pre">malloc</span> <span class="pre">size</span></tt>, <tt class="docutils literal"><span class="pre">realloc</span> <span class="pre">ptr</span> <span class="pre">size</span></tt>, <tt class="docutils literal"><span class="pre">free</span> <span class="pre">ptr</span></tt></dt>
<dd>Interface to <tt class="docutils literal"><span class="pre">malloc</span></tt>, <tt class="docutils literal"><span class="pre">free</span></tt> and friends. These let you allocate
dynamic buffers (represented as Pure pointer values) for various nasty
purposes.</dd>
</dl>
<a name="get_byte"><a name="get_short"><a name="get_int"><a name="get_long"><a name="get_float"><a name="get_double"><a name="get_string"><a name="get_pointer"><a name="put_byte"><a name="put_short"><a name="put_int"><a name="put_long"><a name="put_float"><a name="put_double"><a name="put_string"><a name="put_pointer"><p id="put-pointer"><span id="put-string"></span><span id="put-double"></span><span id="put-float"></span><span id="put-long"></span><span id="put-int"></span><span id="put-short"></span><span id="put-byte"></span><span id="get-pointer"></span><span id="get-string"></span><span id="get-double"></span><span id="get-float"></span><span id="get-long"></span><span id="get-int"></span><span id="get-short"></span><span id="get-byte"></span><tt class="docutils literal"><span class="pre">get_byte</span> <span class="pre">ptr</span></tt>, <tt class="docutils literal"><span class="pre">get_short</span> <span class="pre">ptr</span></tt>, <tt class="docutils literal"><span class="pre">get_int</span> <span class="pre">ptr</span></tt>, <tt class="docutils literal"><span class="pre">get_long</span> <span class="pre">ptr</span></tt>, <tt class="docutils literal"><span class="pre">get_float</span> <span class="pre">ptr</span></tt>, <tt class="docutils literal"><span class="pre">get_double</span> <span class="pre">ptr</span></tt>, <tt class="docutils literal"><span class="pre">get_string</span> <span class="pre">ptr</span></tt>, <tt class="docutils literal"><span class="pre">get_pointer</span> <span class="pre">ptr</span></tt></p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">put_byte</span> <span class="pre">ptr</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">put_short</span> <span class="pre">ptr</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">put_int</span> <span class="pre">ptr</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">put_long</span> <span class="pre">ptr</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">put_float</span> <span class="pre">ptr</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">put_double</span> <span class="pre">ptr</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">put_string</span> <span class="pre">ptr</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">put_pointer</span> <span class="pre">ptr</span> <span class="pre">x</span></tt></dt>
<dd>Direct memory accesses. Use with care ... or else!</dd>
</dl>
<!--  -->
</div>
<div class="section">
<h3><a class="toc-backref" href="#id67" id="sentries" name="sentries">1.7.6&nbsp;&nbsp;&nbsp;Sentries</a></h3>
<p>Sentries are expression &quot;guards&quot;, also known as <strong>finalizers</strong>, which are
applied to the target expression when it is garbage-collected. Note that in
the current implementation sentries can only be placed at applications and
pointer objects, but this presumably covers 99% of all practical uses. The
sentry itself can be any type of object (but usually it's a function).</p>
<!-- sentry: -->
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">sentry</span> <span class="pre">f</span> <span class="pre">x</span></tt></dt>
<dd>Places a sentry <tt class="docutils literal"><span class="pre">f</span></tt> at an expression <tt class="docutils literal"><span class="pre">x</span></tt> and returns the modified
expression.</dd>
</dl>
<!-- clear_sentry: -->
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">clear_sentry</span> <span class="pre">x</span></tt></dt>
<dd>Removes the sentry from an expression <tt class="docutils literal"><span class="pre">x</span></tt>.</dd>
</dl>
<!-- get_sentry: -->
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">get_sentry</span> <span class="pre">x</span></tt></dt>
<dd>Returns the sentry of an expression <tt class="docutils literal"><span class="pre">x</span></tt> (if any, fails otherwise).</dd>
</dl>
<!-- cooked: -->
<!-- cookedp: -->
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">cooked</span> <span class="pre">ptr</span></tt>, <tt class="docutils literal"><span class="pre">cookedp</span> <span class="pre">ptr</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">cooked</span></tt> is a convenience function to create a <strong>cooked</strong> pointer which
disposes itself after use. This is just a shorthand for <tt class="docutils literal"><span class="pre">sentry</span>
<span class="pre">free</span></tt>. The given pointer <tt class="docutils literal"><span class="pre">ptr</span></tt> must be <a class="reference" href="#malloc">malloc</a>ed to make this
work. There's also a predicate <tt class="docutils literal"><span class="pre">cookedp</span></tt> to decide whether a given
pointer is cooked already (we actually assume any pointer to be cooked
which has a sentry set on it).</dd>
</dl>
<!--  -->
</div>
<div class="section">
<h3><a class="toc-backref" href="#id68" id="expression-references" name="expression-references">1.7.7&nbsp;&nbsp;&nbsp;Expression References</a></h3>
<p>If you need these, then you're doomed. ;-) However, they can be useful as a
last resort when you need to keep track of some local state or interface to
the messy imperative world. Pure's references are implemented as Pure
expression pointers so that you can readily pass them as pointers to a C
function which expects a <tt class="docutils literal"><span class="pre">pure_expr**</span></tt> parameter.  This may even be
useful at times.</p>
<!-- ref: -->
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">ref</span> <span class="pre">x</span></tt></dt>
<dd>Create a reference pointing to <tt class="docutils literal"><span class="pre">x</span></tt> initially.</dd>
</dl>
<!-- put: -->
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">put</span> <span class="pre">r</span> <span class="pre">x</span></tt></dt>
<dd>Set a new value <tt class="docutils literal"><span class="pre">x</span></tt>, and return that value.</dd>
</dl>
<!-- get: -->
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">get</span> <span class="pre">r</span></tt></dt>
<dd>Retrieve the current value <tt class="docutils literal"><span class="pre">r</span></tt> points to.</dd>
</dl>
<!-- unref: -->
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">unref</span> <span class="pre">r</span></tt></dt>
<dd>Purge the referenced object and turn the reference into a dangling
pointer. (This is used as a sentry on reference objects and shouldn't
normally be called directly.)</dd>
</dl>
<!-- refp: -->
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">refp</span> <span class="pre">x</span></tt></dt>
<dd>Predicate to check for reference values.</dd>
</dl>
<p>Note that manually removing the <tt class="docutils literal"><span class="pre">unref</span></tt> sentry of a reference turns the
reference into just a normal pointer object and renders it unusable as a
reference. Doing this will also leak memory, so don't!</p>
<!--  -->
</div>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id69" id="mathematical-functions" name="mathematical-functions">2&nbsp;&nbsp;&nbsp;Mathematical Functions</a></h1>
<p>The math.pure module provides Pure's basic math routines. It also defines
complex and rational numbers.</p>
<p>TODO</p>
<!--  -->
</div>
<div class="section">
<h1><a class="toc-backref" href="#id70" id="container-types" name="container-types">3&nbsp;&nbsp;&nbsp;Container Types</a></h1>
<p>The standard library provides a variety of efficient container data
structures for different purposes. Note that these are all purely
functional, i.e., immutable data structures implemented using different
flavours of binary trees. Nevertheless operations are performed
efficiently, in logarithmic time where possible.</p>
<p>All container types implement the equality predicates <tt class="docutils literal"><span class="pre">==</span></tt> and <tt class="docutils literal"><span class="pre">~=</span></tt> by
recursively comparing their members. In addition, the set and bag data
structures also implement the other comparison predicates (<tt class="docutils literal"><span class="pre">&lt;</span></tt>, <tt class="docutils literal"><span class="pre">&lt;=</span></tt>
etc.) by checking whether one set/bag is a subset/subbag of another.</p>
<div class="section">
<h2><a class="toc-backref" href="#id71" id="arrays" name="arrays">3.1&nbsp;&nbsp;&nbsp;Arrays</a></h2>
<p>The array.pure module implements an efficient functional array data
structure which allows to access and update individual array members, as
well as to add and remove elements at the beginning and end of an
array. All these operations are carried out in logarithmic time.</p>
<div class="section">
<h3><a class="toc-backref" href="#id72" id="imports" name="imports">3.1.1&nbsp;&nbsp;&nbsp;Imports</a></h3>
<p>To use the operations of this module, add the following import declaration
to your program:</p>
<pre class="literal-block">
using array;
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id73" id="operations" name="operations">3.1.2&nbsp;&nbsp;&nbsp;Operations</a></h3>
<a name="emptyarray"><dl class="docutils" id="emptyarray">
<dt><tt class="docutils literal"><span class="pre">emptyarray</span></tt></dt>
<dd>return the empty array</dd>
</dl>
<a name="array"><dl class="docutils" id="array">
<dt><tt class="docutils literal"><span class="pre">array</span> <span class="pre">xs</span></tt></dt>
<dd>create an array from a list <tt class="docutils literal"><span class="pre">xs</span></tt></dd>
</dl>
<a name="array2"><dl class="docutils" id="array2">
<dt><tt class="docutils literal"><span class="pre">array2</span> <span class="pre">xs</span></tt></dt>
<dd>create a two-dimensional array from a list of lists</dd>
</dl>
<a name="mkarray"><dl class="docutils" id="mkarray">
<dt><tt class="docutils literal"><span class="pre">mkarray</span> <span class="pre">x</span> <span class="pre">n</span></tt></dt>
<dd>create an array consisting of <tt class="docutils literal"><span class="pre">n</span></tt> <tt class="docutils literal"><span class="pre">x</span></tt>'s</dd>
</dl>
<a name="mkarray2"><dl class="docutils" id="mkarray2">
<dt><tt class="docutils literal"><span class="pre">mkarray2</span> <span class="pre">x</span> <span class="pre">(n,m)</span></tt></dt>
<dd>create a two-dimensional array of <tt class="docutils literal"><span class="pre">n*m</span></tt> <tt class="docutils literal"><span class="pre">x</span></tt>'s</dd>
</dl>
<a name="arrayp"><dl class="docutils" id="arrayp">
<dt><tt class="docutils literal"><span class="pre">arrayp</span> <span class="pre">x</span></tt></dt>
<dd>check whether <tt class="docutils literal"><span class="pre">x</span></tt> is an array</dd>
</dl>
<a name="# (array)"><dl class="docutils" id="id19">
<dt><tt class="docutils literal"><span class="pre">#a</span></tt></dt>
<dd>size of <tt class="docutils literal"><span class="pre">a</span></tt></dd>
</dl>
<a name="! (array)"><dl class="docutils" id="id20">
<dt><tt class="docutils literal"><span class="pre">a!i</span></tt></dt>
<dd>return the <tt class="docutils literal"><span class="pre">i</span></tt>th member of <tt class="docutils literal"><span class="pre">a</span></tt></dd>
<dt><tt class="docutils literal"><span class="pre">a!(i,j)</span></tt></dt>
<dd>two-dimensional subscript</dd>
</dl>
<a name="null (array)"><dl class="docutils" id="null-array">
<dt><tt class="docutils literal"><span class="pre">null</span> <span class="pre">a</span></tt></dt>
<dd>test whether <tt class="docutils literal"><span class="pre">a</span></tt> is the empty array</dd>
</dl>
<a name="members (array)"><a name="list (array)"><dl class="docutils" id="list-array">
<span id="members-array"></span><dt><tt class="docutils literal"><span class="pre">members</span> <span class="pre">a</span></tt>, <tt class="docutils literal"><span class="pre">list</span> <span class="pre">a</span></tt></dt>
<dd>list of values stored in <tt class="docutils literal"><span class="pre">a</span></tt></dd>
</dl>
<a name="members2 (array)"><a name="list2 (array)"><dl class="docutils" id="list2-array">
<span id="members2-array"></span><dt><tt class="docutils literal"><span class="pre">members2</span> <span class="pre">a</span></tt>, <tt class="docutils literal"><span class="pre">list2</span> <span class="pre">a</span></tt></dt>
<dd>list of members in a two-dimensional array</dd>
</dl>
<a name="first (array)"><a name="last (array)"><dl class="docutils" id="last-array">
<span id="first-array"></span><dt><tt class="docutils literal"><span class="pre">first</span> <span class="pre">a</span></tt>, <tt class="docutils literal"><span class="pre">last</span> <span class="pre">a</span></tt></dt>
<dd>first and last member of <tt class="docutils literal"><span class="pre">a</span></tt></dd>
</dl>
<a name="rmfirst (array)"><a name="rmlast (array)"><dl class="docutils" id="rmlast-array">
<span id="rmfirst-array"></span><dt><tt class="docutils literal"><span class="pre">rmfirst</span> <span class="pre">a</span></tt>, <tt class="docutils literal"><span class="pre">rmlast</span> <span class="pre">a</span></tt></dt>
<dd>remove first and last member from <tt class="docutils literal"><span class="pre">a</span></tt></dd>
</dl>
<a name="insert (array)"><dl class="docutils" id="insert-array">
<dt><tt class="docutils literal"><span class="pre">insert</span> <span class="pre">a</span> <span class="pre">x</span></tt></dt>
<dd>insert <tt class="docutils literal"><span class="pre">x</span></tt> at the beginning of <tt class="docutils literal"><span class="pre">a</span></tt></dd>
</dl>
<a name="append (array)"><dl class="docutils" id="append-array">
<dt><tt class="docutils literal"><span class="pre">append</span> <span class="pre">a</span> <span class="pre">x</span></tt></dt>
<dd>append <tt class="docutils literal"><span class="pre">x</span></tt> to the end of <tt class="docutils literal"><span class="pre">a</span></tt></dd>
</dl>
<a name="update (array)"><dl class="docutils" id="update-array">
<dt><tt class="docutils literal"><span class="pre">update</span> <span class="pre">a</span> <span class="pre">i</span> <span class="pre">x</span></tt></dt>
<dd>replace the <tt class="docutils literal"><span class="pre">i</span></tt>th member of <tt class="docutils literal"><span class="pre">a</span></tt> by <tt class="docutils literal"><span class="pre">x</span></tt></dd>
</dl>
<a name="update2"><dl class="docutils" id="update2">
<dt><tt class="docutils literal"><span class="pre">update2</span> <span class="pre">a</span> <span class="pre">(i,j)</span> <span class="pre">x</span></tt></dt>
<dd>update two-dimensional array</dd>
</dl>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id74" id="examples" name="examples">3.1.3&nbsp;&nbsp;&nbsp;Examples</a></h3>
<p>Import the module:</p>
<pre class="literal-block">
&gt; using array;
</pre>
<p>A one-dimensional array:</p>
<pre class="literal-block">
&gt; let a = array (0.0:0.1..1.0);
&gt; #a; members a;
11
[0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]
</pre>
<p>Indexing an array works in the usual way, using Pure's <tt class="docutils literal"><span class="pre">!</span></tt> operator. By
virtue of the prelude, slicing an array with <tt class="docutils literal"><span class="pre">!!</span></tt> also works as
expected:</p>
<pre class="literal-block">
&gt; a!5;
0.5
&gt; a!!(3..7);
[0.3,0.4,0.5,0.6,0.7]
</pre>
<p>Updating a member of an array produces a new array:</p>
<pre class="literal-block">
&gt; let b = update a 1 2.0;
&gt; members b;
[0.0,2.0,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]
</pre>
<p>Two-dimensional arrays can be created with <tt class="docutils literal"><span class="pre">array2</span></tt> from a list of
lists:</p>
<pre class="literal-block">
&gt; let a2 = array2 [[i,x | x = [u,v,w]] | i = 1..2];
&gt; members2 a2;
[[(1,u),(1,v),(1,w)],[(2,u),(2,v),(2,w)]]
&gt; a2!(1,2);
2,w
&gt; a2!![(0,1),(1,2)];
[(1,v),(2,w)]
&gt; a2!!(0..1,1..2);
[[(1,v),(1,w)],[(2,v),(2,w)]]
</pre>
<p>Here's how to convert an array to a Pure matrix:</p>
<pre class="literal-block">
&gt; matrix $ members a;
{0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0}
&gt; matrix $ members2 a2;
{(1,u),(1,v),(1,w);(2,u),(2,v),(2,w)}
</pre>
<p>Converting back from a matrix to an array:</p>
<pre class="literal-block">
&gt; let b2 = array2 $ list2 {(1,u),(1,v),(1,w);(2,u),(2,v),(2,w)};
&gt; members2 b2;
[[(1,u),(1,v),(1,w)],[(2,u),(2,v),(2,w)]]
</pre>
<!--  -->
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id75" id="heaps" name="heaps">3.2&nbsp;&nbsp;&nbsp;Heaps</a></h2>
<p>Heaps allow quick (constant time) access to the smallest member, and to
remove the smallest nember and insert new elements in logarithmic time.
This implementation does not allow quick update of heap members; if
such functionality is required, bags should be used instead
(see <a class="reference" href="#bag">bag</a> in <a class="reference" href="#sets-and-bags">Sets and Bags</a>).</p>
<p>Heap members <em>must</em> be ordered by the <tt class="docutils literal"><span class="pre">&lt;=</span></tt> predicate. Multiple instances
of the same element may be stored in a heap; however, the order in which
equal elements are retrieved is not specified.</p>
<div class="section">
<h3><a class="toc-backref" href="#id76" id="id21" name="id21">3.2.1&nbsp;&nbsp;&nbsp;Imports</a></h3>
<p>To use the operations of this module, add the following import declaration
to your program:</p>
<pre class="literal-block">
using heap;
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id77" id="id22" name="id22">3.2.2&nbsp;&nbsp;&nbsp;Operations</a></h3>
<a name="emptyheap"><dl class="docutils" id="emptyheap">
<dt><tt class="docutils literal"><span class="pre">emptyheap</span></tt></dt>
<dd>return the empty heap</dd>
</dl>
<a name="heap"><dl class="docutils" id="heap">
<dt><tt class="docutils literal"><span class="pre">heap</span> <span class="pre">xs</span></tt></dt>
<dd>create a heap from a list <tt class="docutils literal"><span class="pre">xs</span></tt></dd>
</dl>
<a name="heapp"><dl class="docutils" id="heapp">
<dt><tt class="docutils literal"><span class="pre">heapp</span> <span class="pre">x</span></tt></dt>
<dd>check whether <tt class="docutils literal"><span class="pre">x</span></tt> is a heap</dd>
</dl>
<a name="# (heap)"><dl class="docutils" id="id23">
<dt><tt class="docutils literal"><span class="pre">#h</span></tt></dt>
<dd>size of a heap</dd>
</dl>
<a name="null (heap)"><dl class="docutils" id="null-heap">
<dt><tt class="docutils literal"><span class="pre">null</span> <span class="pre">h</span></tt></dt>
<dd>test whether <tt class="docutils literal"><span class="pre">h</span></tt> is the empty heap</dd>
</dl>
<a name="members (heap)"><a name="list (heap)"><dl class="docutils" id="list-heap">
<span id="members-heap"></span><dt><tt class="docutils literal"><span class="pre">members</span> <span class="pre">h</span></tt>, <tt class="docutils literal"><span class="pre">list</span> <span class="pre">h</span></tt></dt>
<dd>list the members of <tt class="docutils literal"><span class="pre">h</span></tt> in ascending order</dd>
</dl>
<a name="first (heap)"><dl class="docutils" id="first-heap">
<dt><tt class="docutils literal"><span class="pre">first</span> <span class="pre">h</span></tt></dt>
<dd>the first (i.e., smallest) member of <tt class="docutils literal"><span class="pre">h</span></tt></dd>
</dl>
<a name="rmfirst (heap)"><dl class="docutils" id="rmfirst-heap">
<dt><tt class="docutils literal"><span class="pre">rmfirst</span> <span class="pre">h</span></tt></dt>
<dd>remove the first (i.e., smallest) member from <tt class="docutils literal"><span class="pre">h</span></tt></dd>
</dl>
<a name="insert (heap)"><dl class="docutils" id="insert-heap">
<dt><tt class="docutils literal"><span class="pre">insert</span> <span class="pre">h</span> <span class="pre">x</span></tt></dt>
<dd>insert <tt class="docutils literal"><span class="pre">x</span></tt> into <tt class="docutils literal"><span class="pre">h</span></tt></dd>
</dl>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id78" id="id24" name="id24">3.2.3&nbsp;&nbsp;&nbsp;Examples</a></h3>
<pre class="literal-block">
&gt; let h = heap [5,1,3,11,3];
&gt; members h;
[1,3,3,5,11]
&gt; first h;
1
&gt; members $ rmfirst h;
[3,3,5,11]
</pre>
<!--  -->
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id79" id="dictionaries" name="dictionaries">3.3&nbsp;&nbsp;&nbsp;Dictionaries</a></h2>
<p>The dict.pure module provides Pure's <tt class="docutils literal"><span class="pre">dict</span></tt> and <tt class="docutils literal"><span class="pre">hdict</span></tt> data types
based on AVL trees. <tt class="docutils literal"><span class="pre">dict</span></tt> is an ordered dictionary (assuming an ordered
key type), <tt class="docutils literal"><span class="pre">hdict</span></tt> a hashed dictionary which works with any (mixture of)
key types but stores members in an apparently random order.</p>
<p>The used AVL tree algorithm has its origin in the SWI-Prolog implementation
of association lists. The original implementation was created by
R. A. O'Keefe and updated for SWI-Prolog by Jan Wielemaker. For the
original source see <a class="reference" href="http://www.swi-prolog.org">http://www.swi-prolog.org</a>.</p>
<p>The port from SWI-Prolog and the deletion stuff (<tt class="docutils literal"><span class="pre">rmfirst</span></tt>, <tt class="docutils literal"><span class="pre">rmlast</span></tt>,
<tt class="docutils literal"><span class="pre">delete</span></tt>) missing in the Prolog implementation was provided by Jiri
Spitz.</p>
<!--  -->
<div class="section">
<h3><a class="toc-backref" href="#id80" id="id25" name="id25">3.3.1&nbsp;&nbsp;&nbsp;Imports</a></h3>
<p>To use the operations of this module, add the following import declaration
to your program:</p>
<pre class="literal-block">
using dict;
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id81" id="data-structure" name="data-structure">3.3.2&nbsp;&nbsp;&nbsp;Data Structure</a></h3>
<p>A tree for <tt class="docutils literal"><span class="pre">dict</span></tt> and <tt class="docutils literal"><span class="pre">hdict</span></tt> takes the form <tt class="docutils literal"><span class="pre">Dict</span> <span class="pre">T</span></tt> or <tt class="docutils literal"><span class="pre">HDict</span> <span class="pre">T</span></tt>
where <tt class="docutils literal"><span class="pre">T</span></tt> is either:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">nil</span></tt></dt>
<dd>the empty tree; or</dd>
<dt><tt class="docutils literal"><span class="pre">bin</span> <span class="pre">key</span> <span class="pre">value</span> <span class="pre">balance</span> <span class="pre">left</span> <span class="pre">right</span></tt></dt>
<dd>a nonempty tree with given <tt class="docutils literal"><span class="pre">key</span></tt> and <tt class="docutils literal"><span class="pre">value</span></tt> in the root node, where
<tt class="docutils literal"><span class="pre">left</span></tt> and <tt class="docutils literal"><span class="pre">right</span></tt> are the left and right subtree, and <tt class="docutils literal"><span class="pre">balance</span></tt>
is either 1, 0 or -1, denoting <tt class="docutils literal"><span class="pre">|left|-|right|</span></tt> = 1, 0, or -1,
respectively.</dd>
</dl>
<p>The tree constructors are private.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id82" id="id26" name="id26">3.3.3&nbsp;&nbsp;&nbsp;Operations</a></h3>
<a name="emptydict"><a name="emptyhdict"><dl class="docutils" id="emptyhdict">
<span id="emptydict"></span><dt><tt class="docutils literal"><span class="pre">emptydict</span></tt>, <tt class="docutils literal"><span class="pre">emptyhdict</span></tt></dt>
<dd>return the empty dict or hdict</dd>
</dl>
<a name="dict"><a name="hdict"><dl class="docutils" id="hdict">
<span id="dict"></span><dt><tt class="docutils literal"><span class="pre">dict</span> <span class="pre">xs</span></tt>, <tt class="docutils literal"><span class="pre">hdict</span> <span class="pre">xs</span></tt></dt>
<dd>create a dict or hdict from list <tt class="docutils literal"><span class="pre">xs</span></tt> of key-value pairs in the form
<tt class="docutils literal"><span class="pre">key=&gt;value</span></tt></dd>
</dl>
<a name="dictp"><a name="hdictp"><dl class="docutils" id="hdictp">
<span id="dictp"></span><dt><tt class="docutils literal"><span class="pre">dictp</span> <span class="pre">d</span></tt>, <tt class="docutils literal"><span class="pre">hdictp</span> <span class="pre">d</span></tt></dt>
<dd>check whether <tt class="docutils literal"><span class="pre">x</span></tt> is a dict or hdict</dd>
</dl>
<a name="mkdict"><a name="mkhdict"><dl class="docutils" id="mkhdict">
<span id="mkdict"></span><dt><tt class="docutils literal"><span class="pre">mkdict</span> <span class="pre">y</span> <span class="pre">xs</span></tt>, <tt class="docutils literal"><span class="pre">mkhdict</span> <span class="pre">y</span> <span class="pre">xs</span></tt></dt>
<dd>create dict or hdict from a list of keys and a constant value</dd>
</dl>
<a name="# (dict)"><a name="# (hdict)"><dl class="docutils" id="id28">
<span id="id27"></span><dt><tt class="docutils literal"><span class="pre">#d</span></tt></dt>
<dd>size of dict or hdict <tt class="docutils literal"><span class="pre">d</span></tt></dd>
</dl>
<a name="! (dict)"><a name="! (hdict)"><dl class="docutils" id="id30">
<span id="id29"></span><dt><tt class="docutils literal"><span class="pre">d!x</span></tt></dt>
<dd>get value from <tt class="docutils literal"><span class="pre">d</span></tt> by key <tt class="docutils literal"><span class="pre">x</span></tt></dd>
</dl>
<a name="null (dict)"><a name="null (hdict)"><dl class="docutils" id="null-hdict">
<span id="null-dict"></span><dt><tt class="docutils literal"><span class="pre">null</span> <span class="pre">d</span></tt></dt>
<dd>test whether <tt class="docutils literal"><span class="pre">d</span></tt> is the empty dict or hdict</dd>
</dl>
<a name="member (dict)"><a name="member (hdict)"><dl class="docutils" id="member-hdict">
<span id="member-dict"></span><dt><tt class="docutils literal"><span class="pre">member</span> <span class="pre">d</span> <span class="pre">x</span></tt></dt>
<dd>test whether <tt class="docutils literal"><span class="pre">d</span></tt> contains a member with key <tt class="docutils literal"><span class="pre">x</span></tt></dd>
</dl>
<a name="members (dict)"><a name="members (hdict)"><a name="list (dict)"><a name="list (hdict)"><dl class="docutils" id="list-hdict">
<span id="list-dict"></span><span id="members-hdict"></span><span id="members-dict"></span><dt><tt class="docutils literal"><span class="pre">members</span> <span class="pre">d</span></tt>, <tt class="docutils literal"><span class="pre">list</span> <span class="pre">d</span></tt></dt>
<dd>list members of <tt class="docutils literal"><span class="pre">d</span></tt> (in ascending order for dict)</dd>
</dl>
<a name="keys"><dl class="docutils" id="keys">
<dt><tt class="docutils literal"><span class="pre">keys</span> <span class="pre">d</span></tt></dt>
<dd>list keys of <tt class="docutils literal"><span class="pre">d</span></tt> (in ascending order for dict)</dd>
</dl>
<a name="values"><dl class="docutils" id="values">
<dt><tt class="docutils literal"><span class="pre">values</span> <span class="pre">d</span></tt></dt>
<dd>list values of <tt class="docutils literal"><span class="pre">d</span></tt></dd>
</dl>
<a name="first (dict)"><a name="first (hdict)"><a name="last (dict)"><a name="last (hdict)"><dl class="docutils" id="last-hdict">
<span id="last-dict"></span><span id="first-hdict"></span><span id="first-dict"></span><dt><tt class="docutils literal"><span class="pre">first</span> <span class="pre">d</span></tt>, <tt class="docutils literal"><span class="pre">last</span> <span class="pre">d</span></tt></dt>
<dd>return first and last member of <tt class="docutils literal"><span class="pre">d</span></tt></dd>
</dl>
<a name="rmfirst (dict)"><a name="rmfirst (hdict)"><a name="rmlast (dict)"><a name="rmlast (hdict)"><dl class="docutils" id="rmlast-hdict">
<span id="rmlast-dict"></span><span id="rmfirst-hdict"></span><span id="rmfirst-dict"></span><dt><tt class="docutils literal"><span class="pre">rmfirst</span> <span class="pre">d</span></tt>, <tt class="docutils literal"><span class="pre">rmlast</span> <span class="pre">d</span></tt></dt>
<dd>remove first and last member from <tt class="docutils literal"><span class="pre">d</span></tt></dd>
</dl>
<a name="insert (dict)"><a name="insert (hdict)"><a name="update (dict)"><a name="update (hdict)"><dl class="docutils" id="update-hdict">
<span id="update-dict"></span><span id="insert-hdict"></span><span id="insert-dict"></span><dt><tt class="docutils literal"><span class="pre">insert</span> <span class="pre">d</span> <span class="pre">(x=&gt;y)</span></tt>, <tt class="docutils literal"><span class="pre">update</span> <span class="pre">d</span> <span class="pre">x</span> <span class="pre">y</span></tt></dt>
<dd>insert <tt class="docutils literal"><span class="pre">x=&gt;y</span></tt> into <tt class="docutils literal"><span class="pre">d</span></tt> (replace any existing element); <tt class="docutils literal"><span class="pre">update</span></tt> is
a fully curried version of <tt class="docutils literal"><span class="pre">insert</span></tt></dd>
</dl>
<a name="delete (dict)"><a name="delete (hdict)"><dl class="docutils" id="delete-hdict">
<span id="delete-dict"></span><dt><tt class="docutils literal"><span class="pre">delete</span> <span class="pre">d</span> <span class="pre">x</span></tt></dt>
<dd>remove <tt class="docutils literal"><span class="pre">x</span></tt> from <tt class="docutils literal"><span class="pre">d</span></tt></dd>
</dl>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id83" id="id31" name="id31">3.3.4&nbsp;&nbsp;&nbsp;Examples</a></h3>
<p>A normal (ordered) dictionary:</p>
<pre class="literal-block">
&gt; using dict;
&gt; let d = dict [&quot;foo&quot;=&gt;77,&quot;bar&quot;=&gt;99.1];
&gt; keys d; vals d; members d;
[&quot;bar&quot;,&quot;foo&quot;]
[99.1,77]
[&quot;bar&quot;=&gt;99.1,&quot;foo&quot;=&gt;77]
</pre>
<p>Indexing a dictionary works in the usual way, using Pure's <tt class="docutils literal"><span class="pre">!</span></tt> operator.
By virtue of the prelude, slicing a dictionary with <tt class="docutils literal"><span class="pre">!!</span></tt> also works as
expected:</p>
<pre class="literal-block">
&gt; d!&quot;foo&quot;;
77
&gt; d!![&quot;foo&quot;,&quot;bar&quot;];
[77,99.1]
</pre>
<p>A hashed dictionary can be used with any key values, which are stored in a
seemingly random order:</p>
<pre class="literal-block">
&gt; let h = hdict [foo=&gt;77,42=&gt;99.1];
&gt; keys h; vals h; members h;
[42,foo]
[99.1,77]
[42=&gt;99.1,foo=&gt;77]
&gt; h!foo;
77
&gt; h!!keys h;
[99.1,77]
</pre>
<!--  -->
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id84" id="sets-and-bags" name="sets-and-bags">3.4&nbsp;&nbsp;&nbsp;Sets and Bags</a></h2>
<p>The set.pure module implements Pure's set and bag (multiset) data types
based on AVL trees. Set and bag elements must be ordered, i.e., the
predicates <tt class="docutils literal"><span class="pre">==</span></tt>, <tt class="docutils literal"><span class="pre">&lt;</span></tt> and <tt class="docutils literal"><span class="pre">&gt;</span></tt> must be defined on them. The used AVL
tree algorithm has its origin in the SWI-Prolog implementation of
association lists and was ported to Pure by Jiri Spitz, see <a class="reference" href="#dictionaries">Dictionaries</a>
for details.</p>
<!--  -->
<div class="section">
<h3><a class="toc-backref" href="#id85" id="id32" name="id32">3.4.1&nbsp;&nbsp;&nbsp;Imports</a></h3>
<p>To use the operations of this module, add the following import declaration
to your program:</p>
<pre class="literal-block">
using set;
</pre>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id86" id="id33" name="id33">3.4.2&nbsp;&nbsp;&nbsp;Data Structure</a></h3>
<p>A tree for <tt class="docutils literal"><span class="pre">set</span></tt> and <tt class="docutils literal"><span class="pre">bag</span></tt> takes the form <tt class="docutils literal"><span class="pre">Set</span> <span class="pre">T</span></tt> or <tt class="docutils literal"><span class="pre">Bag</span> <span class="pre">T</span></tt> where
<tt class="docutils literal"><span class="pre">T</span></tt> is either:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">nil</span></tt></dt>
<dd>the empty tree; or</dd>
<dt><tt class="docutils literal"><span class="pre">bin</span> <span class="pre">key</span> <span class="pre">balance</span> <span class="pre">left</span> <span class="pre">right</span></tt></dt>
<dd>a nonempty tree with given <tt class="docutils literal"><span class="pre">key</span></tt> (set element) in the root node, where
<tt class="docutils literal"><span class="pre">left</span></tt> and <tt class="docutils literal"><span class="pre">right</span></tt> are the left and right subtree, and <tt class="docutils literal"><span class="pre">balance</span></tt> is
either 1, 0 or -1, denoting <tt class="docutils literal"><span class="pre">|left|-|right|</span></tt> = 1, 0, or -1,
respectively.</dd>
</dl>
<p>The tree constructors are private.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id87" id="id34" name="id34">3.4.3&nbsp;&nbsp;&nbsp;Operations</a></h3>
<a name="emptyset"><a name="emptybag"><dl class="docutils" id="emptybag">
<span id="emptyset"></span><dt><tt class="docutils literal"><span class="pre">emptyset</span></tt>, <tt class="docutils literal"><span class="pre">emptybag</span></tt></dt>
<dd>return the empty set or bag</dd>
</dl>
<a name="set"><a name="bag"><dl class="docutils" id="bag">
<span id="set"></span><dt><tt class="docutils literal"><span class="pre">set</span> <span class="pre">xs</span></tt>, <tt class="docutils literal"><span class="pre">bag</span> <span class="pre">xs</span></tt></dt>
<dd>create a set or bag from a list <tt class="docutils literal"><span class="pre">xs</span></tt></dd>
</dl>
<a name="setp"><a name="bagp"><dl class="docutils" id="bagp">
<span id="setp"></span><dt><tt class="docutils literal"><span class="pre">setp</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">bagp</span> <span class="pre">x</span></tt></dt>
<dd>check whether <tt class="docutils literal"><span class="pre">x</span></tt> is a set or bag</dd>
</dl>
<a name="# (set)"><a name="# (bag)"><dl class="docutils" id="id36">
<span id="id35"></span><dt><tt class="docutils literal"><span class="pre">#m</span></tt></dt>
<dd>size of set or bag <tt class="docutils literal"><span class="pre">m</span></tt></dd>
</dl>
<a name="+ (set)"><a name="+ (bag)"><dl class="docutils" id="id38">
<span id="id37"></span><dt><tt class="docutils literal"><span class="pre">m1+m2</span></tt></dt>
<dd>set and bag union: <tt class="docutils literal"><span class="pre">m1+m2</span></tt> adds the members of <tt class="docutils literal"><span class="pre">m2</span></tt> to <tt class="docutils literal"><span class="pre">m1</span></tt></dd>
</dl>
<a name="- (set)"><a name="- (bag)"><dl class="docutils" id="id40">
<span id="id39"></span><dt><tt class="docutils literal"><span class="pre">m1-m2</span></tt></dt>
<dd>set and bag difference: <tt class="docutils literal"><span class="pre">m1-m2</span></tt> removes the members of <tt class="docutils literal"><span class="pre">m2</span></tt> from
<tt class="docutils literal"><span class="pre">m1</span></tt></dd>
</dl>
<a name="* (set)"><a name="* (bag)"><dl class="docutils" id="id42">
<span id="id41"></span><dt><tt class="docutils literal"><span class="pre">m1*m2</span></tt></dt>
<dd>set and bag intersection: <tt class="docutils literal"><span class="pre">m1*m2</span></tt> removes the members <em>not</em> in <tt class="docutils literal"><span class="pre">m2</span></tt>
from <tt class="docutils literal"><span class="pre">m1</span></tt></dd>
</dl>
<a name="null (set)"><a name="null (bag)"><dl class="docutils" id="null-bag">
<span id="null-set"></span><dt><tt class="docutils literal"><span class="pre">null</span> <span class="pre">m</span></tt></dt>
<dd>test whether <tt class="docutils literal"><span class="pre">m</span></tt> is the empty set or bag</dd>
</dl>
<a name="member (set)"><a name="member (bag)"><dl class="docutils" id="member-bag">
<span id="member-set"></span><dt><tt class="docutils literal"><span class="pre">member</span> <span class="pre">m</span> <span class="pre">x</span></tt></dt>
<dd>test whether <tt class="docutils literal"><span class="pre">m</span></tt> contains <tt class="docutils literal"><span class="pre">x</span></tt></dd>
</dl>
<a name="members (set)"><a name="members (bag)"><a name="list (set)"><a name="list (bag)"><dl class="docutils" id="list-bag">
<span id="list-set"></span><span id="members-bag"></span><span id="members-set"></span><dt><tt class="docutils literal"><span class="pre">members</span> <span class="pre">m</span></tt>, <tt class="docutils literal"><span class="pre">list</span> <span class="pre">m</span></tt></dt>
<dd>list members of <tt class="docutils literal"><span class="pre">m</span></tt> in ascending order</dd>
</dl>
<a name="first (set)"><a name="first (bag)"><a name="last (set)"><a name="last (bag)"><dl class="docutils" id="last-bag">
<span id="last-set"></span><span id="first-bag"></span><span id="first-set"></span><dt><tt class="docutils literal"><span class="pre">first</span> <span class="pre">m</span></tt>, <tt class="docutils literal"><span class="pre">last</span> <span class="pre">m</span></tt></dt>
<dd>return first and last member of <tt class="docutils literal"><span class="pre">m</span></tt></dd>
</dl>
<a name="rmfirst (set)"><a name="rmfirst (bag)"><a name="rmlast (set)"><a name="rmlast (bag)"><dl class="docutils" id="rmlast-bag">
<span id="rmlast-set"></span><span id="rmfirst-bag"></span><span id="rmfirst-set"></span><dt><tt class="docutils literal"><span class="pre">rmfirst</span> <span class="pre">m</span></tt>, <tt class="docutils literal"><span class="pre">rmlast</span> <span class="pre">m</span></tt></dt>
<dd>remove first and last member from <tt class="docutils literal"><span class="pre">m</span></tt></dd>
</dl>
<a name="insert (set)"><a name="insert (bag)"><dl class="docutils" id="insert-bag">
<span id="insert-set"></span><dt><tt class="docutils literal"><span class="pre">insert</span> <span class="pre">m</span> <span class="pre">x</span></tt></dt>
<dd>insert <tt class="docutils literal"><span class="pre">x</span></tt> into <tt class="docutils literal"><span class="pre">m</span></tt> (replaces an existing element in the <tt class="docutils literal"><span class="pre">set</span></tt> case)</dd>
</dl>
<a name="delete (set)"><a name="delete (bag)"><dl class="docutils" id="delete-bag">
<span id="delete-set"></span><dt><tt class="docutils literal"><span class="pre">delete</span> <span class="pre">m</span> <span class="pre">x</span></tt></dt>
<dd>remove <tt class="docutils literal"><span class="pre">x</span></tt> from <tt class="docutils literal"><span class="pre">m</span></tt> (in the <tt class="docutils literal"><span class="pre">bag</span></tt> case, only a single instance of
<tt class="docutils literal"><span class="pre">x</span></tt> is removed)</dd>
</dl>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id88" id="id43" name="id43">3.4.4&nbsp;&nbsp;&nbsp;Examples</a></h3>
<p>Some basic set operations:</p>
<pre class="literal-block">
&gt; let m = set [5,1,3,11,3];
&gt; members m;
[1,3,5,11]
&gt; map (member m) (1..5);
[1,0,1,0,1]
&gt; members $ m+set (3..6);
[1,3,4,5,6,11]
&gt; members $ m-set (3..6);
[1,11]
&gt; members $ m*set (3..6);
[3,5]
</pre>
<p>The bag operations work in a similar fashion, but note that multiple
instances are permitted in this case, and each instance counts as a
separate member:</p>
<pre class="literal-block">
&gt; let m = bag [5,1,3,11,3];
&gt; members m;
[1,3,3,5,11]
&gt; members $ delete m 3;
[1,3,5,11]
&gt; members $ insert m 1;
[1,1,3,3,5,11]
&gt; members $ m+bag (3..6);
[1,3,3,3,4,5,5,6,11]
&gt; members $ m-bag (3..6);
[1,3,11]
&gt; members $ m*bag (3..6);
[3,5]
</pre>
<!--  -->
</div>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id89" id="system-interface" name="system-interface">4&nbsp;&nbsp;&nbsp;System Interface</a></h1>
<p>This module offers some useful system routines, straight from the C
library, as well as some convenience functions for wrapping these up in
Pure. Even the &quot;purest&quot; program needs to do some basic I/O every once in a
while, and this module provides the necessary stuff to do just that. The
interface is rather minimalistic and preliminary right now, but will
probably grow over time.</p>
<p>TODO</p>
<!--  -->
</div>
<div class="section">
<h1><a class="toc-backref" href="#id90" id="getopt" name="getopt">5&nbsp;&nbsp;&nbsp;Getopt</a></h1>
<p>This is a quick-and-dirty replacement for the GNU getopt functions, ported
from the Q library.</p>
<div class="section">
<h2><a class="toc-backref" href="#id91" id="id44" name="id44">5.1&nbsp;&nbsp;&nbsp;Imports</a></h2>
<p>To use the operations of this module, add the following import declaration
to your program:</p>
<pre class="literal-block">
using getopt;
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id92" id="id45" name="id45">5.2&nbsp;&nbsp;&nbsp;Operations</a></h2>
<p>This module provides one operation: <tt class="docutils literal"><span class="pre">getopt</span> <span class="pre">opts</span> <span class="pre">args</span></tt></p>
<p>The <tt class="docutils literal"><span class="pre">getopt</span></tt> function takes two arguments: <tt class="docutils literal"><span class="pre">opts</span></tt>, a list of option
descriptions in the format described below, and <tt class="docutils literal"><span class="pre">args</span></tt>, a list of strings
containing the command line parameters to be parsed for options. The result
is a pair <tt class="docutils literal"><span class="pre">(opts_return,args_return)</span></tt> where <tt class="docutils literal"><span class="pre">opts_return</span></tt> is a list of
options and their values, and <tt class="docutils literal"><span class="pre">args_return</span></tt> is the list of remaining
(non-option) arguments. Options are parsed using the rules of GNU
getopt(1). If an invalid option is encountered (unrecognized option,
missing or extra argument, etc.), <tt class="docutils literal"><span class="pre">getopt</span></tt> throws the offending option
string as an exception.</p>
<p>The <tt class="docutils literal"><span class="pre">opts_return</span></tt> value is a list of &quot;hash pairs&quot; <tt class="docutils literal"><span class="pre">opt=&gt;val</span></tt> where
<tt class="docutils literal"><span class="pre">opt</span></tt> is the (long) option name (as given by the <tt class="docutils literal"><span class="pre">long_opt</span></tt> field given
in the <tt class="docutils literal"><span class="pre">opts</span></tt> argument, see below) and <tt class="docutils literal"><span class="pre">val</span></tt> is the corresponding value
(<tt class="docutils literal"><span class="pre">()</span></tt> if none). Note that this format is ready to be passed to the <a class="reference" href="#dict">dict</a>
or <a class="reference" href="#hdict">hdict</a> function, cf. <a class="reference" href="#dictionaries">Dictionaries</a>, which makes it easy to retrieve
option values or check for the presence of options.</p>
<p>The <tt class="docutils literal"><span class="pre">opts</span></tt> argument of <tt class="docutils literal"><span class="pre">getopt</span></tt> must be a list of triples <tt class="docutils literal"><span class="pre">(long_opt,</span>
<span class="pre">short_opt,</span> <span class="pre">flag)</span></tt>, where <tt class="docutils literal"><span class="pre">long_opt</span></tt> denotes the long option,
<tt class="docutils literal"><span class="pre">short_opt</span></tt> the equivalent short option, and <tt class="docutils literal"><span class="pre">flag</span></tt> is one of the
symbolic integer values <tt class="docutils literal"><span class="pre">NOARG</span></tt>, <tt class="docutils literal"><span class="pre">OPTARG</span></tt> and <tt class="docutils literal"><span class="pre">REQARG</span></tt> which
specifies whether the option has no argument, an optional argument or a
required argument, respectively. Either <tt class="docutils literal"><span class="pre">long_opt</span></tt> or <tt class="docutils literal"><span class="pre">short_opt</span></tt>
should be a string value of the form <tt class="docutils literal"><span class="pre">&quot;--abc&quot;</span></tt> or <tt class="docutils literal"><span class="pre">&quot;-x&quot;</span></tt>,
respectively. Note that since the <tt class="docutils literal"><span class="pre">long_opt</span></tt> value is always used to
denote the corresponding option in the <tt class="docutils literal"><span class="pre">opts_return</span></tt> list, you always
have to specify a sensible value for that field. If no separate long option
name is needed, you can specify the same value as in the <tt class="docutils literal"><span class="pre">short_opt</span></tt>
field, or some other convenient value (e.g., an integer) which designates
the option. Conversely, to indicate that an option has no short option
equivalent, simply specify an empty option string for the <tt class="docutils literal"><span class="pre">short_opt</span></tt>
field.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id93" id="id46" name="id46">5.3&nbsp;&nbsp;&nbsp;Examples</a></h2>
<pre class="literal-block">
&gt; let opts = [(&quot;--help&quot;, &quot;-h&quot;, NOARG),       // no argument
&gt;             (&quot;--version&quot;, &quot;&quot;, NOARG),      // no short option
&gt;             (&quot;--filename&quot;, &quot;-f&quot;, REQARG),  // required argument
&gt;             (&quot;--count&quot;, &quot;-n&quot;, OPTARG)];    // optional argument
&gt; getopt opts [&quot;foo&quot;, &quot;-h&quot;, &quot;--filename&quot;, &quot;bar&quot;, &quot;-n0&quot;, &quot;baz&quot;];
[&quot;--help&quot;=&gt;(),&quot;--filename&quot;=&gt;&quot;bar&quot;,&quot;--count&quot;=&gt;&quot;0&quot;],[&quot;foo&quot;,&quot;baz&quot;]
&gt; catch invalid_option $ getopt opts [&quot;-h&quot;,&quot;-v&quot;];
invalid_option &quot;-v&quot;
&gt; getopt opts [foo, &quot;-h&quot;, bar];
[&quot;--help&quot;=&gt;()],[foo,bar]
</pre>
<p>As the last example shows, non-option arguments (as well as option values
specified as separate arguments) can actually be any values which are just
copied to the result lists as is.</p>
<!-- This is the last module in the manual, so we include the index here. -->
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id94" id="id47" name="id47">6&nbsp;&nbsp;&nbsp;Index</a></h1>
<ul class="simple">
<li><a class="reference" href="#id8">!</a></li>
<li><a class="reference" href="#id20">! (array)</a></li>
<li><a class="reference" href="#id29">! (dict)</a></li>
<li><a class="reference" href="#id30">! (hdict)</a></li>
<li><a class="reference" href="#id10">! (string)</a></li>
<li><a class="reference" href="#id9">!!</a></li>
<li><a class="reference" href="#id11">!! (string)</a></li>
<li><a class="reference" href="#id3">#</a></li>
<li><a class="reference" href="#id19"># (array)</a></li>
<li><a class="reference" href="#id36"># (bag)</a></li>
<li><a class="reference" href="#id27"># (dict)</a></li>
<li><a class="reference" href="#id28"># (hdict)</a></li>
<li><a class="reference" href="#id23"># (heap)</a></li>
<li><a class="reference" href="#matrix"># (matrix)</a></li>
<li><a class="reference" href="#id35"># (set)</a></li>
<li><a class="reference" href="#id12"># (string)</a></li>
<li><a class="reference" href="#id1">$</a></li>
<li><a class="reference" href="#id14">'</a></li>
<li><a class="reference" href="#id42">* (bag)</a></li>
<li><a class="reference" href="#id41">* (set)</a></li>
<li><a class="reference" href="#id38">+ (bag)</a></li>
<li><a class="reference" href="#list">+ (list)</a></li>
<li><a class="reference" href="#id37">+ (set)</a></li>
<li><a class="reference" href="#string">+ (string)</a></li>
<li><a class="reference" href="#id5">,</a></li>
<li><a class="reference" href="#id40">- (bag)</a></li>
<li><a class="reference" href="#id39">- (set)</a></li>
<li><a class="reference" href="#id2">.</a></li>
<li><a class="reference" href="#id6">..</a></li>
<li><a class="reference" href="#id17">===</a></li>
<li><a class="reference" href="#id4">:</a></li>
<li><a class="reference" href="#id16">^</a></li>
<li><a class="reference" href="#abs">abs</a></li>
<li><a class="reference" href="#addr">addr</a></li>
<li><a class="reference" href="#all">all</a></li>
<li><a class="reference" href="#any">any</a></li>
<li><a class="reference" href="#append-array">append (array)</a></li>
<li><a class="reference" href="#applp">applp</a></li>
<li><a class="reference" href="#arithmetic-sequences">arithmetic sequences</a></li>
<li><a class="reference" href="#arity">arity</a></li>
<li><a class="reference" href="#array">array</a></li>
<li><a class="reference" href="#array2">array2</a></li>
<li><a class="reference" href="#arrayp">arrayp</a></li>
<li><a class="reference" href="#bad-list-value">bad_list_value</a></li>
<li><a class="reference" href="#bad-matrix-value">bad_matrix_value</a></li>
<li><a class="reference" href="#bad-tuple-value">bad_tuple_value</a></li>
<li><a class="reference" href="#bag">bag</a></li>
<li><a class="reference" href="#bagp">bagp</a></li>
<li><a class="reference" href="#bigint">bigint</a></li>
<li><a class="reference" href="#bigintp">bigintp</a></li>
<li><a class="reference" href="#byte-cstring">byte_cstring</a></li>
<li><a class="reference" href="#byte-cstring-pointer">byte_cstring_pointer</a></li>
<li><a class="reference" href="#byte-string">byte_string</a></li>
<li><a class="reference" href="#byte-string-pointer">byte_string_pointer</a></li>
<li><a class="reference" href="#calloc">calloc</a></li>
<li><a class="reference" href="#cat">cat</a></li>
<li><a class="reference" href="#catmap">catmap</a></li>
<li><a class="reference" href="#ceil">ceil</a></li>
<li><a class="reference" href="#character-arithmetic">character arithmetic</a></li>
<li><a class="reference" href="#charp">charp</a></li>
<li><a class="reference" href="#chars">chars</a></li>
<li><a class="reference" href="#chr">chr</a></li>
<li><a class="reference" href="#cmatrix">cmatrix</a></li>
<li><a class="reference" href="#col">col</a></li>
<li><a class="reference" href="#colcat">colcat</a></li>
<li><a class="reference" href="#colcatmap">colcatmap</a></li>
<li><a class="reference" href="#colrev">colrev</a></li>
<li><a class="reference" href="#cols">cols</a></li>
<li><a class="reference" href="#colvector">colvector</a></li>
<li><a class="reference" href="#combinators">combinators</a></li>
<li><a class="reference" href="#complexp">complexp</a></li>
<li><a class="reference" href="#conj-matrix">conj (matrix)</a></li>
<li><a class="reference" href="#cst">cst</a></li>
<li><a class="reference" href="#cstring">cstring</a></li>
<li><a class="reference" href="#cstring-dup">cstring_dup</a></li>
<li><a class="reference" href="#cstring-list">cstring_list</a></li>
<li><a class="reference" href="#curry">curry</a></li>
<li><a class="reference" href="#curry3">curry3</a></li>
<li><a class="reference" href="#cycle">cycle</a></li>
<li><a class="reference" href="#cyclen">cyclen</a></li>
<li><a class="reference" href="#delete-bag">delete (bag)</a></li>
<li><a class="reference" href="#delete-dict">delete (dict)</a></li>
<li><a class="reference" href="#delete-hdict">delete (hdict)</a></li>
<li><a class="reference" href="#delete-set">delete (set)</a></li>
<li><a class="reference" href="#diag">diag</a></li>
<li><a class="reference" href="#diagmat">diagmat</a></li>
<li><a class="reference" href="#dict">dict</a></li>
<li><a class="reference" href="#dictp">dictp</a></li>
<li><a class="reference" href="#dim">dim</a></li>
<li><a class="reference" href="#dmatrix">dmatrix</a></li>
<li><a class="reference" href="#do">do</a></li>
<li><a class="reference" href="#double">double</a></li>
<li><a class="reference" href="#doublep">doublep</a></li>
<li><a class="reference" href="#dowith">dowith</a></li>
<li><a class="reference" href="#dowith3">dowith3</a></li>
<li><a class="reference" href="#drop">drop</a></li>
<li><a class="reference" href="#dropwhile">dropwhile</a></li>
<li><a class="reference" href="#emptyarray">emptyarray</a></li>
<li><a class="reference" href="#emptybag">emptybag</a></li>
<li><a class="reference" href="#emptydict">emptydict</a></li>
<li><a class="reference" href="#emptyhdict">emptyhdict</a></li>
<li><a class="reference" href="#emptyheap">emptyheap</a></li>
<li><a class="reference" href="#emptyset">emptyset</a></li>
<li><a class="reference" href="#eval">eval</a></li>
<li><a class="reference" href="#evalcmd">evalcmd</a></li>
<li><a class="reference" href="#exactp">exactp</a></li>
<li><a class="reference" href="#failed-cond">failed_cond</a></li>
<li><a class="reference" href="#failed-match">failed_match</a></li>
<li><a class="reference" href="#false">false</a></li>
<li><a class="reference" href="#filter">filter</a></li>
<li><a class="reference" href="#first-array">first (array)</a></li>
<li><a class="reference" href="#first-bag">first (bag)</a></li>
<li><a class="reference" href="#first-dict">first (dict)</a></li>
<li><a class="reference" href="#first-hdict">first (hdict)</a></li>
<li><a class="reference" href="#first-heap">first (heap)</a></li>
<li><a class="reference" href="#first-set">first (set)</a></li>
<li><a class="reference" href="#fix">fix</a></li>
<li><a class="reference" href="#flip">flip</a></li>
<li><a class="reference" href="#floor">floor</a></li>
<li><a class="reference" href="#foldl">foldl</a></li>
<li><a class="reference" href="#foldl1">foldl1</a></li>
<li><a class="reference" href="#foldr">foldr</a></li>
<li><a class="reference" href="#foldr1">foldr1</a></li>
<li><a class="reference" href="#frac">frac</a></li>
<li><a class="reference" href="#free">free</a></li>
<li><a class="reference" href="#funp">funp</a></li>
<li><a class="reference" href="#gcd">gcd</a></li>
<li><a class="reference" href="#get-byte">get_byte</a></li>
<li><a class="reference" href="#get-double">get_double</a></li>
<li><a class="reference" href="#get-float">get_float</a></li>
<li><a class="reference" href="#get-int">get_int</a></li>
<li><a class="reference" href="#get-long">get_long</a></li>
<li><a class="reference" href="#get-pointer">get_pointer</a></li>
<li><a class="reference" href="#get-short">get_short</a></li>
<li><a class="reference" href="#get-string">get_string</a></li>
<li><a class="reference" href="#hash">hash</a></li>
<li><a class="reference" href="#hdict">hdict</a></li>
<li><a class="reference" href="#hdictp">hdictp</a></li>
<li><a class="reference" href="#head">head</a></li>
<li><a class="reference" href="#heap">heap</a></li>
<li><a class="reference" href="#heapp">heapp</a></li>
<li><a class="reference" href="#id">id</a></li>
<li><a class="reference" href="#im-matrix">im (matrix)</a></li>
<li><a class="reference" href="#imatrix">imatrix</a></li>
<li><a class="reference" href="#index">index</a></li>
<li><a class="reference" href="#index-string">index (string)</a></li>
<li><a class="reference" href="#inexactp">inexactp</a></li>
<li><a class="reference" href="#init">init</a></li>
<li><a class="reference" href="#insert-array">insert (array)</a></li>
<li><a class="reference" href="#insert-bag">insert (bag)</a></li>
<li><a class="reference" href="#insert-dict">insert (dict)</a></li>
<li><a class="reference" href="#insert-hdict">insert (hdict)</a></li>
<li><a class="reference" href="#insert-heap">insert (heap)</a></li>
<li><a class="reference" href="#insert-set">insert (set)</a></li>
<li><a class="reference" href="#int">int</a></li>
<li><a class="reference" href="#integerp">integerp</a></li>
<li><a class="reference" href="#intp">intp</a></li>
<li><a class="reference" href="#iterate">iterate</a></li>
<li><a class="reference" href="#join">join</a></li>
<li><a class="reference" href="#keys">keys</a></li>
<li><a class="reference" href="#lambdap">lambdap</a></li>
<li><a class="reference" href="#last">last</a></li>
<li><a class="reference" href="#last-array">last (array)</a></li>
<li><a class="reference" href="#last-bag">last (bag)</a></li>
<li><a class="reference" href="#last-dict">last (dict)</a></li>
<li><a class="reference" href="#last-hdict">last (hdict)</a></li>
<li><a class="reference" href="#last-set">last (set)</a></li>
<li><a class="reference" href="#lasterr">lasterr</a></li>
<li><a class="reference" href="#lcd">lcd</a></li>
<li><a class="reference" href="#id7">list</a></li>
<li><a class="reference" href="#list-array">list (array)</a></li>
<li><a class="reference" href="#list-bag">list (bag)</a></li>
<li><a class="reference" href="#list-dict">list (dict)</a></li>
<li><a class="reference" href="#list-hdict">list (hdict)</a></li>
<li><a class="reference" href="#list-heap">list (heap)</a></li>
<li><a class="reference" href="#list-matrix">list (matrix)</a></li>
<li><a class="reference" href="#list-set">list (set)</a></li>
<li><a class="reference" href="#list-string">list (string)</a></li>
<li><a class="reference" href="#list-concatenation">list concatenation</a></li>
<li><a class="reference" href="#list-indexing">list indexing</a></li>
<li><a class="reference" href="#list-size">list size</a></li>
<li><a class="reference" href="#list-slicing">list slicing</a></li>
<li><a class="reference" href="#list2-array">list2 (array)</a></li>
<li><a class="reference" href="#list2-matrix">list2 (matrix)</a></li>
<li><a class="reference" href="#listmap">listmap</a></li>
<li><a class="reference" href="#listnp">listnp</a></li>
<li><a class="reference" href="#listp">listp</a></li>
<li><a class="reference" href="#lists">lists</a></li>
<li><a class="reference" href="#malloc">malloc</a></li>
<li><a class="reference" href="#malloc-error">malloc_error</a></li>
<li><a class="reference" href="#map">map</a></li>
<li><a class="reference" href="#matcat">matcat</a></li>
<li><a class="reference" href="#id15">matrix</a></li>
<li><a class="reference" href="#matrix-string">matrix (string)</a></li>
<li><a class="reference" href="#matrix-dimensions">matrix dimensions</a></li>
<li><a class="reference" href="#matrix-size">matrix size</a></li>
<li><a class="reference" href="#matrix-transposition">matrix transposition</a></li>
<li><a class="reference" href="#matrixp">matrixp</a></li>
<li><a class="reference" href="#max">max</a></li>
<li><a class="reference" href="#member-bag">member (bag)</a></li>
<li><a class="reference" href="#member-dict">member (dict)</a></li>
<li><a class="reference" href="#member-hdict">member (hdict)</a></li>
<li><a class="reference" href="#member-set">member (set)</a></li>
<li><a class="reference" href="#members-array">members (array)</a></li>
<li><a class="reference" href="#members-bag">members (bag)</a></li>
<li><a class="reference" href="#members-dict">members (dict)</a></li>
<li><a class="reference" href="#members-hdict">members (hdict)</a></li>
<li><a class="reference" href="#members-heap">members (heap)</a></li>
<li><a class="reference" href="#members-set">members (set)</a></li>
<li><a class="reference" href="#members2-array">members2 (array)</a></li>
<li><a class="reference" href="#min">min</a></li>
<li><a class="reference" href="#mkarray">mkarray</a></li>
<li><a class="reference" href="#mkarray2">mkarray2</a></li>
<li><a class="reference" href="#mkdict">mkdict</a></li>
<li><a class="reference" href="#mkhdict">mkhdict</a></li>
<li><a class="reference" href="#null">null</a></li>
<li><a class="reference" href="#null-array">null (array)</a></li>
<li><a class="reference" href="#null-bag">null (bag)</a></li>
<li><a class="reference" href="#null-dict">null (dict)</a></li>
<li><a class="reference" href="#null-hdict">null (hdict)</a></li>
<li><a class="reference" href="#null-heap">null (heap)</a></li>
<li><a class="reference" href="#null-matrix">null (matrix)</a></li>
<li><a class="reference" href="#null-set">null (set)</a></li>
<li><a class="reference" href="#null-string">null (string)</a></li>
<li><a class="reference" href="#numberp">numberp</a></li>
<li><a class="reference" href="#operators">operators</a></li>
<li><a class="reference" href="#ord">ord</a></li>
<li><a class="reference" href="#out-of-bounds">out_of_bounds</a></li>
<li><a class="reference" href="#pack">pack</a></li>
<li><a class="reference" href="#packed">packed</a></li>
<li><a class="reference" href="#pointer">pointer</a></li>
<li><a class="reference" href="#pointerp">pointerp</a></li>
<li><a class="reference" href="#pow">pow</a></li>
<li><a class="reference" href="#pred">pred</a></li>
<li><a class="reference" href="#put-byte">put_byte</a></li>
<li><a class="reference" href="#put-double">put_double</a></li>
<li><a class="reference" href="#put-float">put_float</a></li>
<li><a class="reference" href="#put-int">put_int</a></li>
<li><a class="reference" href="#put-long">put_long</a></li>
<li><a class="reference" href="#put-pointer">put_pointer</a></li>
<li><a class="reference" href="#put-short">put_short</a></li>
<li><a class="reference" href="#put-string">put_string</a></li>
<li><a class="reference" href="#rationalp">rationalp</a></li>
<li><a class="reference" href="#re-matrix">re (matrix)</a></li>
<li><a class="reference" href="#realloc">realloc</a></li>
<li><a class="reference" href="#realp">realp</a></li>
<li><a class="reference" href="#redim">redim</a></li>
<li><a class="reference" href="#repeat">repeat</a></li>
<li><a class="reference" href="#repeatn">repeatn</a></li>
<li><a class="reference" href="#reverse">reverse</a></li>
<li><a class="reference" href="#reverse-matrix">reverse (matrix)</a></li>
<li><a class="reference" href="#rmfirst-array">rmfirst (array)</a></li>
<li><a class="reference" href="#rmfirst-bag">rmfirst (bag)</a></li>
<li><a class="reference" href="#rmfirst-dict">rmfirst (dict)</a></li>
<li><a class="reference" href="#rmfirst-hdict">rmfirst (hdict)</a></li>
<li><a class="reference" href="#rmfirst-heap">rmfirst (heap)</a></li>
<li><a class="reference" href="#rmfirst-set">rmfirst (set)</a></li>
<li><a class="reference" href="#rmlast-array">rmlast (array)</a></li>
<li><a class="reference" href="#rmlast-bag">rmlast (bag)</a></li>
<li><a class="reference" href="#rmlast-dict">rmlast (dict)</a></li>
<li><a class="reference" href="#rmlast-hdict">rmlast (hdict)</a></li>
<li><a class="reference" href="#rmlast-set">rmlast (set)</a></li>
<li><a class="reference" href="#round">round</a></li>
<li><a class="reference" href="#row">row</a></li>
<li><a class="reference" href="#rowcat">rowcat</a></li>
<li><a class="reference" href="#rowcatmap">rowcatmap</a></li>
<li><a class="reference" href="#rowrev">rowrev</a></li>
<li><a class="reference" href="#rows">rows</a></li>
<li><a class="reference" href="#rowvector">rowvector</a></li>
<li><a class="reference" href="#same">same</a></li>
<li><a class="reference" href="#scanl">scanl</a></li>
<li><a class="reference" href="#scanl1">scanl1</a></li>
<li><a class="reference" href="#scanr">scanr</a></li>
<li><a class="reference" href="#scanr1">scanr1</a></li>
<li><a class="reference" href="#set">set</a></li>
<li><a class="reference" href="#setp">setp</a></li>
<li><a class="reference" href="#sgn">sgn</a></li>
<li><a class="reference" href="#smatrix">smatrix</a></li>
<li><a class="reference" href="#split">split</a></li>
<li><a class="reference" href="#stack-fault">stack_fault</a></li>
<li><a class="reference" href="#str">str</a></li>
<li><a class="reference" href="#strcat">strcat</a></li>
<li><a class="reference" href="#stream">stream</a></li>
<li><a class="reference" href="#stride">stride</a></li>
<li><a class="reference" href="#id13">string</a></li>
<li><a class="reference" href="#string-pointer">string (pointer)</a></li>
<li><a class="reference" href="#string-concatenation">string concatenation</a></li>
<li><a class="reference" href="#string-indexing">string indexing</a></li>
<li><a class="reference" href="#string-size">string size</a></li>
<li><a class="reference" href="#string-slicing">string slicing</a></li>
<li><a class="reference" href="#string-dup">string_dup</a></li>
<li><a class="reference" href="#string-list">string_list</a></li>
<li><a class="reference" href="#stringp">stringp</a></li>
<li><a class="reference" href="#strings">strings</a></li>
<li><a class="reference" href="#subdiag">subdiag</a></li>
<li><a class="reference" href="#subdiagmat">subdiagmat</a></li>
<li><a class="reference" href="#submat">submat</a></li>
<li><a class="reference" href="#substr">substr</a></li>
<li><a class="reference" href="#succ">succ</a></li>
<li><a class="reference" href="#supdiag">supdiag</a></li>
<li><a class="reference" href="#supdiagmat">supdiagmat</a></li>
<li><a class="reference" href="#tail">tail</a></li>
<li><a class="reference" href="#take">take</a></li>
<li><a class="reference" href="#takewhile">takewhile</a></li>
<li><a class="reference" href="#throw">throw</a></li>
<li><a class="reference" href="#thunkp">thunkp</a></li>
<li><a class="reference" href="#true">true</a></li>
<li><a class="reference" href="#trunc">trunc</a></li>
<li><a class="reference" href="#tuple">tuple</a></li>
<li><a class="reference" href="#tuple-matrix">tuple (matrix)</a></li>
<li><a class="reference" href="#tuple-string">tuple (string)</a></li>
<li><a class="reference" href="#tuple-indexing">tuple indexing</a></li>
<li><a class="reference" href="#tuple-size">tuple size</a></li>
<li><a class="reference" href="#tuple-slicing">tuple slicing</a></li>
<li><a class="reference" href="#tuplep">tuplep</a></li>
<li><a class="reference" href="#tuples">tuples</a></li>
<li><a class="reference" href="#ubyte">ubyte</a></li>
<li><a class="reference" href="#uint">uint</a></li>
<li><a class="reference" href="#ulong">ulong</a></li>
<li><a class="reference" href="#uncurry">uncurry</a></li>
<li><a class="reference" href="#uncurry3">uncurry3</a></li>
<li><a class="reference" href="#unzip">unzip</a></li>
<li><a class="reference" href="#unzip3">unzip3</a></li>
<li><a class="reference" href="#update-array">update (array)</a></li>
<li><a class="reference" href="#update-dict">update (dict)</a></li>
<li><a class="reference" href="#update-hdict">update (hdict)</a></li>
<li><a class="reference" href="#update2">update2</a></li>
<li><a class="reference" href="#ushort">ushort</a></li>
<li><a class="reference" href="#values">values</a></li>
<li><a class="reference" href="#varp">varp</a></li>
<li><a class="reference" href="#void">void</a></li>
<li><a class="reference" href="#while">while</a></li>
<li><a class="reference" href="#zip">zip</a></li>
<li><a class="reference" href="#zip3">zip3</a></li>
<li><a class="reference" href="#zipwith">zipwith</a></li>
<li><a class="reference" href="#zipwith3">zipwith3</a></li>
<li><a class="reference" href="#id18">~==</a></li>
</ul>
</div>
</div>
</body>
</html>
