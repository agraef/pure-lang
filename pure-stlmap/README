
--- DRAFT - FOR DISCUSSION PURPOSES ONLY ---


A. General

1. This is *NOT* ready for public consumption!

2. The pure-stlmap package provides a Pure interface to the STL's four "sorted
   associative" containers: map, set, multimap and multiset. The corresponding
   Pure containers are stlmap, stlset, stlmmap and stlmset. The stlmap and
   stlmmap containers, sometimes referred to simply as "maps", hold keys,
   each of which has an associated value that can be set or retrieved based on
   key. The key value pairs in a Pure map or is referred to as an elements or
   members of the map. If v is the value associate with key k, the
   corresponding element of the map is denoted by (k=>v). The stlset and
   stlmset containers, referred to as "sets", contain only keys with
   no associated values. In this case, the keys themselves are referred to as
   the elements or members of the pure-stl set.

3. All four of containers are mutable; no immutable versions are provided by
   pure-stlmap. All of the containers are implemented with balanced binary
   trees which allow for O(log N) time for storage and retrieval.

4. Keys stored in a stlmap or stlset are unique. An attempt to insert a new
   element (k=>v) or k, when k is already in the map or set does not change
   the map or set. To change the associated value of a key value pair stored
   in a stlmap, use the update function. In contrast to stlmaps and stlsets,
   stlmmaps and stlmset can store multiple keys with the same value.

5. All of the sorted associative containers keep their keys in sorted order
   imposed by a "less than function" that is stored in the container. By
   default the less than function is (<), but customized less than functions
   can be specified when a container is created. 

   The ordering imposed on a sorted associative container's elements makes it
   possible to designate well defined "ranges" of elements, using "iterator
   tuples". For these purposes an iterator can be thought of as a pointer to
   an element in the container.

   The iterator tuples for the sorted associative containers always specify
   ranges. They have three elements: (sac, lb_key, ub_key) where sac a stlmap,
   stlset, stlmmap or stlmset, lb_key is a key designating the lower bound of
   the range and ub_key is a key designating the upper bound of the range. The
   designated range is an ordered subsequence of elements of sac beginning with
   the first element whose key is not less than lb_key and all succeeding
   elements that are less than ub_key.
   
   Thus, if sm1 is the stlmmap consisting of ["b"=>1,"b"=>2,"c"=>3","d"=>4]
   then (Sam1,"b","d") is ["b"=>1,"b"=>2,"c"=>3], (Sm1,"a","c") is
   ["b"=>1,"b"=>2] and (sm1,"c","x") is ["c"=>3].

   When specifying a range of a sorted associative container provided by
   pure-stump, the constant stl::stlbeg denotes the first element in the
   container and the constant stl::stlend denotes a value that is greater than
   any of the containers elements. In terms of C++ iterators, stalker and
   stlend correspond to sac.begin() and sac.end() where sac is the STL
   container wrapped by the Pure container. Thus, if ss1 is the stlmset
   consisting of ["b","b","c","d"], (ss1,"c",stlend) is the range ["c","d"].

   Finally, if a function calls for a range as a parameter, the function can
   be passed an iterator tuple consisting of less than three elements.  A
   tuple with two elements, (mp,lb_key), will be treated the same as
   (mp,lb_key,lb1_key) where lb1_key is equal to (next_key mp lb_key). A tuple
   with one element mp will be treated the same as (mp, stl::stlbeg,
   stl::stlend).

6. Note that ranges defined on stlmmaps and stlmsets are based solely on
   keys. It is not possible define a range in terms of a key-value
   combinations. This follows from the fact that in pure-stlmap, elements and
   ranges are always specified by key, not by individual elements. 

   For example, let mmp be a stlmmap that consists of
   ["a"=>1,"a"=>2,"a"=>2,"a"=>3,"a"=>3]. In C++ where ranges are easily
   defined based on individual elements, one could define a range in mmp
   consisting of ["a"="a"=>2,"a"=>3,"a"=>3]. In pure-stlmap, this is not
   possible: if you have one element with key "a", you must have all of
   them. I.e., (ss1,"a","b") consists of ["a"=>1,"a"=>2,"a"=3] and
   (ss1,"a","a")

   This presents a design issue in the case of stlmmaps, in which keys are not
   necessarily unique. If several elements in a stlmmap have the same key, how
   does one refer to a particular instance of them? One might want to delete
   all elements with key "a", all elements with key "a" and value 2, or just
   one element with key "a" and value 2.

   pure-stlmap deals with this issue by providing functions that update or
   erase elements in ranges based on a function passed as one of the
   parameters. For example following would erase all elements of mmp with 
   key "a" and value equal to 2:

      my_equal x (_=>v) = v==x;
      erase_if (my_equal 2) (mmp,"a")

   More precisely, this erases all elements in the range consisting of
   elements with k "a" that satisfy (value_equal 2). A slightly more elaborate
   function can used to erase at most one element of mmp with key "a" and
   value 2:

      let erased = ref 0;
      my_equal_once x (_=>v) = if ~get erased && v==x then put erased 1 else 0;
      erase_if (my_equal_once 2) (mmp,"a")

8. See stlmap.pure and stlmmap for functions provided. Most are just what one
   might expect for a container that holds an ordered sequence of elements.

B. Notable features

1. By default, stlsets and stlmaps are constructed with (<) as the ordering
   function. Other ordering functions can be used if desired.

2. The ! operator

   a. If ss is a stlset or stlmset, ss!k returns the number of elements equal
      to k. Thus, if k is not an element of ss, ss!k is 0.

   b. If sm is a stlmap, sm!k returns v if k is stored in sm. If k is not
      stored in sm, sm!k returns sm's default value, if any, or throws an
      out_of_bounds exception. (see 3 for notes on default values).

   c.  If smm is a stlmmap, smm!k smm!k returns a list of consisting of all v
       where (k=>v) is an element of smm, provided that at least one k is
       stored in smm. Otherwise sm!k returns sm's default value, if any, or
       throws an out_of_bounds exception. (see 3 for notes on default values).

3. A stlmap or stlmmap, mp, can be given a default value (al la C++ T()).

   a. Generally, mp!k will throw out_of_bounds if k is not stored in mp.

   b. However, if mp has a default value dv, will be returned. Contrary to
      operator[] in C++, (k=>dv) is not inserted into mp. Using default values
      allows one to use a error codes in lieu of exceptions.

         let x = mp!k;
         if x == nothing then ... else ...

      Default values such as 0 or [] can be useful for maps that are used to
      count or collect objects that have a given key. (See update_with at 4).

   c. N.B. stlsets do not have default values.

4. A key value pair, (k=>v) for a stlmap or stlmmap, map, can be "updated" using
   "update map k v" or "update_with f (map,kbeg,kend)". Note that the update
   functions only change values, never keys

   a. "update map key val" changes the values of all elements (k=>v) of map
      where k==key to v. If key is not already stored in map, (key=v) is added
      to the map.

   b. "update_with unary_fun (map,key)" changes the values of all elements
      (k=>v) of map where k==key to (unary_fun v). If key is not already
      stored in map then (i) if map has a default value, dv, then
      (key=>unary_fun dv) is added to the map, or (ii) if map does not have a
      default value, a failed_condition error is thrown.
      
   c. "update_with unary_fun (map,kbeg,kend)" changes the values of all
      elements of the range, kbeg, kend to (unary_fun v).
      

   d. "update_with" provides precise control over the modification of key
      value pairs. E.g., if map is a stlmmap, all of its elements with (k=>v)
      where k == "a" and (pred v) is true can be changed to (k=>new v).

         selective_update (_=>v) = if (pred v) then (new v) else v;
         update_with selective_update (map,"a");

   e. "update_with" is also useful for associating a count or lists of objects
      with a given key. E.g., 

        let word_counts = emptystlmap;
        set_default word_counts 0;
        bump_count w = update_with ((\_=>v)->v+1) (word_counts, w); 
        do bump_count word_list;

        sort_str w = strcat $ sort (<) (chars w);
        let anagrams = emptystlmap;
        set_default anagrams [];
        push_word w = update_with (\(_=>v)->w:v) (anagrams, sort_str w));
        do push_word word_list;
  
5. Set operators are provided for all four of the sorted associative
   containers. 

   a. The operators are: "+", "-", "*", "/", "<" and ",=". 

   b. Both operands must be the same type of container. I.e., sm1 + sm2, where
      sm1 and sm2 are stlmaps, but no sm1 + smm1, where smm1 is a stlmmap.
 
   c. The operations act on ranges, so it is possible to work with container
      subsequences. Except for the set inclusion operators (< and <=), all
      of the set operators 

   d. The set operations use the native STL algorithms, which take full
      advantage of the fact that the containers have ordered elements. At
      most 2 (n1 + n2) - 1 comparisons are made where n1 and n2 are the number
      of elements in the first and second operands.

   e. The set operations only consider keys, values are never used to
      determine what elements are included in the resulting containers. Thus,
      for example, mp1 + mp2 might not be the same as mp2 + mp1 where mp1
      and mp2 are stlmaps or stlmmaps.

6. The insert and insert_elms functions follow STL semantics. This means, for
   example, that if (k=>v1) is a member of stlmap sd then insert sd (k=>v2)
   will *not* change sd. sd!k will still be v1. Use update to change the
   values of existing members. E.g., after (update sd k v2), sd!k will be v2.

7. Elements can be deleted from the associative containers using the delete,
   delete_all, delete_if, delete_all_if and erase functions.

   a. erase (sac,k1,k2) deletes all elements in the indicated range.

   b. erase_if pred (sac,k1,k2) deletes all elements in the indicated range
      that satisfy pred 

   c. The erase functions return the number of elements deleted (which
      can be 0).

   g. E.g., to delete all instances of ("b"=>5) from a stlmmap smm:

      let num_deleted = erase_if (\(_=>v)->v==5) (smm,"b");

8. For any sorted associative container, sac, "next_key sac k)" and "prev_key
   sac k) do what their name suggests. If k is the last key in sac "next_key
   sac k)" returns stl::stlend. If k is the past end iterator, next_key throws
   an out_of_bounds exception, and prev_key returns the key of the last
   element in sac. If k is the first key in sac, "prev_key" throws
   out_of_bounds exception. If k is the second key in sac, prev_key returns
   stl::stlbeg, rather than the actual first k in sac.

C. Cached iterators

1. The last C++ iterator used in selected operations is cached. Only one
   iterator is cached at any one time. Operations that invalidate the cached
   iterator cause the iterator to be removed from the cache.

2. The following operations cause an iterator to be cached:

   FIX

3. The following operations cause an iterator to be deleted from the cache:

   FIX

4 In certain commonly occurring sequences caching can eliminate an O(log N)
  lookup. E.g., "member sd k" followed by "sd!k" or "update sd k v" only
  requires only one lookup. Caching also allows efficient traversal of the
  elements in sd using "next sd k" and "prev sd k".

D. Examples/Testing

1. To run the example/test script for stlmaps:

     $> pure -q -w
     > run check_eval.pure 
     > check "ut_script_stlmap.pure";

2. The target scripts for stlmmap, stlset, stlmset have similar names.

3. More testing needs to be done.

