/* stlmmap.pure: Pure interface to C++ STL mulitmap
    
--- DRAFT - FOR DISCUSSON PURPOSES ONLY ---

Copyright (c) 2011 by Peter Summerland <p.summerland@gmail.com>.

All rights reserved.

This software is is part of pure-stlmap, an addon to the Pure Programming
Language (http://code.google.com/p/pure-lang/).

This software is distributed under a BSD-style license in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the COPYING file
included with the pure-stlmap distribution package for details.

*/

using stlbase;
using "lib:stlmmap";

namespace stl;

/*** C++ support ************************************************************/

extern expr* smm_type_tags();
private extern expr* smm_make_empty(expr* kcmp, expr* vcmp, expr* veql,
                                   expr* default_val, int ko);
private extern void  smm_delete(void* smp);
private extern void  smm_iter_delete(void* smip);
private extern expr* smm_parameters(expr* rng);
private extern int   smm_size(expr* rng);
private extern int   smm_count(expr* pxsmmp, expr* key);
private extern bool  smm_empty(expr* rng);
private extern bool  smm_is_set(expr* rng);

private extern expr* smm_find(expr* pxsmp, expr* key, int what);
private extern expr* smm_copy_iter(expr* pxsmip);
private extern expr* smm_begin(expr* pxsmp);
private extern expr* smm_end(expr* pxsmp); 
private extern expr* smm_bounds(expr* pxsmp, expr* key, int what);
private extern expr* smm_range_info(expr* rng);
private extern expr* smm_move_iter(expr* pxsmp, int count);
private extern expr* smm_iter_is_at(expr* pxsmip, int where);
private extern expr* smm_iter_info(expr* pxsmip);
private extern expr* smm_equal_iter(expr* pxsmp, expr* pxsmp);

private extern expr* smm_get_at(expr* pxsmip, int what);
private extern expr* smm_get_elm_at_inc(expr* pxsmip);
private extern expr* smm_put_at(expr* pxsmip, expr* val);
private extern expr* smm_insert_hinted(expr*map, expr* iter, expr* kv);
private extern expr* smm_insert_elm(expr* map, expr* kv);
private extern int   smm_insert_elms_xs(expr* map, expr* src);
private extern int   smm_insert_elms_stlvec(expr* map, expr* svrng);
private extern int   smm_insert_elms_stlmmap(expr* map, expr* rng);
private extern void  smm_swap(expr* sac1, expr* sac2);
private extern int   smm_erase(expr* sac, expr* trg);
private extern int   smm_clear(expr* map);

private extern int   smm_equal(expr* rng1, expr* rng2);
private extern int   smm_less(expr* rng1, expr* rng2);
private extern bool  smm_includes(expr* rng1, expr* rng2);
private extern expr* smm_setop(int op, expr* rng1, expr* rng2);

private extern expr* smm_make_vector(expr* rng);
private extern void* smm_fill_stlvec(expr* rng, void* v);

private extern expr* smm_listmap(expr* fun, expr* rng, int what);
private extern expr* smm_listcatmap(expr* fun, expr* rng, int what);
private extern expr* smm_foldl(expr* fun, expr* val, expr* rng);
private extern expr* smm_foldl1(expr* fun, expr* rng);
private extern expr* smm_foldr(expr* fun, expr* val, expr* rng);
private extern expr* smm_foldr1(expr* fun, expr* rng);

private extern int   smm_member(expr* map, expr* key);
private extern expr* smm_bounding_keys(expr* rng);
private extern expr* smm_prev_key(expr* map, expr* key);
private extern expr* smm_next_key(expr* map, expr* key);
private extern expr* smm_update(expr* map, expr* key, expr* val);

extern void stl_set_smm_trace(bool enable) = set_smm_trace;
extern bool stl_smm_trace_enabled() = smm_trace_enabled;

/*** global type definitions ********************************************/

namespace ;

let stlmmap_t, stlmmap_iter_t, stlmset_t, stlmset_iter_t = stl::smm_type_tags;

type stlmmap x = check_ptrtag stlmmap_t x;
type stlmset x = check_ptrtag stlmset_t x;
type stlmsac x::stlmmap | stlmsac x::stlmset;

type stlmmap_iter x = check_ptrtag stlmmap_iter_t x;
type stlmset_iter x = check_ptrtag stlmset_iter_t x;
type stlmsac_iter x::stlmmap_iter | stlmsac_iter x::stlmset_iter;

type smmrng x::stlmsac | smmrng (x::stlmsac, _);
type smmrng (x::stlmmap_iter, y::stlmmap_iter);
type smmrng (x::stlmset_iter, y::stlmset_iter);

stlmmapp x = check_ptrtag stlmmap_t x;
stlmsetp x = check_ptrtag stlmset_t x;
stlmsacp x = stlmmapp x || stlmsetp x;

stlmmap_iter_p x = check_ptrtag stlmmap_iter_t x;
stlmset_iter_p x = check_ptrtag stlmset_iter_t x;
stlmsac_iter_p x = stlmmap_iter_p x || stlmset_iter_p x;

stlmsac_range_p x = case x of x::smmrng = 1; x = 0 end; 

namespace stl;

/*** Helpers **************************************************************/

private 
  smm_lower_bound smm_update_with
  smm_iter smm_key smm_val smm_elm 
  smm_merge smm_union smm_difference smm_intersection smm_symmetric_difference 
  smm_wrap_sv smm_less smm_equal compatible_ranges lazy_map_aux;

const smm_lower_bound = 1;
const smm_upper_bound = 2;
const smm_equal_range = 3;

const smm_key = 1;
const smm_val = 2;
const smm_elm = 3;
const smm_iter = 4;
const smm_iter_dflt = 5;

const smm_merge = 1;
const smm_union = 2;
const smm_difference = 3;
const smm_intersection = 4;
const smm_symmetric_difference = 5;

const smm_at_beginning = 1;
const smm_at_pastend = 2;

compatible_ranges rng1::smmrng rng2 = 
  if smm_is_set rng1 then smm_is_set rng2 else ~smm_is_set rng2;

// function of k=>v
lazy_map_aux fun first::stlmsac_iter last = gen first with
  gen i = if i==last then [] 
          else fun (smm_get_elm_at_inc i):(gen i &);
end;

lazy_elms_aux first::stlmsac_iter last = gen first with
  gen i = if i==last then [] 
          else smm_get_elm_at_inc i : (gen i &);
end;

/*** Iterators **********************************************************/

iterator pos::stlmsac_iter = smm_copy_iter pos;

begin smm::stlmsac = smm_begin smm;

pastend smm::stlmsac = smm_end smm;

find smm::stlmsac key = smm_find smm key smm_iter;

lower_bound smm::stlmsac key = smm_bounds smm key smm_lower_bound;

upper_bound smm::stlmsac key = smm_bounds smm key smm_upper_bound;

equal_range smm::stlmsac key = smm_bounds smm key smm_equal_range;

is_begin pos::stlmsac_iter = smm_iter_is_at pos smm_at_beginning;

is_pastend pos::stlmsac_iter = smm_iter_is_at pos smm_at_pastend;

get_info pos::stlmsac_iter = smm_iter_info pos;

get_elm pos::stlmsac_iter = smm_get_at pos smm_elm;

get_key pos::stlmsac_iter = smm_get_at pos smm_key;

get_val pos::stlmsac_iter = smm_get_at pos smm_val;

put_val pos::stlmmap_iter val = smm_put_at pos val;

inc pos::stlmsac_iter = smm_move_iter pos 1;

dec pos::stlmsac_iter = smm_move_iter pos (-1);

move pos::stlmsac_iter n::int = smm_move_iter pos n;

/*** Iterator Operators ****************************************************/

(::==) pos1::stlmsac_iter pos2::stlmsac_iter = smm_equal_iter pos1 pos2;

(::^) smm::stlmmap key = smm_find smm key smm_iter_dflt;  // inserts default

// (::!) smm::stlmmap pos::stlmmap_iter = smm_get_at pos smm_val 
//   if container pos === smm;

/***  Constructors *********************************************************/

emptystlmmap (kcmp,dflt,vcmp,veql) = smm_make_empty kcmp vcmp veql dflt 0;
emptystlmmap (kcmp,dflt,vcmp)      = smm_make_empty kcmp vcmp (==) dflt 0;
emptystlmmap (kcmp,dflt)           = smm_make_empty kcmp (<) (==) dflt  0;
emptystlmmap kcmp                  = smm_make_empty kcmp (<) (==) [] 0;

stlmmap xs = smm when
  smm = emptystlmmap (<);
  smm_insert_elms_xs smm xs;
end if listp xs || matrixp xs;

stlmmap rng::svrng = smm when
  smm = emptystlmmap (<);
  smm_insert_elms_stlvec smm rng;
end;

stlmmap rng::smmrng = smm when
  _,params = smm_parameters rng;
  smm = emptystlmmap params;
  smm_insert_elms_stlmmap smm rng;
end if ~smm_is_set rng;

emptystlmset kcmp = smm_make_empty kcmp (<) (==) [] 1;

stlmset xs = ss when
  ss = emptystlmset (<);
  smm_insert_elms_xs ss xs;
end if listp xs || matrixp xs;

stlmset rng::svrng = ss when
  ss = emptystlmset (<);
  smm_insert_elms_stlvec ss rng;
end;

stlmset rng::smmrng = ss when
  _,kc,_ = smm_parameters rng;
  ss = emptystlmset kc;
  smm_insert_elms_stlmmap ss rng;
end if smm_is_set rng;

/*** Range Content ****************************************************/

lazy_map f rng::smmrng = lazy_map_aux f first last if valid when 
  valid,m,b,last = smm_range_info rng;
  first = iterator b;
end;

lazy_elms rng::smmrng = lazy_elms_aux first last if valid when 
  valid,m,b,last = smm_range_info rng;
  first = smm_copy_iter b;
end;

lazy_keys rng::smmrng = lazy_map (\(k=>v)->k) rng if ~smm_is_set rng;

lazy_keys rng::smmrng = lazy_elms rng;

lazy_vals rng::smmrng = lazy_map (\(k=>v)->v) rng if ~smm_is_set rng;

lazy_vals rng::smmrng = lazy_elms rng;

elms rng::smmrng = smm_listmap 0 rng smm_elm; 

keys rng::smmrng = smm_listmap 0 rng smm_key;// if ~smm_is_set rng;

vals rng::smmrng = smm_listmap 0 rng smm_val;// if ~smm_is_set rng;

vector rng::smmrng = smm_make_vector rng;

stlvec rng::smmrng = sv if ok when
  sv = emptystlvec;
  ok = case sv of  
    STLVEC v = smm_fill_stlvec rng v $$ 1;
    _ = 0;
  end;
end;

/*** Info ***************************************************************/

range_info rng::smmrng = smm_range_info rng;

(::#) smm::stlmsac = smm_size smm;

size smm::stlmsac = smm_size smm;

empty smm::stlmsac = smm_empty smm;

distance rng::smmrng = smm_size rng;

is_set rng::smmrng = smm_is_set rng;

count smm::stlmsac key = smm_count smm key;

parameters rng::smmrng = smm_parameters rng;

/*** Modifiers *********************************************************/

insert smm::stlmsac xs::list = smm_insert_elms_xs smm xs;

insert smm::stlmsac xs::matrix = smm_insert_elms_xs smm xs;

insert smm::stlmsac rng::smmrng = smm_insert_elms_stlmmap smm rng;

insert smm::stlmsac rng::svrng = smm_insert_elms_stlvec smm rng;

insert smm::stlmmap (val@(k=>v), pos::stlmsac_iter) = smm_insert_hinted smm pos val;

insert smm::stlmmap val@(k=>v) = smm_insert_elm smm val;

insert smm::stlmset (key, pos::stlmsac_iter) = smm_insert_hinted smm pos key;

insert smm::stlmset key = smm_insert_elm smm key;

insert_elm smm::stlmset key = smm_insert_elm smm key; // to get xs, etc into set

clear smm::stlmsac = smm_clear smm;

erase smm::stlmsac tpl@(i::stlmsac_iter, j::stlmsac_iter) = smm_erase smm tpl;

erase smm::stlmsac pos::stlmsac_iter = smm_erase smm pos;

erase smm::stlmsac (smm,key1,key2) = smm_erase smm (smm,key1,key2);

erase smm::stlmsac (smm,key) = smm_erase smm (smm,key);

erase smm::stlmsac key = smm_erase smm (smm,key);

swap sm1::stlmmap sm2::stlmmap = smm_swap sm1 sm2;

swap ss1::stlmset ss2::stlmset = smm_swap ss1 ss2;

/*** Equality and Lexicographical Comparison ***************************/

equal rng1::smmrng rng2::smmrng = smm_equal rng1 rng2
  if compatible_ranges rng1 rng2;

(::==) sac1::stlmsac sac2::stlmsac = smm_equal sac1 sac2
  if compatible_ranges sac1 sac2;

(::~=) sac1::stlmsac sac2::stlmsac = ~smm_equal sac1 sac2
  if compatible_ranges sac1 sac2;

(::<) rng1::smmrng rng2::smmrng = smm_less rng1 rng2
  if compatible_ranges rng1 rng2;

(::<=) rng1::smmrng rng2::smmrng = ~smm_less rng2 rng1
  if compatible_ranges rng1 rng2;

(::>) rng1::smmrng rng2::smmrng = smm_less rng2 rng1
  if compatible_ranges rng1 rng2;

(::>=) rng1::smmrng rng2::smmrng = ~smm_less rng1 rng2
  if compatible_ranges rng1 rng2;

/** STL Set Algorithms ***************************************************/

merge rng1::smmrng rng2::smmrng = 
  smm_setop smm_merge rng1 rng2 if compatible_ranges rng1 rng2;

set_union rng1::smmrng rng2::smmrng = 
  smm_setop smm_union rng1 rng2 if compatible_ranges rng1 rng2;

set_difference rng1::smmrng rng2::smmrng = 
  smm_setop smm_difference rng1 rng2 if compatible_ranges rng1 rng2;

set_intersection rng1::smmrng rng2::smmrng = 
  smm_setop smm_intersection rng1 rng2 if compatible_ranges rng1 rng2;

set_symmetric_difference rng1::smmrng rng2::smmrng = 
  smm_setop smm_symmetric_difference rng1 rng2 if compatible_ranges rng1 rng2;

set_includes rng1::smmrng rng2::smmrng =
 smm_includes rng1 rng2 if compatible_ranges rng1 rng2;

// add find adj ?? some others ??05

/*** Mapping and Folding ********************************************/

::map f rng::smmrng = smm_listmap f rng smm_elm; // => smm_key for sets

::foldl f x rng::smmrng = smm_foldl f x rng;

::foldl1 f rng::smmrng = smm_foldl1 f rng;

::foldr f x rng::smmrng = smm_foldr f x rng;

::foldr1 f rng::smmrng = smm_foldr1 f rng;

::do f rng::smmrng = smm_foldl (\_ x->f x) () rng $$ ();

::filter p rng::smmrng = smm_foldr f [] rng with
  f x xs = res when
    res = case p x of
      1 = x:xs;
      0 = xs;
      y = throw failed_cond;
    end;
  end;
end;

::listmap f rng::smmrng = smm_listmap f rng smm_elm;

::catmap f rng::smmrng = smm_listcatmap f rng smm_elm;

/*** Vector functions ****************************************************/

::rowmap f rng::smmrng = rowcat (smm_listmap f rng smm_elm);

::rowcatmap f rng::smmrng = rowcat (smm_listmap f rng smm_elm);

::colmap f rng::smmrng = colcat (smm_listmap f rng smm_elm);

::colcatmap f rng::smmrng = colcat (smm_listmap f rng smm_elm);

/*** Key oriented interface functions *********************************/

(::!) smm::stlmsac key = smm_listmap 0 (smm,key) smm_val;

has_key smm::stlmsac key = smm_member smm key;

bounding_keys rng::smmrng = smm_bounding_keys rng;

next_key smm::stlmsac key = smm_next_key smm key;

prev_key smm::stlmsac key = smm_prev_key smm key;

update smm::stlmmap k xs = smm_update smm k xs $$ smm;

update_elms smm::stlmmap (k=>xs) = smm_update smm k xs $$ smm if ~is_set smm;

