/* stlmap.pure: Pure interface to C++ STL map
    
--- DRAFT - FOR DISCUSSON PURPOSES ONLY ---

Copyright (c) 2011 by Peter Summerland <p.summerland@gmail.com>.

All rights reserved.

This software is is part of pure-stlmap, an addon to the Pure Programming
Language (http://code.google.com/p/pure-lang/).

This software is distributed under a BSD-style license in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the COPYING file
included with the pure-stlmap distribution package for details.

*/
 
using stlbase;
using "lib:stlassoc";

namespace stl;

/*** C++ Support **********************************************************/

extern expr* sm_type_tags();
private extern expr* sm_make_empty(expr* kcmp, expr* vcmp, expr* veql,
                                   expr* default_val, int ko);
private extern void  sm_delete(void* smp);
private extern void  sm_iter_delete(void* smip);
private extern expr* sm_container_info(expr* rng); 
private extern int   sm_size(expr* rng);
private extern int   sm_count(expr* pxsmp, expr* key);
private extern bool  sm_empty(expr* rng);
private extern bool  sm_is_set(expr* rng);
private extern expr* sm_find(expr* pxsmp, expr* key, int what);
private extern expr* sm_copy_iter(expr* pxsmip);
private extern expr* sm_begin(expr* pxsmp);
private extern expr* sm_end(expr* pxsmp); 
private extern expr* sm_bounds(expr* pxsmp, expr* key, int what);
private extern expr* sm_range_info(expr* rng);
private extern expr* sm_move_iter(expr* pxsmp, int count);
private extern expr* sm_iter_is_at(expr* pxsmip, int where);
private extern expr* sm_iter_info(expr* pxsmip);
private extern expr* sm_equal_iter(expr* pxsmp, expr* pxsmp);
private extern expr* sm_get_at(expr* pxsmip, int what);
private extern expr* sm_get_elm_at_inc(expr* pxsmip);
private extern expr* sm_put_at(expr* pxsmip, expr* val);
private extern expr* sm_insert_hinted(expr*map, expr* iter, expr* kv);
private extern expr* sm_insert_elm(expr* map, expr* kv);
private extern int   sm_insert_elms_xs(expr* map, expr* src);
private extern int   sm_insert_elms_stlvec(expr* map, void* svp);
private extern int   sm_insert_elms_stlmap(expr* map, expr* rng);
private extern void  sm_swap(expr* sac1, expr* sac2);
private extern int   sm_erase(expr* sac, expr* trg);
private extern int   sm_clear(expr* map);
private extern int   sm_equal(expr* rng1, expr* rng2);
private extern int   sm_less(expr* rng1, expr* rng2);
private extern bool  sm_includes(expr* rng1, expr* rng2);
private extern expr* sm_setop(int op, expr* rng1, expr* rng2);
private extern expr* sm_make_vector(expr* rng);
private extern void* sm_fill_stlvec(expr* rng, void* v);
private extern expr* sm_listmap(expr* fun, expr* rng, int what);
private extern expr* sm_listcatmap(expr* fun, expr* rng, int what);
private extern expr* sm_foldl(expr* fun, expr* val, expr* rng);
private extern expr* sm_foldl1(expr* fun, expr* rng);
private extern expr* sm_foldr(expr* fun, expr* val, expr* rng);
private extern expr* sm_foldr1(expr* fun, expr* rng);
private extern int   sm_member(expr* map, expr* key);
private extern expr* sm_bounding_keys(expr* rng);
private extern expr* sm_prev_key(expr* map, expr* key);
private extern expr* sm_next_key(expr* map, expr* key);
private extern expr* sm_update(expr* map, expr* key, expr* val);
private extern expr* sm_update_with(expr* map, expr* key, expr* unaryfun);

/*** Global Definitions **************************************************/

namespace ;

public emptystlmap mkstlmap emptystlset mkstlset; 

let stlmap_t, stlmap_iter_t, stlset_t, stlset_iter_t = stl::sm_type_tags;

type stlmap x = check_ptrtag stlmap_t x;     //c++ map
type stlset x = check_ptrtag stlset_t x;     //c++ set 
type stlacon x::stlmap | stlacon x::stlset;  //c++ sorted assoc container

type stlmap_iter x = check_ptrtag stlmap_iter_t x;
type stlset_iter x = check_ptrtag stlset_iter_t x;
type stlacon_iter x::stlmap_iter | stlacon_iter x::stlset_iter;

type stlacon_rng x::stlacon | stlacon_rng (x::stlacon, _);
type stlacon_rng (x::stlmap_iter, y::stlmap_iter);
type stlacon_rng (x::stlset_iter, y::stlset_iter);

namespace stl;

/*** Helpers **************************************************************/

private 
  sm_lower_bound sm_update_with
  sm_iter sm_key sm_val sm_elm 
  sm_merge sm_union sm_difference sm_intersection sm_symmetric_difference 
  sm_less sm_equal compatible_ranges;

const sm_lower_bound = 1;
const sm_upper_bound = 2;
const sm_equal_range = 3;

const sm_key = 1;
const sm_val = 2;
const sm_elm = 3;
const sm_iter = 4;
const sm_iter_dflt = 5;

const sm_merge = 1;
const sm_union = 2;
const sm_difference = 3;
const sm_intersection = 4;
const sm_symmetric_difference = 5;

const sm_at_beginning = 1;
const sm_at_pastend = 2; 

compatible_ranges rng1::stlacon_rng rng2 = 
  if sm_is_set rng1 then sm_is_set rng2 else ~sm_is_set rng2;

/*** Iterators **********************************************************/

iterator pos::stlacon_iter = sm_copy_iter pos;

begin sm::stlacon = sm_begin sm;

pastend sm::stlacon = sm_end sm;

find sm::stlacon key = sm_find sm key sm_iter;

lower_bound sm::stlacon key = sm_bounds sm key sm_lower_bound;

upper_bound sm::stlacon key = sm_bounds sm key sm_upper_bound;

equal_range sm::stlacon key = sm_bounds sm key sm_equal_range;

is_begin pos::stlacon_iter = sm_iter_is_at pos sm_at_beginning;

is_pastend pos::stlacon_iter = sm_iter_is_at pos sm_at_pastend;

get_info pos::stlacon_iter = sm_iter_info pos;

get pos::stlacon_iter = sm_get_at pos sm_elm;     // like *p

get_key pos::stlacon_iter = sm_get_at pos sm_key; // p->first

get_val pos::stlacon_iter = sm_get_at pos sm_val; // p->second

put pos::stlmap_iter val = sm_put_at pos val;

inc pos::stlacon_iter = sm_move_iter pos 1;

dec pos::stlacon_iter = sm_move_iter pos (-1);

move pos::stlacon_iter n::int = sm_move_iter pos n;

/*** Iterator Operators ****************************************************/

(::==) pos1::stlacon_iter pos2::stlacon_iter = sm_equal_iter pos1 pos2;

(::^) sm::stlmap key = sm_find sm key sm_iter_dflt;  // inserts like [k]

/***  Constructors *********************************************************/

::emptystlmap                    = sm_make_empty (<) (<) (==) [] 0;

::mkstlmap (kcmp,dflt,vcmp,veql) = sm_make_empty kcmp vcmp veql dflt 0;
::mkstlmap (kcmp,dflt,vcmp)      = sm_make_empty kcmp vcmp (==) dflt 0;
::mkstlmap (kcmp,dflt)           = sm_make_empty kcmp (<) (==) dflt  0;
::mkstlmap kcmp                  = sm_make_empty kcmp (<) (==) [] 0;

::stlmap xs = sm when
  sm = ::emptystlmap;
  sm_insert_elms_xs sm xs;
end if listp xs || matrixp xs;

::stlmap (STLVEC svp) = sm when
  sm = ::emptystlmap;
  sm_insert_elms_stlvec sm svp;
end;

::stlmap rng::stlacon_rng = sm when
  _,params = sm_container_info rng;
  sm = mkstlmap params;
  sm_insert_elms_stlmap sm rng;
end if ~sm_is_set rng;

::emptystlset = sm_make_empty (<) (<) (==) [] 1;

::mkstlset kcmp = sm_make_empty kcmp (<) (==) [] 1;

::stlset xs = ss when
  ss = ::emptystlset;
  sm_insert_elms_xs ss xs;
end if listp xs || matrixp xs;

::stlset (STLVEC svp) = ss when
  ss = ::emptystlset;
  sm_insert_elms_stlvec ss svp;
end;

::stlset rng::stlacon_rng = ss when
  _,kc,_ = sm_container_info rng;
  ss = mkstlset kc;
  sm_insert_elms_stlmap ss rng;
end if sm_is_set rng;

/*** Info ***************************************************************/

container_info rng::stlacon_rng = sm_container_info rng;

(::#) sm::stlacon = sm_size sm;

empty sm::stlacon = sm_empty sm;

count sm::stlacon key = sm_count sm key;

range_info rng::stlacon_rng = sm_range_info rng;

distance rng::stlacon_rng = sm_size rng;

/*** Range Access ****************************************************/

lazy_map f rng::stlacon_rng = gen first with
  gen i = if sm_equal_iter i last then [] 
          else f (sm_get_elm_at_inc i) : (gen i &);  
end if valid when 
  valid,m,b,last = sm_range_info rng;
  first = sm_copy_iter b;
end;

stream rng::stlacon_rng = gen first with 
  gen i = if sm_equal_iter i last then [] 
          else sm_get_elm_at_inc i : (gen i &);  
end if valid when 
  valid,m,b,last = sm_range_info rng;
  first = sm_copy_iter b;
end;

elms rng::stlacon_rng = sm_listmap 0 rng sm_elm; 

members rng::stlacon_rng = sm_listmap 0 rng sm_elm; 

keys rng::stlacon_rng = sm_listmap 0 rng sm_key;// if ~sm_is_set rng;

vals rng::stlacon_rng = sm_listmap 0 rng sm_val;// if ~sm_is_set rng;

vector rng::stlacon_rng = sm_make_vector rng;

stlvec rng::stlacon_rng = sv if ok when
  sv = emptystlvec;
  ok = case sv of  
    STLVEC v = sm_fill_stlvec rng v $$ 1;
    _ = 0;
  end;
end;

/*** Modifiers *********************************************************/

insert sm::stlacon xs::list = sm_insert_elms_xs sm xs;

insert sm::stlacon xs::matrix = sm_insert_elms_xs sm xs;

insert sm::stlacon rng::stlacon_rng = sm_insert_elms_stlmap sm rng;

insert sm::stlacon (STLVEC svp) = sm_insert_elms_stlvec sm svp;

insert sm::stlmap (elm@(k=>v), pos::stlacon_iter) = 
  sm_insert_hinted sm pos elm;

insert sm::stlmap elm@(k=>v) = sm_insert_elm sm elm;

insert_or_update sm::stlmap (k=>v) = sm_update sm k v $$ sm;

insert_or_update sm::stlset k = sm_insert_elm sm k $$ sm;

insert_or_update_with f sm::stlmap (key=>x) = sm_update_with sm key (f x) $$ sm;

insert sm::stlset (key, pos::stlacon_iter) = sm_insert_hinted sm pos key;

insert sm::stlset key = sm_insert_elm sm key;

insert_elm sm::stlset key = sm_insert_elm sm key; // to get xs, etc into set

erase sm::stlacon = sm_clear sm;

erase (sm::stlacon,i::stlacon_iter, j::stlacon_iter) = sm_erase sm (i,j);

erase (sm::stlacon,pos::stlacon_iter) = sm_erase sm pos;

erase (sm::stlacon,key1,key2) = sm_erase sm (sm,key1,key2);

erase (sm::stlacon,key) = sm_erase sm (sm,key);

swap sm1::stlmap sm2::stlmap = sm_swap sm1 sm2;

swap ss1::stlset ss2::stlset = sm_swap ss1 ss2;

/*** Equality and Lexicographical Comparison ***************************/

equal rng1::stlacon_rng rng2::stlacon_rng = sm_equal rng1 rng2
  if compatible_ranges rng1 rng2;

(::==) sac1::stlacon sac2::stlacon = sm_equal sac1 sac2
  if compatible_ranges sac1 sac2;

(::~=) sac1::stlacon sac2::stlacon = ~sm_equal sac1 sac2
  if compatible_ranges sac1 sac2;

(::<) rng1::stlacon_rng rng2::stlacon_rng = sm_less rng1 rng2
  if compatible_ranges rng1 rng2;

(::<=) rng1::stlacon_rng rng2::stlacon_rng = ~sm_less rng2 rng1
  if compatible_ranges rng1 rng2;

(::>) rng1::stlacon_rng rng2::stlacon_rng = sm_less rng2 rng1
  if compatible_ranges rng1 rng2;

(::>=) rng1::stlacon_rng rng2::stlacon_rng = ~sm_less rng1 rng2
  if compatible_ranges rng1 rng2;

/** STL Set Algorithms ***************************************************/

merge rng1::stlacon_rng rng2::stlacon_rng = 
  sm_setop sm_merge rng1 rng2 if compatible_ranges rng1 rng2;

set_union rng1::stlacon_rng rng2::stlacon_rng = 
  sm_setop sm_union rng1 rng2 if compatible_ranges rng1 rng2;

set_difference rng1::stlacon_rng rng2::stlacon_rng = 
  sm_setop sm_difference rng1 rng2 if compatible_ranges rng1 rng2;

set_intersection rng1::stlacon_rng rng2::stlacon_rng = 
  sm_setop sm_intersection rng1 rng2 if compatible_ranges rng1 rng2;

set_symmetric_difference rng1::stlacon_rng rng2::stlacon_rng = 
  sm_setop sm_symmetric_difference rng1 rng2 if compatible_ranges rng1 rng2;

set_includes rng1::stlacon_rng rng2::stlacon_rng =
  sm_includes rng1 rng2 if compatible_ranges rng1 rng2;

// add find adj ?? some others ??05

/*** Key Oriented Interface Functions *********************************/

/* The key oriented interface allows one to work with stlmaps and stlsets
   without using iterators. If (!key) is applied to a stlmap it returns the
   returns the value of the element with the indicated key, if any, or throws
   an out_of_bounds exception. When applied to a stlset it returns the element
   that is equivalent to the key.

   These functions cache iterators. In addition, insert (for an element),
   insert_or_update, and insert_or_update_with also cache iterators.

*/

(::!) sm::stlacon key = sm_find sm key sm_val;  // no default

get (sm::stlmap,key) = sm_find sm key sm_elm;    // no default, like get . find

put (sm::stlmap,key) val = sm_update sm key val;

has_key sm::stlacon key = sm_member sm key;

bounding_keys rng::stlacon_rng = sm_bounding_keys rng;

next_key sm::stlacon key = sm_next_key sm key;

prev_key sm::stlacon key = sm_prev_key sm key;

/*** Mapping and Folding *************************************************/

::map f rng::stlacon_rng = sm_listmap f rng sm_elm; // => sm_key for sets

::foldl f x rng::stlacon_rng = sm_foldl f x rng;

::foldl1 f rng::stlacon_rng = sm_foldl1 f rng;

::foldr f x rng::stlacon_rng = sm_foldr f x rng;

::foldr1 f rng::stlacon_rng = sm_foldr1 f rng;

::do f rng::stlacon_rng = sm_foldl (\_ x->f x) () rng $$ ();

::filter p rng::stlacon_rng = sm_foldr f [] rng with
  f x xs = res when
    res = case p x of
      1 = x:xs;
      0 = xs;
      y = throw failed_cond;
    end;
  end;
end;

::listmap f rng::stlacon_rng = sm_listmap f rng sm_elm;

::catmap f rng::stlacon_rng = sm_listcatmap f rng sm_elm;

::rowmap f rng::stlacon_rng = rowcat (sm_listmap f rng sm_elm);

::rowcatmap f rng::stlacon_rng = rowcat (sm_listmap f rng sm_elm);

::colmap f rng::stlacon_rng = colcat (sm_listmap f rng sm_elm);

::colcatmap f rng::stlacon_rng = colcat (sm_listmap f rng sm_elm);

