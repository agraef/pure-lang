/* stlhmap.pure: Pure interface to C++ STL unordered_map
    
--- DRAFT - FOR DISCUSSON PURPOSES ONLY ---

Copyright (c) 2011 by Peter Summerland <p.summerland@gmail.com>.

All rights reserved.

This software is is part of pure-stlmap, an addon to the Pure Programming
Language (http://code.google.com/p/pure-lang/).

This software is distributed under a BSD-style license in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the COPYING file
included with the pure-stlmap distribution package for details.

*/
 
using stlbase;
using "lib:stlassoc";

namespace stl;

/*** C++ support **********************************************************/

extern expr* sh_type_tags();
extern expr* sh_make_empty(int ko);
extern expr* sh_copy(expr* pxshp);

private extern void  sh_delete(void* shmapp);

// These are the fastest way to access
extern void  sh_reserve(expr* pxshp, double mlf, int size);
extern expr* sh_info(expr* pxshp);
extern int   sh_bucket_size(expr* pxshp, int bucket_pos);
extern int   sh_size(expr* pxshp);
extern bool  sh_empty(expr* pxshp);
extern bool  sh_is_set(expr* pxshp);
extern int   sh_equal(expr* pxshp1, expr* pxshp2);
extern int   sh_count(expr* pxshp, expr* key);
extern int   sh_member(stlhmap* pxshp, expr* key);
extern expr* sh_find(expr* pxshp, expr* key, int what);
extern expr* sh_find_val(stlhmap* pxshp, expr* key);
extern int   sh_insert(expr* pxshp, expr* src, bool replace);
extern expr* sh_insert_stlhmap(expr* pxshp, bool replace);
extern int   sh_insert_stlvec(expr* map, void* svp, bool replace);
extern expr* sh_replace(expr* pxshp, expr* key, expr* val);
extern void  sh_swap(expr* pxshp1, expr* pxshp2);
extern int   sh_erase(expr* pxshp, expr* key);
extern int   sh_clear(expr* pxshp);
extern expr* sh_make_vector(expr* pxshp);
extern void* sh_fill_stlvec(expr* rng, void* v);

extern expr* sh_listmap(expr* fun, expr* pxshp, int what);
extern expr* sh_listcatmap(expr* fun, expr* pxshp, int what);
extern expr* sh_foldl(expr* fun, expr* val, expr* pxshp);
extern expr* sh_foldl1(expr* fun, expr* pxshp);
extern void  sh_do(expr* fun, expr* pxshp);

/*** Global Definitions **************************************************/

namespace ;

public emptystlhmap emptystlhset member members erase 
  insert_or_replace replace;

let stlhmap_t = stl::sh_type_tags;

type stlhmap x::pointer = check_ptrtag stlhmap_t x;
type stlhset x::pointer = check_ptrtag stlhmap_t x && stl::sh_is_set x;

/*** Experiment *********************************************************/

nonfix STLHMAP;

wrap x = STLHMAP x;

(!) (STLHMAP hm) key = stl::sh_find_val hm key;

member (STLHMAP hm) key = stl::sh_member hm key;

w_find (STLHMAP hm) key = stl::sh_find_val hm key;

w_member (STLHMAP hm) key = stl::sh_member hm key;

p_find hm key = stl::sh_find_val hm key;

p_member hm key = stl::sh_member hm key;

extern int   x_sh_member(stlhmap* pxshp, expr* key) = x_member;

extern expr* x_sh_find_val(stlhmap* pxshp, expr* key) = x_find;


namespace stl;

/*** Helpers **************************************************************/

private sh_key_flag sh_val_flag sh_elm_flag compatible_ranges;

const sh_key_flag = 1;
const sh_val_flag = 2;
const sh_elm_flag = 3;

compatible c1 c2 = if sh_is_set c1 then sh_is_set c2 else ~sh_is_set c2; 

/***  Constructors *********************************************************/

::emptystlhmap = sh_make_empty 0;

::stlhmap xs = hm when
  hm = ::emptystlhmap;
  sh_insert hm xs 0;
end if listp xs || matrixp xs;

::stlhmap (STLVEC svp) = hm when
  hm = ::emptystlhmap;
  sh_insert_stlvec hm svp 0;
end;

::stlhmap hm::stlhmap = sh_copy hm if ~sh_is_set hm;

::emptystlhset = sh_make_empty 1;

::stlhset xs = hs when
  hs = ::emptystlhset;
  sh_insert hs xs 0;
end if listp xs || matrixp xs;

::stlhset (STLVEC svp) = hs when
  hs = ::emptystlhset;
  sh_insert_stlvec hs svp 0;
end;

::stlhset hs::stlhset = sh_copy hs;

hmap_reserve hm::stlhmap mlf::double size::int = sh_reserve hm mlf size;

/*** Info ***************************************************************/

(::#) hm::stlhmap = sh_size hm;

empty hm::stlhmap = sh_empty hm;

container_info hm::stlhmap = sh_info hm;

bucket_size hm::stlhmap i::int = sh_bucket_size hm i;

count hm::stlhmap key = sh_count hm key;

::member hm::stlhmap key = stl::sh_member hm key;

/*** Access *************************************************************/

(::!) hm::stlhmap key = sh_find_val hm key;

::get (hm::stlhmap,key) = sh_find hm key sh_elm_flag; 

::members hm::stlhmap = sh_listmap 0 hm sh_elm_flag;

::keys hm::stlhmap = sh_listmap 0 hm sh_key_flag;

::vals hm::stlhmap = sh_listmap 0 hm sh_val_flag;

vector hm::stlhmap = sh_make_vector hm;

::stlvec hm::stlhmap = sv if ok when
  sv = emptystlvec;
  ok = case sv of  
    STLVEC v = sh_fill_stlvec hm v $$ 1;
    _ = 0;
  end;
end;

/*** Modifiers *********************************************************/

::insert hm::stlhmap (STLVEC svp) = sh_insert_stlvec hm svp 0;

::insert hm::stlhmap src::stlhmap = 
  sh_insert_stlhmap hm src 0 if compatible hm src;

::insert hm::stlhmap src = sh_insert hm src 0;

::insert_or_replace hm::stlhmap (STLVEC svp) = 
  sh_insert_stlvec hm svp 1 if ~sh_is_set hm;

::insert_or_replace hm::stlhmap src::stlhmap = 
  sh_insert_stlhmap hm src 1 if ~sh_is_set hm && ~sh_is_set src;

::insert_or_replace hm::stlhmap src = sh_insert hm src 1 if ~sh_is_set hm;

::replace hm::stlhmap key v = sh_replace hm key v;

::erase hm::stlhmap = sh_clear hm;

::erase (hm::stlhmap,key) = sh_erase hm key;

swap hm1::stlhmap hm2::stlhmap = sh_swap hm1 hm2 if compatible hm1 hm2;

/*** Equality **********************************************************/

(::==) c1::stlhmap c2::stlhmap = sh_equal c1 c2 if compatible c1 c2;

(::~=) c1::stlhmap c2::stlhmap = ~sh_equal c1 c2 if compatible c1 c2;

/*** Mapping ***********************************************************/

::map f hm::stlhmap = sh_listmap f hm sh_elm_flag;

::foldl f x hm::stlhmap = sh_foldl f x hm;

::foldl1 f hm::stlhmap = sh_foldl1 f hm;

::do f hm::stlhmap = sh_do f hm;

::filter p hm::stlhmap = sh_listcatmap f hm sh_elm_flag with
  f x = res when
    res = case p x of
      1 = [x];
      0 = [];
      y = throw failed_cond;
    end;
  end;
end;

::listmap f hm::stlhmap = sh_listmap f hm sh_elm_flag;

::catmap f hm::stlhmap = sh_listcatmap f hm sh_elm_flag;

::rowmap f hm::stlhmap = rowcat (sh_listmap f hm sh_elm_flag);

::rowcatmap f hm::stlhmap = rowcat (sh_listmap f hm sh_elm_flag);

::colmap f hm::stlhmap = colcat (sh_listmap f hm sh_elm_flag);

::colcatmap f hm::stlhmap = colcat (sh_listmap f hm sh_elm_flag);

