
pd-pure: Pd loader for Pure scripts
======== == ====== === ==== =======

Copyright (c) 2008 by Albert Graef <Dr.Graef@t-online.de>
Distributed under the GNU Public License V3, see COPYING for details.

This plugin lets you write external Pd control objects in Pure. Pure is a
functional programming language based on the term rewriting calculus, see
http://pure-lang.googlecode.com.

This is still an experimental version, please report bugs to the author.

In particular, note that the embedded Pure interpreter uses the same kind of
JIT compiler as the command line version, which may cause annoying delays
during startup, since the Pure functions are compiled by the JIT when they are
first used. (However, once all Pure objects have been compiled to native code,
they are executed very efficiently.) With the current version of the LLVM JIT
used by the Pure interpreter there's no easy way around this, but we hope to
fix this issue in a future release.

Installation
============

Usually, 'make && sudo make install' should do the trick. This will compile
the external (you need to have both Pd and Pure installed to do that) and
install it in the lib/pd/extra/pure directory.

The Makefile tries to guess the installation prefix under which Pd is
installed. If it guesses wrong, you can tell it the right prefix with 'make
prefix=/some/path'. Or you can specify the exact path of the lib/pd/extra
directory with 'make pdextradir=/some/path' (by default the Makefile assumes
$(prefix)/lib/pd/extra).

After installation, you still have to tell Pd to load the Pure external at
startup, either with the -lib option (pd -lib pure), or by specifying 'pure'
in the File/Startup options. (The latter setting can be saved so that the Pure
loader is always available when you run Pd.)

Usage
=====

See the pure-help.pd patch for a few examples. Basically, to implement a Pd
object named 'foo', you have to supply a Pure script named 'foo.pure' which
defines a function 'foo' and anything else that it might need. Put that script
in the same directory as the Pd patch in which you want to use the 'foo'
object. The 'foo' function gets evaluated at object creation time, receiving
any additional parameters the object is created with. The resulting Pure
expression (which can also just be 'foo' itself) becomes the object executed
at runtime, by passing Pd messages from the inlets as parameters, and routing
the function results to the outlets of the object.

Pd messages are translated to corresponding Pure expressions and vice versa in
a straightforward fashion. Special support is provided for converting between
the natural Pd and Pure representations of floating point numbers, symbols and
lists. The following table summarizes the available conversions.

Message Type	Pd		Pure
------------	------------	--------------
symbol		foo		foo
		a&b		"a&b"
float		float 1.23	1.23
list		list 1 2 3	[1.0,2.0,3.0]
other		foo a 2 3	foo a 2.0 3.0

Note that Pd symbols which are no valid Pure symbols become strings in
Pure. Conversely, both symbols and strings in Pure are mapped to corresponding
Pd symbols. Pure (machine) integers and floating point values both become
'float' messages in Pd. Pd list messages are translated to Pure list values,
while other aggregate messages are mapped to Pure applications (and vice
versa).

Simple Objects
====== =======

By default, a Pure object has just one inlet and one outlet and thus acts like
a simple function with no internal state. For instance, the following object
accepts Pd 'float' messages and adds 5 to each received value:

add5 x = x+5;

In the Pd patch each [add5] object then has a single inlet supplying
parameters and a single outlet for results of the add5 function.

Creation Arguments
======== =========

You can parameterize an object with creation arguments, which are passed to
the Pure function at object creation time. For instance:

add x y = x+y;

This object can then be invoked, e.g., as [add 5] in the Pd patch to supply
the needed creation argument x.

The [pure] Object
=== ====== ======

For simple kinds of objects like these, the Pure loader also provides the
generic [pure] object as a quick means to create Pure objects without actually
preparing a script file. The creation parameter of [pure] is the object
function. This can be a predefined Pure function, or you can define it on the
fly in a 'with' clause.

For instance, [pure succ] uses the predefined Pure function 'succ' which adds
1 to its input, while the object [pure add 5 with add x y = x+y end] produces
the same results as the [add 5] object defined using a separate add.pure
script in the previous section. You can also generate constant values that
way. E.g., the object [pure cst 1.618] responds to any message (such as
'bang') by producing the constant value 1.618, while the object [pure cst
[1..10]] yields the constant list containing the numbers 1..10.

Configuring Inlets and Outlets
=========== ====== === =======

To create an object with multiple inlets and outlets, the object creation
function must return the desired numbers of inlets and outlets, along with a
second function to be applied at runtime, as a tuple n,m,foo. The input
arguments to the runtime function as well as the corresponding function
results are then encoded as pairs k,val where k denotes the inlet or outlet
index. (Note that the k index is provided only if there actually is more than
one inlet. Also, the outlet index is assumed to be zero if none is specified,
so that it can be omitted if there's only one outlet.)

For instance, the following object, invoked as [cross] in the Pd patch, has
two inlets and two outlets and routes messages from the left inlet to the
right outlet and vice versa.

cross = 2,2,cross with cross (k,x) = (1-k,x) end;

You can also emit multiple messages, possibly to different outlets, in one
go. These must be encoded as lists of values or index,value pairs, which are
emitted in the order in which they are written. E.g., the following [fan]
object implements an "n-fan" which routes its input to n outlets
simultaneously:

fan n = 1,n,fan n with fan n x = reverse [k,x | k = 0..n-1] end;

(Note that, because of the use of the 'reserve', the n outlets are served in
right-to-left order here. This is not strictly necessary, but matches the Pd
convention.)

Another example is the following [dup] object with a single inlet and outlet,
which just sends out each received message twice:

dup x = [x,x];

Note that if you want to output a *real* list value to an outlet, you'll
either have to specify the outlet index explicitly, or enclose the list in an
extra pair of brackets, since otherwise the list elements will be sent as
separate messages instead (like in the 'dup' example). Thus, to output the
list [x,x] literally, rather than sending x twice, use the following code:

dup2 x = [[x,x]]; // or: 0,[x,x]

An object can also just "swallow" messages and generate no output at all. To
these ends, make the object return either an empty list [] or the empty tuple
(). For instance, the following object [echo] implements a sink which just
prints received messages on standard output, which is useful for debugging
purposes:

using system;
echo x = () when puts (str x) end;

You could also implement this object as follows, by just removing the
superflous outlet (in this case all return values from the function will be
ignored anyway):

using system;
echo = 1,0,puts.str;

Local State
===== =====

Local state can be kept in Pure reference values. For instance, the following
[counter] object produces the next counter value when receiving a 'bang'
message:

nullary bang;
counter = next (ref 0) with
  next r bang = put r (get r+1);
  next _ _    = () otherwise;
end;

Asynchronous Messages
============ ========

pd-pure provides a simple asynchronous messaging facility which allows a Pure
object to schedule a message to be delivered to itself later. This is useful
for implementing all kinds of delays and, more generally, any kind of object
which, once triggered, does its own sequencing of output messages.

To these ends, the object function may return a special message of the form
'delay t msg' (either by itself or as an element of a result list) to indicate
that the message 'msg' should be delivered to the object function after t
milliseconds (where t is either a machine int or a double value). After the
prescribed delay the object function will then be invoked on the given
message, and the results of this call are processed as usual (routing messages
to outlets and/or scheduling new timer events in response to further 'delay'
messages). Note that if the delay is zero or negative, the message is
scheduled to be delivered immediately.

For instance, a simple kind of delay object can be implemented in Pure as
follows:

mydelay _ (alarm msg) = msg;
mydelay t msg = delay t (alarm msg) otherwise;

The desired delay time is specified as a creation argument. The first equation
handles messages of the form 'alarm msg'; the action is to just output the
delayed message given by the 'msg' argument. All other input messages are
scheduled by the second equation, which wraps the message in an 'alarm' term
so that it gets processed by the first equation when it is delivered.

Note that pd-pure only allows you to schedule a single asynchronous event per
call of the object function. Thus, if the 'mydelay' object above receives
another message while it is still waiting for the previous one to be
delivered, the old timer is cancelled and the new one is scheduled instead;
this works like Pd's builtin 'delay' object.

Moreover, scheduling a new event at an infinite (or nan) time value cancels
any existing timer. (Note that you still have to specify the 'msg' parameter,
but it will be ignored in this case.) We can use this to equip our 'mydelay'
object with a 'stop' message as follows:

nullary stop;
mydelay _ (alarm msg) = msg;
mydelay _ stop = delay inf ();
mydelay t msg = delay t (alarm msg) otherwise;

More elaborate functionality can be built on top of the basic timer
facility. The following example shows how to maintain a timed message queue in
a Pure list, in order to implement a simple delay line similar to Pd's builtin
'pipe' object. Here we also employ the 'pd_time' function, which is provided
by the Pure loader so that Pure scripts can access the current logical Pd time
in milliseconds. This is convenient if we need to deal with absolute time
values, which we use in this example to keep track of the times at which
messages in the queue are to be delivered.

extern double pd_time();
mypipe t = process (ref []) with
  process q () = case dequeue q of
                   x,(t,_):_ = [x,delay (t-pd_time) ()];
                   x,_ = x;
                 end;
  process q x  = enqueue q x $$ delay t () if null (get q);
               = enqueue q x $$ () otherwise;
  enqueue q x  = put q $ get q+[(pd_time+t,x)];
  dequeue q    = x,put q xs when (_,x):xs = get q end;
end;

Livecoding Support
========== =======

Livecoding means that you can quickly reload your Pure scripts after changes
while the Pd patch keeps running. The Pure loader provides some experimental
support for this by means of a special 'pure' receiver object. Sending the
message 'reload' to this object tells the plugin to reload all loaded scripts
and update the Pure objects in your patch accordingly.

You can find a sample patch pure-remote.pd, which you can include in your
patches to send the 'reload' message remotely (e.g., using the pdsend
program), in the pd-pure sources. (You can also trigger a reload by just
clicking the bang control of the abstraction.) There's also an accompanying
elisp program (pure-remote.el) which contains some convenient keybindings for
the necessary pdsend invocations, so that you can operate the pure-remote
patch with simple keystrokes directly from Emacs. Please see the patch and
elisp file for more details.

Also please note the following limitations in the current implementation:

- The 'reload' message just starts up a new interpreter instance, which, due
to the hiccups with interpreter startup mentioned at the beginning of this
file, is not as smooth as we'd like it to be. But it's currently as close to
livecoding with Pure as it gets. We hope to improve this in the future.

- The number of inlets and outlets of Pure objects never changes after a
'reload' message. (Pd doesn't support this through its API right now.) Thus by
editing and reloading the Pure scripts you can change the functionality of
existing objects at runtime, but not their interfaces.


Enjoy. :)
Albert Graef <Dr.Graef@t-online.de>
