
using system;

/* Gnumeric function descriptions. These are optional, but needed if you want
   to tell Gnumeric about the parameters the function is to be invoked with,
   and/or the help text to be displayed for the function.

   To describe a given function to Gnumeric, all you have to do is to define
   gnm_info "<name>" (where <name> is the name of the function) as either:

   - A pair of strings. The first string gives the parameter types (e.g., "f"
     for a single float parameter), the second one is a list of parameter
     names (e.g., "x,y,z"). Optional parameters can be indicated using '|', as
     in "ff|s" (two non-optional floats, followed by an optional string).

   - Just a help string, in the format indicated below.

   - Both parameter types/names and help string, as a triple.

   Here's the list of valid parameter types, straight from the
   writing-functions.sgml file in the Gnumeric sources.

    b : boolean		identical to f
    f : float 		no errors, string conversion attempted, blanks
			converted to int 0
    s : string		no errors, blanks accepted and passed as empty
    S : scalar		any scalar non-error, blanks passed as empty
    E : scalar		any scalar non blank value
    B : scalar		any scalar even a blank

    r : cell range	content is _NOT_ guaranteed to have been evaluated yet
    A : area		array, range, (range as above), or scalar
    a : array
    ? : anything

   Marshalling between Gnumeric and Pure values is pretty straightforward:

   Pure                   Gnumeric
   -------------------    -------------------------------
   ()                     empty
   4711, 4711L, 4711.0    scalar (number)
   "Hello world"          string
   [1,2,3]                array
   {1,2,3;4,5,6}          array (or cell range)

   Note that on input, cell ranges are always passed as matrices to Pure
   functions (not the cell references themselves). Conversely, both matrices
   and lists become Gnumeric arrays on output. The empty tuple can be used to
   denote empty Gnumeric values.

   If no parameter types/names are given, then the function accepts any number
   of parameters of any type, so your function definition must be prepared to
   handle that. In that case, or if there are optional parameters, the
   function becomes *variadic* and the (optional) parameters are passed as a
   Pure list (in addition to the non-optional parameters).

   See below for some examples. Note that if no description is given then the
   function defaults to variadic and no help text will be available. */

gnm_info "pure_hello" = "|s", "name", sprintf "@FUNCTION=pure_hello\n\
@SYNTAX=pure_hello(name)\n\
@DESCRIPTION=\
This function demonstrates the Gnumeric/Pure interface. The function takes an optional string parameter @name. It formats a little text and returns it as a string.\n\n\
* Gnumeric/Pure is (c) 2009 by Albert Gr√§f, distributed under the GPL V3.\n\
* You're running Pure version %s.\n"
version;

gnm_info "pure_max" = "ff", "x,y", "@FUNCTION=pure_max\n\
@SYNTAX=pure_max(x,y)\n\
@DESCRIPTION=\
Computes the maximum of two numbers @x and @y. This is an example of a function of fixed arity, where arguments are passed in curried form.\n";

gnm_info "pure_sum" = "@FUNCTION=pure_sum\n\
@SYNTAX=pure_sum(...)\n\
@DESCRIPTION=\
Computes the sum of a collection of numbers, using Pure's foldl. Takes any number of scalars or ranges as parameters. This is an example of a variadic function, where arguments are passed as a Pure list.\n";

gnm_info "pure_sums" = "@FUNCTION=pure_sums\n\
@SYNTAX=pure_sums(...)\n\
@DESCRIPTION=\
Computes the partial sums of a collection of numbers, using Pure's scanl. Takes any number of scalars or ranges as parameters. Returns a Pure list of the results, which becomes an array in Gnumeric land, so you'll have to enter this as an array function.\n";

gnm_info "pure_echo" = "@FUNCTION=pure_echo\n\
@SYNTAX=pure_echo(...)\n\
@DESCRIPTION=\
This simply echoes all given arguments as a string in Pure syntax, as Pure sees them. Useful for debugging purposes.\n";

gnm_info "pure_eval" = "@FUNCTION=pure_eval\n\
@SYNTAX=pure_eval(x,...)\n\
@DESCRIPTION=\
Evaluates a Pure expression, given as a string x. Any remaining parameters are available in the evaluated code as a list 'x', so 'x!0' denotes the first argument, x!1 the second, etc. This lets you evaluate any Pure code in a spreadsheet without first having to define a function for it.\n";

gnm_info "gnm_bitand" = "ff", "x,y", "@FUNCTION=gnm_bitand\n\
@SYNTAX=gnm_bitand(x,y)\n\
@DESCRIPTION=\
Computes the bitwise and of two numbers @x and @y, using the corresponding Gnumeric function. This example shows how to call Gnumeric functions from Pure.\n";

namespace pure_func;

/* Helper function to collect the values in a list of scalars and ranges or
   arrays in a single list. */

private ranges;
ranges xs = cat [ case x of _::matrix = list x; _ = [x] end | x = xs ];

/* The actual Pure function definitions. These must match the descriptions
   given above. */

pure_hello []  = sprintf "Hi Gnumeric, this is Pure %s." version;
pure_hello [s] = sprintf "Hi %s, this is Pure %s." (s,version);

pure_max x y = max x y;
pure_sum xs = foldl (+) 0 (ranges xs);
pure_sums xs = scanl (+) 0 (ranges xs);

pure_echo xs = str $ tuple xs;

pure_eval (s::string:args) =
  case eval (sprintf "'[%s]" s) of
    [y] = eval (reduce y) with x = args end;
    _ = throw "pure_eval: syntax error";
  end;

/* This example shows how to call Gnumeric functions from Pure. This is done
   using the following external defined in the Pure plugin loader. The
   arguments must be given as a list of Pure expressions which can be
   converted to Gnumeric values ((), numbers, strings, lists and matrices). */

extern expr* call_gnm_function(char* name, expr* args);

gnm_bitand x y = call_gnm_function "bitand" [x,y];

namespace;

/* Just add your own definitions below. (You also have to add the function
   names to plugin.xml to have them show up in Gnumeric.) */
