/* /usr/include/sndfile.h: */
using "lib:sfinfo";
const SF_STR_FIRST = 1;
const SF_STR_LAST = 16;
const SF_FORMAT_WAV = 65536;
const SF_FORMAT_AIFF = 131072;
const SF_FORMAT_AU = 196608;
const SF_FORMAT_RAW = 262144;
const SF_FORMAT_PAF = 327680;
const SF_FORMAT_SVX = 393216;
const SF_FORMAT_NIST = 458752;
const SF_FORMAT_VOC = 524288;
const SF_FORMAT_IRCAM = 655360;
const SF_FORMAT_W64 = 720896;
const SF_FORMAT_MAT4 = 786432;
const SF_FORMAT_MAT5 = 851968;
const SF_FORMAT_PVF = 917504;
const SF_FORMAT_XI = 983040;
const SF_FORMAT_HTK = 1048576;
const SF_FORMAT_SDS = 1114112;
const SF_FORMAT_AVR = 1179648;
const SF_FORMAT_WAVEX = 1245184;
const SF_FORMAT_SD2 = 1441792;
const SF_FORMAT_FLAC = 1507328;
const SF_FORMAT_CAF = 1572864;
const SF_FORMAT_WVE = 1638400;
const SF_FORMAT_OGG = 2097152;
const SF_FORMAT_MPC2K = 2162688;
const SF_FORMAT_RF64 = 2228224;
const SF_FORMAT_PCM_S8 = 1;
const SF_FORMAT_PCM_16 = 2;
const SF_FORMAT_PCM_24 = 3;
const SF_FORMAT_PCM_32 = 4;
const SF_FORMAT_PCM_U8 = 5;
const SF_FORMAT_FLOAT = 6;
const SF_FORMAT_DOUBLE = 7;
const SF_FORMAT_ULAW = 16;
const SF_FORMAT_ALAW = 17;
const SF_FORMAT_IMA_ADPCM = 18;
const SF_FORMAT_MS_ADPCM = 19;
const SF_FORMAT_GSM610 = 32;
const SF_FORMAT_VOX_ADPCM = 33;
const SF_FORMAT_G721_32 = 48;
const SF_FORMAT_G723_24 = 49;
const SF_FORMAT_G723_40 = 50;
const SF_FORMAT_DWVW_12 = 64;
const SF_FORMAT_DWVW_16 = 65;
const SF_FORMAT_DWVW_24 = 66;
const SF_FORMAT_DWVW_N = 67;
const SF_FORMAT_DPCM_8 = 80;
const SF_FORMAT_DPCM_16 = 81;
const SF_FORMAT_VORBIS = 96;
const SF_ENDIAN_FILE = 0;
const SF_ENDIAN_LITTLE = 268435456;
const SF_ENDIAN_BIG = 536870912;
const SF_ENDIAN_CPU = 805306368;
const SF_FORMAT_SUBMASK = 65535;
const SF_FORMAT_TYPEMASK = 268369920;
const SF_FORMAT_ENDMASK = 805306368;
const SFC_GET_LIB_VERSION = 4096;
const SFC_GET_LOG_INFO = 4097;
const SFC_GET_CURRENT_SF_INFO = 4098;
const SFC_GET_NORM_DOUBLE = 4112;
const SFC_GET_NORM_FLOAT = 4113;
const SFC_SET_NORM_DOUBLE = 4114;
const SFC_SET_NORM_FLOAT = 4115;
const SFC_SET_SCALE_FLOAT_INT_READ = 4116;
const SFC_SET_SCALE_INT_FLOAT_WRITE = 4117;
const SFC_GET_SIMPLE_FORMAT_COUNT = 4128;
const SFC_GET_SIMPLE_FORMAT = 4129;
const SFC_GET_FORMAT_INFO = 4136;
const SFC_GET_FORMAT_MAJOR_COUNT = 4144;
const SFC_GET_FORMAT_MAJOR = 4145;
const SFC_GET_FORMAT_SUBTYPE_COUNT = 4146;
const SFC_GET_FORMAT_SUBTYPE = 4147;
const SFC_CALC_SIGNAL_MAX = 4160;
const SFC_CALC_NORM_SIGNAL_MAX = 4161;
const SFC_CALC_MAX_ALL_CHANNELS = 4162;
const SFC_CALC_NORM_MAX_ALL_CHANNELS = 4163;
const SFC_GET_SIGNAL_MAX = 4164;
const SFC_GET_MAX_ALL_CHANNELS = 4165;
const SFC_SET_ADD_PEAK_CHUNK = 4176;
const SFC_SET_ADD_HEADER_PAD_CHUNK = 4177;
const SFC_UPDATE_HEADER_NOW = 4192;
const SFC_SET_UPDATE_HEADER_AUTO = 4193;
const SFC_FILE_TRUNCATE = 4224;
const SFC_SET_RAW_START_OFFSET = 4240;
const SFC_SET_DITHER_ON_WRITE = 4256;
const SFC_SET_DITHER_ON_READ = 4257;
const SFC_GET_DITHER_INFO_COUNT = 4258;
const SFC_GET_DITHER_INFO = 4259;
const SFC_GET_EMBED_FILE_INFO = 4272;
const SFC_SET_CLIPPING = 4288;
const SFC_GET_CLIPPING = 4289;
const SFC_GET_INSTRUMENT = 4304;
const SFC_SET_INSTRUMENT = 4305;
const SFC_GET_LOOP_INFO = 4320;
const SFC_GET_BROADCAST_INFO = 4336;
const SFC_SET_BROADCAST_INFO = 4337;
const SFC_GET_CHANNEL_MAP_INFO = 4352;
const SFC_SET_CHANNEL_MAP_INFO = 4353;
const SFC_RAW_DATA_NEEDS_ENDSWAP = 4368;
const SFC_WAVEX_SET_AMBISONIC = 4608;
const SFC_WAVEX_GET_AMBISONIC = 4609;
const SFC_SET_VBR_ENCODING_QUALITY = 4864;
const SFC_TEST_IEEE_FLOAT_REPLACE = 24577;
const SFC_SET_ADD_DITHER_ON_WRITE = 4208;
const SFC_SET_ADD_DITHER_ON_READ = 4209;
const SF_STR_TITLE = 1;
const SF_STR_COPYRIGHT = 2;
const SF_STR_SOFTWARE = 3;
const SF_STR_ARTIST = 4;
const SF_STR_COMMENT = 5;
const SF_STR_DATE = 6;
const SF_STR_ALBUM = 7;
const SF_STR_LICENSE = 8;
const SF_STR_TRACKNUMBER = 9;
const SF_STR_GENRE = 16;
const SF_FALSE = 0;
const SF_TRUE = 1;
const SFM_READ = 16;
const SFM_WRITE = 32;
const SFM_RDWR = 48;
const SF_AMBISONIC_NONE = 64;
const SF_AMBISONIC_B_FORMAT = 65;
const SF_ERR_NO_ERROR = 0;
const SF_ERR_UNRECOGNISED_FORMAT = 1;
const SF_ERR_SYSTEM = 2;
const SF_ERR_MALFORMED_FILE = 3;
const SF_ERR_UNSUPPORTED_ENCODING = 4;
const SF_CHANNEL_MAP_INVALID = 0;
const SF_CHANNEL_MAP_MONO = 1;
const SF_CHANNEL_MAP_LEFT = 2;
const SF_CHANNEL_MAP_RIGHT = 3;
const SF_CHANNEL_MAP_CENTER = 4;
const SF_CHANNEL_MAP_FRONT_LEFT = 5;
const SF_CHANNEL_MAP_FRONT_RIGHT = 6;
const SF_CHANNEL_MAP_FRONT_CENTER = 7;
const SF_CHANNEL_MAP_REAR_CENTER = 8;
const SF_CHANNEL_MAP_REAR_LEFT = 9;
const SF_CHANNEL_MAP_REAR_RIGHT = 10;
const SF_CHANNEL_MAP_LFE = 11;
const SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER = 12;
const SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER = 13;
const SF_CHANNEL_MAP_SIDE_LEFT = 14;
const SF_CHANNEL_MAP_SIDE_RIGHT = 15;
const SF_CHANNEL_MAP_TOP_CENTER = 16;
const SF_CHANNEL_MAP_TOP_FRONT_LEFT = 17;
const SF_CHANNEL_MAP_TOP_FRONT_RIGHT = 18;
const SF_CHANNEL_MAP_TOP_FRONT_CENTER = 19;
const SF_CHANNEL_MAP_TOP_REAR_LEFT = 20;
const SF_CHANNEL_MAP_TOP_REAR_RIGHT = 21;
const SF_CHANNEL_MAP_TOP_REAR_CENTER = 22;
const SF_CHANNEL_MAP_AMBISONIC_B_W = 23;
const SF_CHANNEL_MAP_AMBISONIC_B_X = 24;
const SF_CHANNEL_MAP_AMBISONIC_B_Y = 25;
const SF_CHANNEL_MAP_AMBISONIC_B_Z = 26;
const SF_CHANNEL_MAP_MAX = 27;
const SFD_DEFAULT_LEVEL = 0;
const SFD_CUSTOM_LEVEL = 1073741824;
const SFD_NO_DITHER = 500;
const SFD_WHITE = 501;
const SFD_TRIANGULAR_PDF = 502;
const SF_LOOP_NONE = 800;
const SF_LOOP_FORWARD = 801;
const SF_LOOP_BACKWARD = 802;
const SF_LOOP_ALTERNATING = 803;
extern int sf_error(SNDFILE*);
extern char* sf_strerror(SNDFILE*);
extern char* sf_error_number(int);
extern int sf_perror(SNDFILE*);
extern int sf_error_str(SNDFILE*, char*, long);
extern int sf_command(SNDFILE*, int, void*, int);
extern int sf_format_check(SF_INFO*);
extern int sf_seek(SNDFILE*, int, int);
extern int sf_set_string(SNDFILE*, int, char*);
extern char* sf_get_string(SNDFILE*, int);
extern char* sf_version_string();
extern int sf_read_raw(SNDFILE*, void*, int);
extern int sf_write_raw(SNDFILE*, void*, int);
extern int sf_readf_short(SNDFILE*, short*, int);
extern int sf_writef_short(SNDFILE*, short*, int);
extern int sf_readf_int(SNDFILE*, int*, int);
extern int sf_writef_int(SNDFILE*, int*, int);
extern int sf_readf_float(SNDFILE*, float*, int);
extern int sf_writef_float(SNDFILE*, float*, int);
extern int sf_readf_double(SNDFILE*, double*, int);
extern int sf_writef_double(SNDFILE*, double*, int);
extern int sf_read_short(SNDFILE*, short*, int);
extern int sf_write_short(SNDFILE*, short*, int);
extern int sf_read_int(SNDFILE*, int*, int);
extern int sf_write_int(SNDFILE*, int*, int);
extern int sf_read_float(SNDFILE*, float*, int);
extern int sf_write_float(SNDFILE*, float*, int);
extern int sf_read_double(SNDFILE*, double*, int);
extern int sf_write_double(SNDFILE*, double*, int);
extern void sf_write_sync(SNDFILE*);
/* sfinfo.h: */
extern char* sf_get_version();
extern SF_INFO* sf_make_info(int, int, int);
extern SF_INFO* sf_new_info();
extern expr* sf_get_info(SF_INFO*);
extern SF_FORMAT_INFO* sf_make_format_info(int);
extern expr* sf_get_format_info(SF_FORMAT_INFO*);

// Some convenience functions.

extern void __sndfile_defs(); __sndfile_defs;

// Wrappers around sf_open, sf_open_fd and sf_close to provide for
// auto-collecting SNDFILE* pointers.

namespace __C with
extern SNDFILE* sf_open(char*, int, SF_INFO*);
extern SNDFILE* sf_open_fd(int, int, SF_INFO*, int);
extern int sf_close(SNDFILE*);
end;

sf_open name::string mode::int info::pointer
  = if null sf then sf else sentry __C::sf_close sf if pointerp sf
    when sf = __C::sf_open name mode info end;

sf_open_fd fd::int mode::int info::pointer close_desc::int
  = if null sf then sf else sentry __C::sf_close sf if pointerp sf
    when sf = __C::sf_open_fd fd mode info close_desc end;

sf_close sf::pointer = __C::sf_close $ clear_sentry sf
  if get_sentry sf === __C::sf_close;

// Create an auto-collecting SF_INFO structure for use with sf_open.

sf_info () = cooked sf_new_info;
sf_info (samplerate::int, channels::int, format::int) =
  cooked $ sf_make_info samplerate channels format;

// Create an auto-collecting SF_FORMAT_INFO structure for use with sf_command.

sf_format_info format::int = cooked $ sf_make_format_info format;

// Get the info for the given format id.

sf_get_format_info format::int = sf_get_format_info info if res==0 when
  info = sf_format_info format;
  res = sf_command NULL SFC_GET_FORMAT_INFO info SIZEOF_SF_FORMAT_INFO;
end;

// Enumerate all available simple formats.

sf_simple_formats = map sf_get_simple_format $ 0..sf_get_simple_format_count-1
with
  sf_get_simple_format_count = count!0 if res==0 when
    count = {0};
    res = sf_command NULL SFC_GET_SIMPLE_FORMAT_COUNT count SIZEOF_INT;
  end;
  sf_get_simple_format k::int = sf_get_format_info info if res==0 when
    info = sf_format_info k;
    res = sf_command NULL SFC_GET_SIMPLE_FORMAT info SIZEOF_SF_FORMAT_INFO;
  end;
end;

// Enumerate all available major formats.

sf_major_formats = map sf_get_major_format $ 0..sf_get_major_format_count-1
with
  sf_get_major_format_count = count!0 if res==0 when
    count = {0};
    res = sf_command NULL SFC_GET_FORMAT_MAJOR_COUNT count SIZEOF_INT;
  end;
  sf_get_major_format k::int = sf_get_format_info info if res==0 when
    info = sf_format_info k;
    res = sf_command NULL SFC_GET_FORMAT_MAJOR info SIZEOF_SF_FORMAT_INFO;
  end;
end;

// Enumerate all available subtypes.

sf_subtypes = map sf_get_subtype $ 0..sf_get_subtype_count-1
with
  sf_get_subtype_count = count!0 if res==0 when
    count = {0};
    res = sf_command NULL SFC_GET_FORMAT_SUBTYPE_COUNT count SIZEOF_INT;
  end;
  sf_get_subtype k::int = sf_get_format_info info if res==0 when
    info = sf_format_info k;
    res = sf_command NULL SFC_GET_FORMAT_SUBTYPE info SIZEOF_SF_FORMAT_INFO;
  end;
end;
