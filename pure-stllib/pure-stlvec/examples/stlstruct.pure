/* defstruct.pure - named field data structures using the stlcontainer library 

Copyright (c) 2011-2012 by Peter Summerland <p.summerland@gmail.com>.

All rights reserved.

This software is is part of pure-stlvec, an addon to the Pure Programming
Language (http://code.google.com/p/pure-lang/).

This software is distributed under a BSD-style license in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the COPYING file
included with the pure-stlvec distribution package for details.

defstruct and defstruct_code
----------------------------

The defstruct macro is used to define a "struct", a custom data type that
holds arbitrary Pure expressions in named fields. The macro defines a type tag
for the new type, functions to create instances of it and functions for
setting and accessing field values.

    defstruct name_spec field_spec

The name_spec is used to name the custom data structure and to specifiy
whether all of its instances are mutable or immutable. The field_spec names
each field in the structure and optionally specifies the type of the field and
whether the field is readonly or settable. If the custom data structure is
immutable, the "setter functions" generated by defstruct will
"copy-and-write".

The defstruct_code macro is the same as defstruct except that it generates
code and prints it rather than evaluating it.

Examples
--------

    > using stlstruct;

A simple mutable struct type with mutable instances and settable fields.
 
    > stl::defstruct worker {name, idnum};
    ()

    > let w = worker {"Fred", 201}; w;
    struct worker {"Fred",201}

    > typep worker w;
    1

    > name w, idnum w;
    "Fred",201

    > set_name w "Sam";
    struct worker {"Sam",201}

    > name w;
    "Sam

A type with immutable instances, typed fields and a readonly field.

    > stl::defstruct_code (person/stl::immutable) 
        {name.string, idnum.int/stl::readonly, age.int};

    > let p1 = person {"Mary", 201, 21}; p1;
    struct person {"Mary",201,21}

    > let p2 = set_name p1 "Sue"; p2;
    struct person {"Sue",201,21}

    > p1;
    struct person {"Mary",201,21}

    > set_age p1 "twenty one"; // fails type guard
    set_age (struct person {"Mary",201,21}) "twenty one"

    > set_idnum p1 202;
    set_idnum (struct person {"Mary",201,21}) 202


Print the code generated by defstruct assuming the "ns" namespace:

    namespace ns;

    struct::defstruct_code (person/stl::immutable)
      {name.string, idnum.int/stl::readonly, age.int};

The output (slightly edited) looks like this:

    type ns::person (stl::STRUCT ns::person _);

    ns::mk_person x = stl::STRUCT ns::person (stl::struct_mk_sv x 3);

    ns::person v@{p0:: string,p1:: int,p2:: int} = 
      stl::STRUCT ns::person (stl::struct_sv v);

    ns::person (stl::STRUCT ns::person sv) = 
      stl::STRUCT ns::person (stl::struct_dup sv);

    ns::name (stl::STRUCT ns::person v) = stl::sv_get v 0;

    ns::set_name (stl::STRUCT ns::person sv) x:: string = 
    stl::STRUCT ns::person (stl::struct_put (stl::struct_dup sv) 0 x);

    ns::idnum (stl::STRUCT ns::person v) = stl::sv_get v 1;

    ns::age (stl::STRUCT ns::person v) = stl::sv_get v 2;

    ns::set_age (stl::STRUCT ns::person sv) x:: int = 
    stl::STRUCT ns::person (stl::struct_put (stl::struct_dup sv) 2 x);

Parameter Syntax
----------------

   access_code ::= "stl::readonly" | "stl::settable"

   mutability_code ::= "stl::mutable" | "stl::immutable"

   field ::= identifier [ .typeguard ] [ /access_code ]

   fields ::= field | fields, field

   name_spec ::= identifier | "(" identifier "/" mutability_code ")"

   field_spec ::=  "{" fields "}"

The default values for access_code is "stl::settable", and the default value
for mutability_code is "stl::mutable".

Explicit Namespaces
-------------------

Sometimes it is necessary to specify a namespace. For example, see
ut_struct.pure, in which the worker struct is defined first in the
global namespace and then in the "fo" namespace. In the second definition the
fo:: namespace qualifier is required. Note that the namespace qualifier is not
required for the "executive" struct because it was not previously defined.

It is not a bad idea to always specify the namespace in the name-spec. For one
thing you might change from the global namespace to a private namespace as you
are writing a program, and you might still intend for a particular struct
to be in the global namespace. E.g.,

    > stl::defstruct sa {fa};
    <stdin>, line 2: warning: implicit declaration of 'sa'
    <stdin>, line 2: warning: implicit declaration of 'fa'
    ()

    > stl::defstruct ::sb {::fb};

defstruct silently forces all of the field names to reside in the same
namespace as the name of the struct being defined.

*/

using system, regex;
using stlbase, "lib:stlvec";

public members;

namespace stl;

private extern void* stl_sv_make_from_xs(expr* xs_or_sm);
private extern void* stl_sv_make_n(expr* xs, int n);
private extern void  stl_sv_delete(void* vec);
private extern void* stl_sv_dup(expr* it);
private extern expr* stl_sv_vector(expr* it);
private extern expr* stl_sv_foldr(expr* fun, expr* val, expr* it);

extern expr* stl_sv_get(void* vec, int pos) = sv_get;
extern void  stl_sv_put(void* vec, int pos, expr* val) = sv_put;

private extern int pure_sym(char* s);
private extern int atoi(char* s);

def immutable = 0;
def mutable = 1;
def readonly = 0;
def settable = 1;

nonfix STRUCT;
STRUCT = quote STRUCT;
const struct_constr = "stl::STRUCT";

type struct (STRUCT _ _ );

nonfix struct_error;

private parse_field_spec parse_name_spec parse_field_specs eval_code 
        mk_struct_constructors mk_struct_accessors
        mk_struct;

struct_err msg = throw (struct_error msg);

struct_mk_sv x n::int = sentry stl_sv_delete (stl_sv_make_n x n);

struct_sv v = sentry stl_sv_delete (stl_sv_make_from_xs (smatrix v))
  if vectorp v;

struct_dup sv = sentry stl_sv_delete (stl_sv_dup (STRUCT sv));

struct_put sv i x = sv_put sv i x $$ sv;

// bootstrapped with ns = "zzz" then replace zzz:: with ""
type field_def (stl::STRUCT field_def _);
mk_field_def x = stl::STRUCT field_def (stl::struct_mk_sv x 4);
field_def v@{p0:: string,p1:: string,p2:: string,p3:: int} = 
  stl::STRUCT field_def (stl::struct_sv v);
field_def (stl::STRUCT field_def sv) = 
  stl::STRUCT field_def (stl::struct_dup sv);
fnamespace (stl::STRUCT field_def v) = stl::sv_get v 0;
set_fnamespace (stl::STRUCT field_def sv) x:: string = 
  stl::STRUCT field_def (stl::sv_put sv 0 x $$ sv);
fname (stl::STRUCT field_def v) = stl::sv_get v 1;
set_fname (stl::STRUCT field_def sv) x:: string = 
  stl::STRUCT field_def (stl::sv_put sv 1 x $$ sv);
ftype (stl::STRUCT field_def v) = stl::sv_get v 2;
set_ftype (stl::STRUCT field_def sv) x:: string = 
  stl::STRUCT field_def (stl::sv_put sv 2 x $$ sv);
faccess (stl::STRUCT field_def v) = stl::sv_get v 3;
set_faccess (stl::STRUCT field_def sv) x:: int = 
  stl::STRUCT field_def (stl::sv_put sv 3 x $$ sv);

parse_field_spec default_namespace default_access spec = fdef when
  field_pat ="^[[:space:]]*([^ ./]+)(\\.[^ ./]+)?(/[[:digit:]])?$";
  ri = reg_info $ regex field_pat REG_EXTENDED spec 0;
  if #ri <8 then struct_err (sprintf "bad field def: %s" spec) else ();
  qname = ri!3;
  ftype = ri!5;
  faccess_str = ri!7;
  ri = reg_info $ regex "(([^ ./:]+)::)?([^ ./]+)" REG_EXTENDED qname 0;
  fnamespace, fname = ri!5,ri!7;
  fnamespace = if null fnamespace then default_namespace else fnamespace;
  ftype = if ::null ftype then ftype else substr ftype 1 10000;
  faccess = if ::null faccess_str then default_access 
            else atoi (substr faccess_str 1 1000);
  fdef = field_def {fnamespace ,fname, ftype, faccess};
end;

parse_name_spec name_spec = ns, struct_name, faccess ndef when
  ndef = catch err (parse_field_spec "" mutable name_spec);
  null (ftype ndef) || err ();
  ns = fnamespace ndef;
  struct_name = fname ndef;
end with
  err _ = struct_err (sprintf "bad name spec: %s" name_spec); 
end;

parse_field_specs nspace fields_spec = fdefs when
  fss = split "," (substr fields_spec 1 (#fields_spec-2));
  fdefs = map (parse_field_spec nspace settable) fss;
end;

eval_code print code = () when
  if print then puts (code + ";") else eval code;
end;

mk_qname ns name = if null ns then "::" +  name else ns + "::" + name;

mk_constr ns name = struct_constr + " " + mk_qname ns name;

mk_struct_constructors print ns name fdefs = () when
  constr_name = mk_constr ns name;
  qname = mk_qname ns name;  
  ftypes = map ftype fdefs;  
  params = join "," $ zipwith mkparam ftypes (0..inf);
  eval_code print ("type " + qname + " (" + constr_name + " _)");
  cd = mk_qname ns ("mk_" + name) + " x = " +
    constr_name + " (stl::struct_mk_sv x " + str (#ftypes) + ")";
  eval_code print cd;
  cd = qname + " v@{" + params + "} = " + constr_name + 
    " (stl::struct_sv v)";
  eval_code print cd;
  cd = qname + " (" + constr_name + " sv) = " + constr_name + 
    " (stl::struct_dup sv)";
  eval_code print cd;
end with
 mkparam ftype i = sprintf "p%d%s" (i,tguard) when
    tguard = if null ftype then "" else ":: " + ftype;
  end;
end;

mk_struct_accessors print ns name is_mutable fdefs = mk_a fdefs 0 with
  mk_a [] _ = ();
  mk_a (fdef:rest) ndx = mk_a rest (ndx+1) when
    qfname = mk_qname ns (fname fdef);
    pure_sym(qfname);
    cd = qfname + " (" + constr_name + " v) = stl::sv_get v " + str ndx;
    eval_code print cd;
    (str (qfname, faccess fdef));
    if faccess fdef == readonly then ()
    else if is_mutable then
      eval_code print (mk_mutable_setter fdef ndx)
    else
      eval_code print (mk_immutable_setter fdef ndx);
  end;
  mk_mutable_setter fdef ndx = setter_lhs fdef + " = " + constr_name + 
    " (stl::sv_put sv " + str ndx + " x $$ sv)";
  mk_immutable_setter fdef ndx = setter_lhs fdef + " = " + constr_name + 
    " (stl::struct_put (stl::struct_dup sv) " + str ndx + " x)";
  type_guard fd = if null t then t else ":: " + t when t = ftype fd end;
  setter_lhs fdef = lhs when
    setter_name = mk_qname ns ("set_" + fname fdef);
    lhs = setter_name + " (" + constr_name + " sv) x" + type_guard fdef;
    pure_sym(setter_name);
  end;
end when
  constr_name = mk_constr ns name;
  qname = mk_qname ns name;  ftypes = map ftype fdefs;  
end;

mk_struct print name_spec field_specs = () when
  nspace, name, is_mutable = parse_name_spec name_spec;
  fdefs = parse_field_specs nspace field_specs;
  mk_struct_constructors print nspace name fdefs;
  mk_struct_accessors print nspace name is_mutable fdefs;
end;

def defstruct name fields = 
  stl::mk_struct 0 (str ('name)) (str ('fields));

def defstruct_code name fields = 
  stl::mk_struct 1 (str ('name)) (str ('fields));

::members (STRUCT _ sv) = stl_sv_foldr (\x xs->x:xs) [] (STRUCT sv);

struct_name (STRUCT name _) = str name; 

