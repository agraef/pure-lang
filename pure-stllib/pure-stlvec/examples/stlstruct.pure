/* stlstruct.pure - named field data structures using the stlvec library 

Copyright (c) 2011-2012 by Peter Summerland <p.summerland@gmail.com>.

All rights reserved.

This software is is part of pure-stllib, an addon to the Pure Programming
Language (http://code.google.com/p/pure-lang/).

This software is distributed under a BSD-style license in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the COPYING file
included with the pure-stlvec distribution package for details

defstruct and defstruct_code
----------------------------

The defstruct macro is used to define a "stlstruct", a custom data type that
holds arbitrary Pure expressions in named fields. The macro defines a type tag
for the new type, functions to create instances of it and functions for
setting and accessing field values.

    defstruct name_spec field_spec

The name_spec is used to name the new data type and to specifiy whether all
of its instances are mutable or immutable. The field_spec names each field in
the type's structure and optionally specifies the type of the field and
whether the field is readonly or settable. If the custom data type is
immutable, the "setter functions" generated by defstruct, if any, will have
copy-on-write semmantics.

The defstruct_code macro is the same as defstruct except that it generates
code and prints it rather than evaluating it. If you want, you can paste
the generated code in your scripts.

Examples
--------

Start Pure, load the stlstruct module and set a pragma to avoid implicit
declaration warnings.

   $> pure
   Pure 0.52 (i686-pc-linux-gnu) Copyright (c) 2008-2012 by Albert Graef
   (Type 'help' for help, 'help copying' for license information.)
   Loaded prelude from /usr/local/lib/pure/prelude.pure.

   > using system, stlstruct;

   > #! --nowarn

   // defstruct macros here

   > #! --rewarn


Example 1 - A Mutable stlstruct
-------------------------------

Define a new data type, plumber. Each plumber is a mutable type with
three fields: name, idnum, and unit. name must be a string, idnum must be an
int and unit can be anything.

   > stl::defstruct plumber {name.string, idnum.int, unit};
   ()

Construct a plumber.

   > let p = plumber {"Steve",203, "unit_11"};

Get the name.

   > name p;                       // name works on plumbers
   "Steve"

Set the idnum.

   > set_idnum p 213.0;            // fails, 213.0 is not an int
   set_idnum (plumber {"Steve",203,"unit_21"}) 213.0

   > set_idnum p 213;             // ok
   plumber{"Steve",213,"unit_21"} // returns p, mutated

   > p;
   plumber{"Steve",213,"unit_21"}


Example 2 - An Immutable stlstruct ----------------------------------

The following definition, "/immutable" means that instances of type carpenter
are immutable. I.e., setter functions write on and return copies of structures
that they are asked to change.

   > stl::defstruct (carpenter/immutable) {idnum.int, name.string, unit};
   ()

Construct a carpenter.

   > let c = carpenter {201, "Fred", "unit_10"};

   > typep carpenter c;
   1

We now have overloaded functions for name, idnum and unit, one for plumbers
and one for carpenters.

   > show name
   name (stl::STRUCT ::plumber v) = stl::sv_get v 0;
   name (stl::STRUCT ::carpenter v) = stl::sv_get v 1;

Constructors and setter functions generated by defstruct are type-checked to
the extent that type info is provided in the definition.

   > catch id $ carpenter {(), "Fred", "unit_10"};
   bad_argument  // () is not a int

Using [] instead of {} you can turn off type guards for constructor
parameters. This can be useful when you need a partially initialized instance
of a new structure.

   > let c1 = carpenter [(), "Fred", "unit_10"]
  
   > c1;
   carpenter{(),"Fred","unit_10"}

Now let's change c's name. Because carpenter is an immutable data structure, c
is not changed. Instead an updated new carpenter is created and returned.

   > let c1 = set_name c "Sam";      // c1 is different than c
 
   > c1;                             // c1 is Sam
   carpenter{"Sam",201,"unit_10"}

   > c;                              // c is still Fred
   carpenter{"Fred",201,"unit_10"}

   
Example 3 - A mutable stlstruct with a read-only field
------------------------------------------------------

An "/r" after a field name means that the field is read-only, i.e., do not
create a setter function for tne field. The overall structure can be mutable
or immutable.

   > stl::defstruct (painter/mutable) {name, (idnum.int/r), unit};
   ()

   > let p = painter {"Bill",202, "unit_10"};

    > set_unit p "unit_20";
   painter{"Bill",202,"unit_20"}

   > p;
   painter{"Bill",202,"unit_20"}

Try to change idnum.

   > set_idnum p 203;            // fails idnum is read only for painters
   set_idnum (painter {"Bill",202,"unit_20"}) 203

   > show set_idnum              // no set_idnum for painters
   set_idnum (stl::STRUCT ::plumber sv) x::int = \
     stl::STRUCT ::plumber (stl::struct_put sv 1 x);
   set_idnum (stl::STRUCT ::carpenter sv) x::int = \
     stl::STRUCT ::carpenter (stl::struct_put sv 0 x);

   painter{"Bill",202,"unit_20"}
  

Syntax
------

   mutability_tag ::= "/mutable" | "/immutable"

   name_spec ::= identifier | "(" identifier [ mutability_tag ] ")"

   access_tag ::= "/r" | "/s"

   typeguard ::= "." qualified_type_name

   field ::= identifier | "(" [ typeguard ] [ access_tag ] ")"

   fields ::= field | fields, field

   field_list ::=  "{" fields "}"

   defstruct ::= "defstruct" name_spec field_list

For name_specs, the default mutablility_tag, "mutable", means change field
values in place. "immutable" means copy on write. I.e., the setter functions,
if any, will make a copy before setting the new value and return the copy
rather than the original struct. For the access_tag, the default, "r", is
means that the field is read-only and "s" means that the field is settable.

Generated Code
--------------

Paste these lines in at the prompt and take a look.

  using stlstruct;
  #! --nowarn

  stl::defstruct_code plumber {name.string, idnum.int, unit};
  stl::defstruct_code (carpenter.i/immutable) {name.string, idnum.int, unit};
  stl::defstruct_code (painter.i/mutable) {name, idnum.int/r, unit};

Here is the code for plumber:

   ::plumber (stl::STRUCT ::plumber sv) = 
     stl::STRUCT ::plumber (stl::struct_dup sv);

   ::plumber v@{p0:: string,p1:: int,p2} = 
     stl::STRUCT ::plumber (stl::struct_sv v);

   ::plumber xs = 
     stl::STRUCT ::plumber (stl::struct_sv xs) 
     if ~vectorp xs && #xs == 3;

   ::plumber _ = throw bad_argument;

   ::name (stl::STRUCT ::plumber v) = stl::sv_get v 0;

   ::set_name (stl::STRUCT ::plumber sv) x:: string = 
      stl::STRUCT ::plumber (stl::sv_put sv 0 x $$ sv);

   ::idnum (stl::STRUCT ::plumber v) = stl::sv_get v 1;

   ::set_idnum (stl::STRUCT ::plumber sv) x:: int = 
      stl::STRUCT ::plumber (stl::sv_put sv 1 x $$ sv);

   ::unit (stl::STRUCT ::plumber v) = stl::sv_get v 2;

   ::set_unit (stl::STRUCT ::plumber sv) x = 
     stl::STRUCT ::plumber (stl::sv_

Explicit Namespaces
-------------------

In general, defstruct seems to work with different namespaces. Sometimes,
however, it is necessary provide a namespace qualifier before the struct name
in the defstruct definition.

   > namespace ;

   > #! --nowarn

   > stl::defstruct_code worker {name.string, idnum/r, unit.string};

   > namespace fo;

   > stl::defstruct_code executive {name.string, idnum/r, unit};

   > stl::defstruct_code (fo::worker) {name.string, idnum/r, unit};

All of the functions for the worker and executive types are defined in the
fo namespace. And functions for the fo::worker type end in in the fo
namespace. But this only worked for fo::worker because of the fo:: qualifier
in the defstruct statement. The "fo::" is required because worker was already
defined in the global namespace when we tried to define the fo::worker struct.
This was not required for the fo::executive type because executive was not
previously defined. Using defstruct_code, you should, by trial and error, be
able to determine if you need the qualifier more readily than trying to learn
some complex rule.

*/

using system, regex;
using "lib:stlbase", "lib:stlvec";

public members bad_argument;

namespace stl;

private extern void* stl_sv_make_from_xs(expr* xs_or_sm);
private extern void* stl_sv_make_n(expr* xs, int n);
private extern void  stl_sv_delete(void* vec);
private extern void* stl_sv_dup(expr* it);
private extern expr* stl_sv_vector(expr* it);
private extern expr* stl_sv_foldr(expr* fun, expr* val, expr* it);
private extern int pure_sym(char* s);
private extern int atoi(char* s);

/* Runtime Support For stlstruct **********************************************/

nonfix STRUCT;
STRUCT = quote STRUCT;
const struct_constr = "stl::STRUCT";

type struct (STRUCT _ _ );

nonfix struct_error;

extern expr* stl_sv_get(void* vec, int pos) = sv_get;

extern void  stl_sv_put(void* vec, int pos, expr* val) = sv_put;

struct_err msg = throw (struct_error msg);

struct_sv xs = sentry stl_sv_delete (stl_sv_make_from_xs xs);

struct_dup sv = sentry stl_sv_delete (stl_sv_dup (STRUCT sv));

struct_put sv i x = sv_put sv i x $$ sv;


/* Bootstrapped stlstruct To Hold Field Info *********************************/

// stl::defstruct_code (field_def) 
// {
//  fnamespace.string,
//  fname.string,
//  ftype.string,
//  faccess.string
// };

type field_def (stl::STRUCT field_def _);
field_def (stl::STRUCT field_def sv) = stl::STRUCT field_def (stl::struct_dup sv);
field_def v@{p0:: string,p1:: string,p2:: string,p3:: string} = stl::STRUCT field_def (stl::struct_sv v);
field_def xs = stl::STRUCT field_def (stl::struct_sv xs) if ~vectorp xs && #xs == 4;
field_def _ = throw ::bad_argument;
fnamespace (stl::STRUCT field_def v) = stl::sv_get v 0;
set_fnamespace (stl::STRUCT field_def sv) x:: string = stl::STRUCT field_def (stl::struct_put sv 0 x);
fname (stl::STRUCT field_def v) = stl::sv_get v 1;
set_fname (stl::STRUCT field_def sv) x:: string = stl::STRUCT field_def (stl::struct_put sv 1 x);
ftype (stl::STRUCT field_def v) = stl::sv_get v 2;
set_ftype (stl::STRUCT field_def sv) x:: string = stl::STRUCT field_def (stl::struct_put sv 2 x);
faccess (stl::STRUCT field_def v) = stl::sv_get v 3;
set_faccess (stl::STRUCT field_def sv) x:: string = stl::STRUCT field_def (stl::struct_put sv 3 x);

/* Functions To Parse defstruct And Generate Code *****************************/

private parse_field_spec parse_name_spec parse_field_specs eval_code 
        mk_struct_constructors mk_struct_accessors mk_struct ;

private readonly_tag settable_tag indexed_tag 
        functional_tag mutable_tag immutable_tag;

const readonly_tag = "r";
const settable_tag = "s";
const indexed_tag = "i";
const functional_tag = "f";
const mutable_tag = "mutable";
const immutable_tag = "immutable";

parse_field_spec default_namespace default_access spec = fdef when
  field_pat ="^[[:space:]]*([^ ./]+)(\\.[^ ./]+)?(/[^[:space:]]+)?$";
  ri = reg_info $ regex field_pat REG_EXTENDED spec 0;
  if #ri <8 then struct_err (sprintf "bad field def: %s" spec) else ();
  qname = ri!3;
  ftype = ri!5;
  faccess_str = ri!7;
  ri = reg_info $ regex "(([^ ./:]+)::)?([^ ./]+)" REG_EXTENDED qname 0;
  fnamespace, fname = ri!5,ri!7;
  fnamespace = if null fnamespace then default_namespace else fnamespace;
  ftype = if ::null ftype then ftype else substr ftype 1 1000;
  faccess = if ::null faccess_str then default_access 
            else substr faccess_str 1 1000;
  fdef = field_def {fnamespace ,fname, ftype, faccess};
end;

parse_name_spec name_spec = ns, struct_name, mutable, indexed
when
  ndef = catch err (parse_field_spec "" mutable_tag name_spec);
  ndx_tag = ftype ndef;
  indexed = if null ndx_tag then 0
              // disable indexed read-style 
              // else if ndx_tag == indexed_tag then 1 
              // else if ndx_tag == functional_tag then 0
            else err 1;
  ns = fnamespace ndef;
  struct_name = fname ndef;
  m_tag = faccess ndef;
  mutable = if  m_tag == mutable_tag then 1
            else if m_tag == immutable_tag then 0
            else err 1;
end with
  err _ = struct_err (sprintf "bad name spec: %s" name_spec); 
end;

parse_field_specs nspace fields_spec = fdefs when
  fss = split "," (substr fields_spec 1 (#fields_spec-2));
  fdefs = map (parse_field_spec nspace settable_tag) fss;
end;

eval_code print code = () when
  if print then puts (code + ";") else eval code;
end;

mk_qname ns name = if null ns then "::" +  name else ns + "::" + name;

mk_constr ns name = struct_constr + " " + mk_qname ns name;

mk_struct_constructors print ns name fdefs = () when
  constr_name = mk_constr ns name;
  qname = mk_qname ns name;  
  ftypes = map ftype fdefs;  
  params = join "," $ zipwith mkparam ftypes (0..inf);
  eval_code print ("type " + qname + " (" + constr_name + " _)");
  cd = qname + " (" + constr_name + " sv) = " + constr_name + 
    " (stl::struct_dup sv)";
  eval_code print cd;
  cd = qname + " v@{" + params + "} = " + constr_name +
    " (stl::struct_sv v)";
  eval_code print cd;
  cd = qname + " xs = " + constr_name + 
    " (stl::struct_sv xs) if ~vectorp xs && #xs == " + str (#ftypes);
  eval_code print cd;
  cd = qname + " _ = throw ::bad_argument";
  eval_code print cd;
end with
 mkparam ftype i = sprintf "p%d%s" (i,tguard) when
    tguard = if null ftype then "" else ":: " + ftype;
  end;
end;

mk_struct_accessors print ns name mutable indexed fdefs = mk_a fdefs 0 
with
  mk_a [] _ = ();
  mk_a (fdef:rest) ndx = mk_a rest (ndx+1) when
    fldname = fname fdef;
    qfname = mk_qname ns fldname;
    pure_sym(qfname);
    cd = if indexed then
          "const " + name + "_" + fldname + " = " + str ndx 
         else
           qfname + " (" + constr_name + " v) = stl::sv_get v " + str ndx;
    eval_code print cd;
    if faccess fdef == readonly_tag then ()
    else if mutable then
      eval_code print (mk_mutable_setter fdef ndx)
    else
      eval_code print (mk_immutable_setter fdef ndx);
  end;
  mk_mutable_setter fdef ndx = setter_lhs fdef + " = " + constr_name + 
    " (stl::struct_put sv " + str ndx + " x)";
  mk_immutable_setter fdef ndx = setter_lhs fdef + " = " + constr_name + 
    " (stl::struct_put (stl::struct_dup sv) " + str ndx + " x)";
  type_guard fd = if null t then t else ":: " + t when t = ftype fd end;
  setter_lhs fdef = lhs when
    setter_name = mk_qname ns ("set_" + fname fdef);
    lhs = setter_name + " (" + constr_name + " sv) x" + type_guard fdef;
    pure_sym(setter_name);
  end;
end when
  constr_name = mk_constr ns name;
  qname = mk_qname ns name;  ftypes = map ftype fdefs;  
end;

mk_struct print name_spec field_specs = () when
  nspace, name, mutable, indexed = parse_name_spec name_spec;
  fdefs = parse_field_specs nspace field_specs;
  mk_struct_constructors print nspace name fdefs;
  mk_struct_accessors print nspace name mutable indexed fdefs;
end;

/* Public Interface *********************************************************/

def defstruct name fields = 
  stl::mk_struct 0 (str ('name)) (str ('fields));

def defstruct_code name fields = 
  stl::mk_struct 1 (str ('name)) (str ('fields));

::members (STRUCT _ sv) = stl_sv_foldr (\x xs->x:xs) [] (STRUCT sv);

struct_name (STRUCT name _) = str name; 

(::!) (STRUCT _ sv) ndx::int = stl::sv_get sv ndx;

namespace ;

__show__ s@(stl::STRUCT name sv) = str name + str (vector $ members s);


