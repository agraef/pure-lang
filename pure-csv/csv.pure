/* CSV library interface

   Date: July 15, 2008
   Updated: November 21,22, 2008 to use namespaces.
   Updated: December 22, 2009: changed the default dialect to a const and 
            modified lookup to take advantage of nonlinear pattern matching.
   Updated: July 11, 2010 to make use of rewritten C module and Pure's built
            in records.
*/

namespace csv;

using "lib:csv";

private extern dialect_t *dialect_new(char *, char *, char *, char *, int);
private extern void dialect_free(dialect_t *);
private extern csv_t *csv_open(char *, char *, void *, int);
private extern void csv_close(csv_t *t);
private extern void csv_free(csv_t *t);
private extern expr *csv_write(csv_t *, expr **, int);
private extern expr *csv_read(csv_t *csv);

public
  MINIMAL
  STRING
  ALL
  LIST
  VECTOR
  dialect
  quote
  escape
  delimiter
  terminator
  quote_flag
  default
  open
  close
  getr
  putr;

/* Public dialect options

  delimiter:  Character used to separates fields.
              Type: string
              Default: ","

  escape:     Escape character used to embed delimiter, escape, or return
              characters. If the escape character is not null, then the
              quote character is ignored.
              Type: string
              Default: ""
              Notes:
                Reading: The escape character is dropped and the next char
                         is inserted into the field.
                Writing: The escape character is written into the output
                         stream before the delimiter, escape, or return
                         character.

  quote:      Quote character for embedding delimiters, quotes, and
              returns. The quote character is ignored if the escape
              character is defined.
              Type: string
              Default: "\""

  quote_flag: Sets whether strings or numbers should be quoted.
              Type: One of {ALL, STRING, MINIMAL}
              Default: ALL
	      Notes:
	        Reading: ALL     - all fields are returned as strings.
			 STRING  - 
                         MINIMAL - non quoted integer and double fields are
			           converted.
                Writing: ALL     - all fields are written enclosed in quotes.
                         STRING  - only string fields are written enclosed in
                                   quotes.
                         MINIMAL - only fields containing quote, delimiter,
                                   or return characters are written with
                                   enclosing quotes.

  terminator: Value use for record termination.
              Type: One of {"\r\n", "\n"}
              Default: "\n"
	      Notes:
                Reading: "\r" are always ignored except when embedded in
                         fields.
*/

const MINIMAL = 1;
const STRING = 2;
const ALL = 3;

dialect d::matrix
  = if null r then
      error "out of memory"
    else
      sentry dialect_free r
    when
      s = {quote=>"\"", escape=>"", delimiter=>",", terminator=>"\n",
      	   quote_flag=>ALL};
      v = if check_dialect d then
            record {s, d}
          else
            error "invalid dialect"
	  with
      	    check_dialect d::matrix
              = all (\(x=>y) -> member s x) d &&
	        (~ member d terminator ||  d!terminator == "\n" || 
		 d!terminator == "\r\n") &&
                all stringp (d!![quote,escape,delimiter]) &&
                (~ member d quote_flag || any (=== d!quote_flag) [1,2,3]);
          end;
      r = dialect_new (v!quote) (v!escape) (v!delimiter) (v!terminator)
                      (v!quote_flag);
    end;

/* Predefined dialects */
const default = dialect {};
const RFC4180 = dialect {terminator=>"\r\n"};
const EXCEL = dialect {quote_flag=>MINIMAL, terminator=>"\r\n"};

const LIST = 1;
const VECTOR = 0;

/* Open a CSV file for reading, "r", writing, "w", or appending, "a",
   with dialect d */
open (fname::string, rw_flag::string, d::pointer, list_flag::int)
  = if rw_flag ~= "r" && rw_flag ~= "w" && rw_flag ~= "a" then
      throw error "bad read/write/append flag"
    else if null d || null f then
      throw error "cannot open file"    
    else
      (sentry csv_free f $$ sentry csv_close f)
    when
      f = csv_open fname rw_flag d list_flag;
    end;

/* Open a CSV file like above but with the library but output is a vector */
open (fname::string, rw_flag::string, d::pointer)
  = open (fname, rw_flag, d, 0);

/* Open a CSV file like above but with the library default dialect */
open (fname::string, rw_flag::string) = open (fname, rw_flag, default, 0);

/* Open a CSV file for reading with the library default dialect */
open fname::string = open (fname, "r", default, 0);

/* Close a CSV file. Sentries ensure files will automatically be closed
   and internal buffers will be freed when the file pointer goes out of
   scope. */
close f::pointer = clear_sentry f $$ csv_close f;

/* Write a record to a CSV file */
putr f::pointer r::matrix = csv_write f r (#r) if rowvectorp r;
putr f::pointer r@(_:_) = csv_write f m (#m) when m = matrix r; end;

/* Write a list of records to a CSV file */
fputr f::pointer xs@(_:_) = loop xs with
  loop [] = ();
  loop (x:xs) = (putr f x) $$ loop xs;
end;

/* Read a record from a CSV file */
getr f::pointer = csv_read f;

/* Read a list of records from a CSV file */
fgetr f::pointer = loop (getr f) [] with
  loop () xs = reverse xs;
  loop x xs = loop (getr f) (x:xs);
end;

/* Lazily read a list of records from a CSV file */
fgetr_lazy f::pointer = if null r then [] else r:fgetr_lazy f & when
  r = getr f;
end;