
/* gsl_randist.pure: GSL wrapper for the Pure programming language. */

/* Copyright (c) 2008 by Albert Graef <Dr.Graef@t-online.de>.
   Copyright (c) 2008 by Robert E. Rucker <erucker@bmc.edu>.

   This file is part of the Pure programming language and system.

   Pure is free software: you can redistribute it and/or modify it under the
   terms of the GNU General Public License as published by the Free Software
   Foundation, either version 3 of the License, or (at your option) any later
   version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
   details.

   You should have received a copy of the GNU General Public License along
   with this program.  If not, see <http://www.gnu.org/licenses/>. */

/* ..
   
   Random Number Distributions
   ---------------------------
   
   This module is loaded via the command ``using gsl::randist`` and provides
   Pure wrappers for the GSL random distribution routines found in Chapter 
   19 of the GSL manual,
   
   http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Distributions.html.
   
   There are two namespaces provided by randist.pure, ``gsl::ran`` for
   probability densitity functions and ``gsl::cdf`` for cumulative
   distribution functions. The two namespaces minimize typing of the
   prefixes ``gsl_ran_`` and ``gsl_cdf_`` respectively.
   
   Routines
   ~~~~~~~~ */

using "lib:gsl";

namespace gsl;
namespace gsl::ran;

private extern double gsl_ran_gaussian_pdf(double, double);
private extern double gsl_ran_ugaussian_pdf(double);
private extern double gsl_ran_gaussian_tail_pdf(double, double, double);
private extern double gsl_ran_ugaussian_tail_pdf(double, double);
private extern double gsl_ran_bivariate_gaussian_pdf
  (double, double, double, double, double);
private extern double gsl_ran_exponential_pdf(double, double);
private extern double gsl_ran_laplace_pdf(double, double);
private extern double gsl_ran_exppow_pdf(double, double, double);
private extern double gsl_ran_cauchy_pdf(double, double);
private extern double gsl_ran_rayleigh_pdf(double, double);
private extern double gsl_ran_rayleigh_tail_pdf(double, double, double);
private extern double gsl_ran_landau_pdf(double);
private extern double gsl_ran_gamma_pdf(double, double, double);
private extern double gsl_ran_flat_pdf(double, double, double);
private extern double gsl_ran_lognormal_pdf(double, double, double);
private extern double gsl_ran_chisq_pdf(double, double);
private extern double gsl_ran_fdist_pdf(double, double, double);
private extern double gsl_ran_tdist_pdf(double, double);
private extern double gsl_ran_beta_pdf(double, double, double);
private extern double gsl_ran_logistic_pdf(double, double);
private extern double gsl_ran_pareto_pdf(double, double, double);
private extern double gsl_ran_weibull_pdf(double, double, double);
private extern double gsl_ran_gumbel1_pdf(double, double, double);
private extern double gsl_ran_gumbel2_pdf(double, double, double);
private extern double gsl_ran_dirichlet_pdf(size_t, double*, double*);
private extern double gsl_ran_dirichlet_lnpdf(size_t, double*, double*);
private extern gsl_ran_discrete_t *gsl_ran_discrete_preproc(size_t, double*);
private extern double gsl_ran_discrete_pdf(size_t, gsl_ran_discrete_t*);
private extern void gsl_ran_discrete_free(gsl_ran_discrete_t *);
private extern double gsl_ran_poisson_pdf(int, double);
private extern double gsl_ran_bernoulli_pdf(int, double);
private extern double gsl_ran_binomial_pdf(int, double, int);
private extern double gsl_ran_multinomial_pdf(size_t, double*, int*);
private extern double gsl_ran_multinomial_lnpdf(size_t, double*, int*);
private extern double gsl_ran_negative_binomial_pdf(int, double, double);
private extern double gsl_ran_pascal_pdf(int, double, int);
private extern double gsl_ran_geometric_pdf(int, double);
private extern double gsl_ran_hypergeometric_pdf(int, int, int, int);
private extern double gsl_ran_logarithmic_pdf(int, double);

/* P.d.f. macro. */

private
  apply2_ran;

def apply2_ran  f  m1  m2  =
  if rowvectorp m1 && rowvectorp m2 && #m1 == #m2 then
    (v
     when
       x1, x2 = dmatrix m1, dmatrix m2;
       v = f (#m1) (pointer x1) (pointer x2);
     end)
  else
    f m1 m2;

public
  ugaussian_pdf
  gaussian_pdf
  gaussian_tail_pdf
  ugaussian_tail_pdf
  bivariate_gaussian_pdf
  exponential_pdf
  laplace_pdf
  exppow_pdf
  cauchy_pdf
  rayleigh_pdf
  rayleigh_tail_pdf
  landau_pdf
  gamma_pdf
  flat_pdf
  lognormal_pdf
  chisq_pdf
  fdist_pdf
  tdist_pdf
  beta_pdf
  logistic_pdf
  pareto_pdf
  weibull_pdf
  gumbel1_pdf
  gumbel2_pdf
  dirichlet_pdf
  dirichlet_lnpdf
  discrete_preproc
  discrete_pdf
  discrete_free
  poisson_pdf
  bernoulli_pdf
  binomial_pdf
  multinomial_pdf
  multinomial_lnpdf
  negative_binomial_pdf
  pascal_pdf
  geometric_pdf
  hypergeometric_pdf
  logarithmic_pdf;

/* .. _ugaussian_pdf:
   
   ``ugaussian_pdf  x``
     implements ``gsl_ran_ugaussian``.
*/

ugaussian_pdf  x
  = gsl_ran_ugaussian_pdf (double x) if realp x;

/* .. _gaussian_pdf:
   
   ``gaussian_pdf  x  sigma``
     implements ``gsl_ran_gaussian_pdf``.
*/

gaussian_pdf  x  sigma
  = gsl_ran_gaussian_pdf (double x) (double sigma) if realp x && realp sigma;

/* .. _gaussian_tail_pdf:
   
   ``gaussian_tail_pdf  x  a  sigma``
     implements ``gsl_ran_gaussian_tail_pdf``.
*/

gaussian_tail_pdf  x  a  sigma
  = gsl_ran_gaussian_tail_pdf (double x) (double a) (double sigma)
    if realp x && realp a && realp sigma;

/* .. _ugaussian_tail_pdf:
   
   ``ugaussian_tail_pdf  x  a``
     implements ``gsl_ran_ugaussian_tail_pdf``.
*/

ugaussian_tail_pdf  x  a
  = gsl_ran_ugaussian_tail_pdf (double x) (double a) if realp x && realp a;

/* .. _bivariate_gaussian_pdf:
   
   ``bivariate_gaussian_pdf  x  a``
     implements ``gsl_ran_bivariate_gaussian_pdf``.
*/

bivariate_gaussian_pdf  x  y  sigma_x  sigma_y  rho
  = gsl_ran_bivariate_gaussian_pdf
      (double x) (double y) (double sigma_x) (double sigma_y) (double rho)
    if realp x && realp y && realp sigma_x && realp sigma_y && realp rho;

/* .. _expoential_pdf:
   
   ``exponential_pdf  x  mu``
     implements ``gsl_ran_exponential_pdf``.
*/

exponential_pdf  x  mu
  = gsl_ran_exponential_pdf (double x) (double mu) if realp x && realp mu;

/* .. _laplace_pdf:
   
   ``laplace_pdf  x  a``
     implements ``gsl_ran_laplace_pdf``.
*/

laplace_pdf  x  a
  = gsl_ran_laplace_pdf (double x) (double a) if realp x && realp a;

/* .. _exppow_pdf:
   
   ``exppow_pdf  x  a  b``
     implements ``gsl_ran_exppow_pdf``.
*/

exppow_pdf  x  a  b
  = gsl_ran_exppow_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

/* .. _cauchy_pdf:
   
   ``cauchy_pdf  x  a``
     implements ``gsl_ran_cauchy_pdf``.
*/

cauchy_pdf  x  a
  = gsl_ran_cauchy_pdf (double x) (double a) if realp x && realp a;

/* .. _rayleigh_pdf:
   
   ``rayleigh_pdf  x  sigma``
     implements ``gsl_ran_rayleigh_pdf``.
*/

rayleigh_pdf  x  sigma
  = gsl_ran_rayleigh_pdf (double x) (double sigma) if realp x && realp sigma;

/* .. _rayleigh_tail_pdf:
   
   ``rayleigh_tail_pdf  x  a  sigma``
     implements ``gsl_ran_rayleigh_tail_pdf``.
*/

rayleigh_tail_pdf  x  a  sigma
  = gsl_ran_rayleigh_tail_pdf (double x) (double a) (double sigma)
    if realp x && realp a && realp sigma;

/* .. _landau_pdf:
   
   ``landau_pdf  x``
     implements ``gsl_ran_landau_pdf``.
*/

landau_pdf  x
  = gsl_ran_landau_pdf x if realp x;

/* .. _gamma_pdf:
   
   ``gamma_pdf  x  a  b``
     implements ``gsl_ran_gamma_pdf``.
*/

gamma_pdf  x  a  b
  = gsl_ran_gamma_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

/* .. _flat_pdf:
   
   ``flat_pdf  x  a  b``
     implements ``gsl_ran_flat_pdf``.
*/

flat_pdf  x  a  b
  = gsl_ran_flat_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

/* .. _lognormal_pdf:
   
   ``lognormal_pdf  x  zeta  sigma``
     implements ``gsl_ran_lognormal_pdf``.
*/

lognormal_pdf  x  zeta  sigma
  = gsl_ran_lognormal_pdf (double x) (double zeta) (double sigma)
    if realp x && realp zeta && realp sigma;

/* .. _chisq_pdf:
   
   ``chisq_pdf  x  nu``
     implements ``gsl_ran_chisq_pdf``.
*/

chisq_pdf  x  nu
  = gsl_ran_chisq_pdf (double x) (double nu) if realp x && realp nu;

/* .. _fdist_pdf:
   
   ``fdist_pdf  x  nu1  nu2``
     implements ``gsl_ran_fdist_pdf``.
*/

fdist_pdf  x  nu1  nu2
  = gsl_ran_fdist_pdf (double x) (double nu1) (double nu2)
    if realp x && realp nu1 && realp nu2;

/* .. _tdist_pdf:
   
   ``tdist_pdf  x  nu``
     implements ``gsl_ran_tdist_pdf``.
*/

tdist_pdf  x  nu
  = gsl_ran_tdist_pdf (double x) (double nu) if realp x && realp nu;

/* .. _beta_pdf:
   
   ``beta_pdf  x  a  b``
     implements ``gsl_ran_beta_pdf``.
*/

beta_pdf  x  a  b
  = gsl_ran_beta_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

/* .. _logistic_pdf:
   
   ``logistic_pdf  x  a``
     implements ``gsl_ran_logistic_pdf``.
*/

logistic_pdf  x  a
  = gsl_ran_logistic_pdf (double x) (double a) if realp x && realp a;

/* .. _pareto_pdf:
   
   ``pareto_pdf  x  a  b``
     implements ``gsl_ran_pareto_pdf``.
*/

pareto_pdf  x  a  b
  = gsl_ran_pareto_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

/* .. _weibull_pdf:
   
   ``weibull_pdf  x  a  b``
     implements ``gsl_ran_weibull_pdf``.
*/

weibull_pdf  x  a  b
  = gsl_ran_weibull_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

/* .. _gumbel1_pdf:
   
   ``gumbel1_pdf  x  a  b``
     implements ``gsl_ran_gumbel1_pdf``.
*/

gumbel1_pdf  x  a  b
  = gsl_ran_gumbel1_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

/* .. _gumbel2_pdf:
   
   ``gumbel2_pdf  x  a  b``
     implements ``gsl_ran_gumbel2_pdf``.
*/

gumbel2_pdf  x  a  b
  = gsl_ran_gumbel2_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

/* .. _dirichlet_pdf:
   
   ``dirichlet_pdf  alpha::matrix  theta::matrix``
     implements ``gsl_ran_dirichlet_pdf``.
*/

dirichlet_pdf  alpha::matrix  theta::matrix
  = apply2_ran gsl_ran_dirichlet_pdf alpha theta;

/* .. _dirichlet_lnpdf:
   
   ``dirichlet_lnpdf  alpha::matrix  theta::matrix``
     implements ``gsl_ran_dirichlet_lnpdf``.
*/

dirichlet_lnpdf  alpha::matrix  theta::matrix
  = apply2_ran gsl_ran_dirichlet_lnpdf alpha theta;

/* .. _discrete_preproc:
   
   ``discrete_preproc  p::matrix``
     implements ``gsl_ran_discrete_preproc`` without the
     ``K`` parameter.
*/

discrete_preproc  p::matrix
  = v
    when
      x = dmatrix p;
      v = gsl_ran_discrete_preproc (#p) (pointer x);
    end
    if rowvectorp p;

/* .. _discrete_pdf:
   
   ``discrete_pdf  k::int  p::pointer``
     implements ``gsl_ran_discrete_pdf`` without the
     ``K`` parameter.
*/

discrete_pdf  k::int  p::pointer
  = gsl_ran_discrete_pdf k p if k >= 0;

/* .. _discrete_free:
   
   ``discrete_free  p::pointer``
     implements ``gsl_ran_discrete_free``
*/

discrete_free  p::pointer
  = gsl_ran_discrete_free p;

/* .. _poisson_pdf:
   
   ``poisson_pdf  k::int  mu``
     implements ``gsl_ran_poisson_pdf``.
*/

poisson_pdf  k::int  mu
  = gsl_ran_poisson_pdf k (double mu) if realp mu && k >= 0;

/* .. _bernoulli_pdf:
   
   ``bernoulli_pdf  k::int  p``
     implements ``gsl_ran_bernoulli_pdf``.
*/

bernoulli_pdf  k::int  p
  = gsl_ran_bernoulli_pdf k (double p) if realp p && k >= 0;

/* .. _binomial_pdf:
   
   ``binomial_pdf  k::int  p  n::int``
     implements ``gsl_ran_binomial_pdf``.
*/

binomial_pdf  k::int  p  n::int
  = gsl_ran_binomial_pdf k (double p) n if realp p && k >= 0 && n > 0;

/* .. _multinomial_pdf:
   
   ``multinomial_pdf  p::matrix  n::matrix``
     implements ``gsl_ran_multinomial_pdf``.
*/

multinomial_pdf  p::matrix  n::matrix
  = apply2_ran gsl_ran_multinomial_pdf p n;

/* .. _multinomial_lnpdf:
   
   ``multinomial_lnpdf  p::matrix  n::matrix``
     implements ``gsl_ran_multinomial_lnpdf``.
*/

multinomial_lnpdf  p::matrix  n::matrix
  = apply2_ran gsl_ran_multinomial_lnpdf p n;

/* .. _negative_binomial_pdf:
   
   ``negative_binomial_pdf  k::int  p  n``
     implements ``gsl_ran_negative_binomial_pdf``.
*/

negative_binomial_pdf  k::int  p  n
  = gsl_ran_negative_binomial_pdf k (double p) (double n)
    if realp p && realp n && k >= 0;

/* .. _pascal_pdf:
   
   ``pascal_pdf  k::int  p  n::int``
     implements ``gsl_ran_pascal_pdf``.
*/

pascal_pdf  k::int  p  n::int
  = gsl_ran_pascal_pdf k (double p) n if realp p && k >= 0;

/* .. _geometric_pdf:
   
   ``geometric_pdf  k::int  p``
     implements ``gsl_ran_geometric_pdf``.
*/

geometric_pdf  k::int  p
  = gsl_ran_geometric_pdf k (double p) if realp p && k >= 1;

/* .. _hypergeometric_pdf:
   
   ``hypergeometric_pdf  k::int  n1::int  n2::int  t::int``
     implements ``gsl_ran_hypergeometric_pdf``.
*/

hypergeometric_pdf  k::int  n1::int  n2::int  t::int
  = gsl_ran_hypergeometric_pdf k n1 n2 t
    if k >= 0 && n1 >= 0 && n2 >= 0 && t >= 0;

/* .. _logarithmic_pdf:
   
   ``logarithmic_pdf  k::int  p``
     implements ``gsl_ran_logarithmic_pdf``.
*/

logarithmic_pdf  k::int  p
  = gsl_ran_logarithmic_pdf k (double p) if k >= 1 && realp p;

namespace gsl::cdf;

private extern double gsl_cdf_ugaussian_P(double);
private extern double gsl_cdf_gaussian_P(double, double);
private extern double gsl_cdf_ugaussian_Q(double);
private extern double gsl_cdf_gaussian_Q(double, double);
private extern double gsl_cdf_ugaussian_Pinv(double);
private extern double gsl_cdf_gaussian_Pinv(double, double);
private extern double gsl_cdf_ugaussian_Qinv(double);
private extern double gsl_cdf_gaussian_Qinv(double, double);
private extern double gsl_cdf_exponential_P(double, double);
private extern double gsl_cdf_exponential_Q(double, double);
private extern double gsl_cdf_exponential_Pinv(double, double);
private extern double gsl_cdf_exponential_Qinv(double, double);
private extern double gsl_cdf_laplace_P(double, double);
private extern double gsl_cdf_laplace_Q(double, double);
private extern double gsl_cdf_laplace_Pinv(double, double);
private extern double gsl_cdf_laplace_Qinv(double, double);
private extern double gsl_cdf_exppow_P(double, double, double);
private extern double gsl_cdf_exppow_Q(double, double, double);
private extern double gsl_cdf_cauchy_P(double, double);
private extern double gsl_cdf_cauchy_Q(double, double);
private extern double gsl_cdf_cauchy_Pinv(double, double);
private extern double gsl_cdf_cauchy_Qinv(double, double);
private extern double gsl_cdf_rayleigh_P(double, double);
private extern double gsl_cdf_rayleigh_Q(double, double);
private extern double gsl_cdf_rayleigh_Pinv(double, double);
private extern double gsl_cdf_rayleigh_Qinv(double, double);
private extern double gsl_cdf_gamma_P(double, double, double);
private extern double gsl_cdf_gamma_Q(double, double, double);
private extern double gsl_cdf_gamma_Pinv(double, double, double);
private extern double gsl_cdf_gamma_Qinv(double, double, double);
private extern double gsl_cdf_flat_P(double, double, double);
private extern double gsl_cdf_flat_Q(double, double, double);
private extern double gsl_cdf_flat_Pinv(double, double, double);
private extern double gsl_cdf_flat_Qinv(double, double, double);
private extern double gsl_cdf_lognormal_P(double, double, double);
private extern double gsl_cdf_lognormal_Q(double, double, double);
private extern double gsl_cdf_lognormal_Pinv(double, double, double);
private extern double gsl_cdf_lognormal_Qinv(double, double, double);
private extern double gsl_cdf_chisq_P(double, double);
private extern double gsl_cdf_chisq_Q(double, double);
private extern double gsl_cdf_chisq_Pinv(double, double);
private extern double gsl_cdf_chisq_Qinv(double, double);
private extern double gsl_cdf_fdist_P(double, double, double);
private extern double gsl_cdf_fdist_Q(double, double, double);
private extern double gsl_cdf_fdist_Pinv(double, double, double);
private extern double gsl_cdf_fdist_Qinv(double, double, double);
private extern double gsl_cdf_tdist_P(double, double);
private extern double gsl_cdf_tdist_Q(double, double);
private extern double gsl_cdf_tdist_Pinv(double, double);
private extern double gsl_cdf_tdist_Qinv(double, double);
private extern double gsl_cdf_beta_P(double, double, double);
private extern double gsl_cdf_beta_Q(double, double, double);
private extern double gsl_cdf_beta_Pinv(double, double, double);
private extern double gsl_cdf_beta_Qinv(double, double, double);
private extern double gsl_cdf_logistic_P(double, double);
private extern double gsl_cdf_logistic_Q(double, double);
private extern double gsl_cdf_logistic_Pinv(double, double);
private extern double gsl_cdf_logistic_Qinv(double, double);
private extern double gsl_cdf_pareto_P(double, double, double);
private extern double gsl_cdf_pareto_Q(double, double, double);
private extern double gsl_cdf_pareto_Pinv(double, double, double);
private extern double gsl_cdf_pareto_Qinv(double, double, double);
private extern double gsl_cdf_weibull_P(double, double, double);
private extern double gsl_cdf_weibull_Q(double, double, double);
private extern double gsl_cdf_weibull_Pinv(double, double, double);
private extern double gsl_cdf_weibull_Qinv(double, double, double);
private extern double gsl_cdf_gumbel1_P(double, double, double);
private extern double gsl_cdf_gumbel1_Q(double, double, double);
private extern double gsl_cdf_gumbel1_Pinv(double, double, double);
private extern double gsl_cdf_gumbel1_Qinv(double, double, double);
private extern double gsl_cdf_gumbel2_P(double, double, double);
private extern double gsl_cdf_gumbel2_Q(double, double, double);
private extern double gsl_cdf_gumbel2_Pinv(double, double, double);
private extern double gsl_cdf_gumbel2_Qinv(double, double, double);
private extern double gsl_cdf_poisson_P(int, double);
private extern double gsl_cdf_poisson_Q(int, double);
private extern double gsl_cdf_binomial_P(int, double, int);
private extern double gsl_cdf_binomial_Q(int, double, int);
private extern double gsl_cdf_negative_binomial_P(int, double, double);
private extern double gsl_cdf_negative_binomial_Q(int, double, double);
private extern double gsl_cdf_pascal_P(int, double, int);
private extern double gsl_cdf_pascal_Q(int, double, int);
private extern double gsl_cdf_geometric_P(int, double);
private extern double gsl_cdf_geometric_Q(int, double);
private extern double gsl_cdf_hypergeometric_P(int, int, int, int);
private extern double gsl_cdf_hypergeometric_Q(int, int, int, int);

public
  ugaussian_P
  gaussian_P
  ugaussian_Q
  gaussian_Q
  ugaussian_Pinv
  gaussian_Pinv
  ugaussian_Qinv
  gaussian_Qinv
  exponential_P
  exponential_Q
  exponential_Pinv
  exponential_Qinv
  laplace_P
  laplace_Q
  laplace_Pinv
  laplace_Qinv
  exppow_P
  exppow_Q
  cauchy_P
  cauchy_Q
  cauchy_Pinv
  cauchy_Qinv
  rayleigh_P
  rayleigh_Q
  rayleigh_Pinv
  rayleigh_Qinv
  gamma_P
  gamma_Q
  gamma_Pinv
  gamma_Qinv
  flat_P
  flat_Q
  flat_Pinv
  flat_Qinv
  lognormal_P
  lognormal_Q
  lognormal_Pinv
  lognormal_Qinv
  chisq_P
  chisq_Q
  chisq_Pinv
  chisq_Qinv
  fdist_P
  fdist_Q
  fdist_Pinv
  fdist_Qinv
  tdist_P
  tdist_Q
  tdist_Pinv
  tdist_Qinv
  beta_P
  beta_Q
  beta_Pinv
  beta_Qinv
  logistic_P
  logistic_Q
  logistic_Pinv
  logistic_Qinv
  pareto_P
  pareto_Q
  pareto_Pinv
  pareto_Qinv
  weibull_P
  weibull_Q
  weibull_Pinv
  weibull_Qinv
  gumbel1_P
  gumbel1_Q
  gumbel1_Pinv
  gumbel1_Qinv
  gumbel2_P
  gumbel2_Q
  gumbel2_Pinv
  gumbel2_Qinv
  poisson_P
  poisson_Q
  binomial_P
  binomial_Q
  negative_binomial_P
  negative_binomial_Q
  pascal_P
  pascal_Q
  geometric_P
  geometric_Q
  hypergeometric_P
  hypergeometric_Q;

/* .. _ugaussian_P: _ugaussian_Q: _ugaussian_Pinv: _ugaussian_Qinv:
   
   ``ugaussian_P  x``
     implements ``gsl_cdf_ugaussian_P``.
   
   ``ugaussian_Q  x``
     implements ``gsl_cdf_ugaussian_Q``.
   
   ``ugaussian_Pinv p``
     implements ``gsl_cdf_ugaussian_Pinv``.
     
   ``ugaussian_Qinv q``
     implements ``gsl_cdf_ugaussian_Qinv``.
*/

ugaussian_P  x
  = gsl_cdf_ugaussian_P (double x) if realp x;

ugaussian_Q  x
  = gsl_cdf_ugaussian_Q (double x) if realp x;

ugaussian_Pinv  p
  = gsl_cdf_ugaussian_Pinv (double p) if realp p;

ugaussian_Qinv  q
  = gsl_cdf_ugaussian_Qinv (double q) if realp q;

/* .. _gaussian_P: _gaussian_Q: _gaussian_Pinv: _gaussian_Qinv:
   
   ``gaussian_P  x  sigma``
     implements ``gsl_cdf_gaussian_P``.
     
   ``gaussian_Q  x  sigma``
     implements ``gsl_cdf_gaussian_Q``.
     
   ``gaussian_Pinv  p  sigma``
     implements ``gsl_cdf_gaussian_Pinv``.
   
   ``guassian_Qinv  q  sigma``
     implements ``gsl_cdf_gaussian_Qinv``.
*/

gaussian_P  x  sigma
  = gsl_cdf_gaussian_P (double x) (double sigma) if realp x && realp sigma;

gaussian_Q  x  sigma
  = gsl_cdf_gaussian_Q (double x) (double sigma) if realp x && realp sigma;

gaussian_Pinv  p  sigma
  = gsl_cdf_gaussian_Pinv (double p) (double sigma) if realp p && realp sigma;

gaussian_Qinv  q  sigma
  = gsl_cdf_gaussian_Qinv (double q) (double sigma) if realp q && realp sigma;

/* .. _exponential_P: _exponential_Q: _exponential_Pinv: _exponential_Qinv:
   
   ``exponential_P  x  mu``
     implements ``gsl_cdf_exponential_P``.
       
   ``exponential_Q  x  mu``
     implements ``gsl_cdf_exponential_Q``.
     
   ``exponential_Pinv  p  mu``
     implements ``gsl_cdf_exponential_Pinv``.
     
   ``exponential_Qinv  q  mu``
     implements ``gsl_cdf_exponential_Qinv``.
*/

exponential_P  x  mu
  = gsl_cdf_exponential_P (double x) (double mu) if realp x && realp mu;

exponential_Q  x  mu
  = gsl_cdf_exponential_Q (double x) (double mu) if realp x && realp mu;

exponential_Pinv  p  mu
  = gsl_cdf_exponential_Pinv (double p) (double mu) if realp p && realp mu;

exponential_Qinv  q  mu
  = gsl_cdf_exponential_Qinv (double q) (double mu) if realp q && realp mu;

/* .. _laplace_P: _laplace_Q: _laplace_Pinv: _laplace_Qinv:
   
   ``laplace_P  x  a``
     implements ``gsl_cdf_laplace_P``.
          
   ``laplace_Q  x  a``
     implements ``gsl_cdf_laplace_Q``.
   
   ``laplace_Pinv  p  a``
     implements ``gsl_cdf_laplace_Pinv``.

   ``laplace_Qinv  q  a``
     implements ``gsl_cdf_laplace_Qinv``.
*/

laplace_P  x  a
  = gsl_cdf_laplace_P (double x) (double a) if realp x && realp a;

laplace_Q  x  a
  = gsl_cdf_laplace_Q (double x) (double a) if realp x && realp a;

laplace_Pinv  p  a
  = gsl_cdf_laplace_Pinv (double p) (double a) if realp p && realp a;

laplace_Qinv  q  a
  = gsl_cdf_laplace_Qinv (double q) (double a)
    if realp q && realp a;

/* .. _exppow_P: _exppow_Q:
   
   ``exppow_P  x  a  b``
     implements ``gsl_cdf_exppow_P``.
     
   ``exppow_Q  x  a  b``
     implements ``gsl_cdf_exppow_Q``.
*/

exppow_P  x  a  b
  = gsl_cdf_exppow_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

exppow_Q  x  a  b
  = gsl_cdf_exppow_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

/* .. _cauchy_P: _cauchy_Q: _cauchy_Pinv: _cauchy_Qinv:
   
   ``cauchy_P  x  a``
     implements ``gsl_cdf_cauchy_P``.
     
   ``cauchy_Q  x  a``
     implements ``gsl_cdf_cauchy_Q``.
     
   ``cauchy_Pinv  p  a``
     implements ``gsl_cdf_cauchy_Pinv``.
     
   ``cauchy_Qinv  q  a``
     implements ``gsl_cdf_cauchy_Qinv``.
*/

cauchy_P  x  a
  = gsl_cdf_cauchy_P (double x) (double a) if realp x && realp a;

cauchy_Q  x  a
  = gsl_cdf_cauchy_Q (double x) (double a) if realp x && realp a;

cauchy_Pinv  p  a
  = gsl_cdf_cauchy_Pinv (double p) (double a) if realp p && realp a;

cauchy_Qinv  q  a
  = gsl_cdf_cauchy_Qinv (double q) (double a) if realp q && realp a;

/* .. _rayleigh_P: _rayleigh_Q: _rayleigh_Pinv: _rayleigh_Qinv:
   
   ``rayleigh_P  x  sigma``
     implements ``gsl_cdf_rayleigh_P``.
     
   ``rayleigh_Q  x  sigma``
     implements ``gsl_cdf_rayleigh_Q``.

   ``rayleigh_Pinv  p  sigma``
     implements ``gsl_cdf_rayleigh_Pinv``.
     
   ``rayleigh_Qinv  q  sigma``
     implements ``gsl_cdf_rayleigh_Qinv``.
*/

rayleigh_P  x  sigma
  = gsl_cdf_rayleigh_P (double x) (double sigma) if realp x && realp sigma;

rayleigh_Q  x  sigma
  = gsl_cdf_rayleigh_Q (double x) (double sigma) if realp x && realp sigma;

rayleigh_Pinv  p  sigma
  = gsl_cdf_rayleigh_Pinv (double p) (double sigma) if realp p && realp sigma;

rayleigh_Qinv  q  sigma
  = gsl_cdf_rayleigh_Qinv (double q) (double sigma) if realp q && realp sigma;

/* .. _gamma_P: _gamma_Q: _gamma_Pinv: _gamma_Qinv:
      
   ``gamma_P  x  a  b``
     implements ``gsl_cdf_gamma_P``.
     
   ``gamma_Q  x  a  b``
     implements ``gsl_cdf_gamMa_Q``.
     
   ``gamma_Pinv  p  a  b``
     implements ``gsl_cdf_gamma_Pinv``.
     
   ``gamma_Qinv  q  a  b``
     implements ``gsl_cdf_gamma_Qinv``.
*/

gamma_P  x  a  b
  = gsl_cdf_gamma_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

gamma_Q  x  a  b
  = gsl_cdf_gamma_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

gamma_Pinv  p  a  b
  = gsl_cdf_gamma_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

gamma_Qinv  q  a  b
  = gsl_cdf_gamma_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

/* .. _flat_P: _flat_Q: _flat_Pinv: _flat_Qinv:
   
   ``flat_P  x  a  b``
     implements ``gsl_cdf_flat_P``.
     
   ``flat_Q  x  a  b``
     implements ``gsl_cdf_flat_Q``.
     
   ``flat_Pinv  p  a  b``
     implements ``gsl_cdf_flat_Pinv``.
     
   ``flat_Qinv  q  a  b``
     implements ``gsl_cdf_flat_Qinv``.
*/

flat_P  x  a  b
  = gsl_cdf_flat_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

flat_Q  x  a  b
  = gsl_cdf_flat_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

flat_Pinv  p  a  b
  = gsl_cdf_flat_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

flat_Qinv  q  a  b
  = gsl_cdf_flat_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

/* .. _lognormal_P: _lognormal_Q: _lognormal_Pinv: _lognormal_Qinv:
   
   ``lognormal_P  x  zeta  sigma``
     implements ``gsl_cdf_lognormal_P``.
     
   ``lognormal_Q  x  zeta  sigma``
     implements ``gsl_cdf_lognormal_Q``.
     
   ``lognormal_Pinv  p  zeta  sigma``
     implements ``gsl_cdf_lognormal_Pinv``.
     
   ``lognormal_Qinv  q  zeta  sigma``
     implements ``gsl_cdf_lognormal_Qinv``.
*/

lognormal_P  x  zeta  sigma
  = gsl_cdf_lognormal_P (double x) (double zeta) (double sigma)
    if realp x && realp zeta && realp sigma;

lognormal_Q  x  zeta  sigma
  = gsl_cdf_lognormal_Q (double x) (double zeta) (double sigma)
    if realp x && realp zeta && realp sigma;

lognormal_Pinv  p  zeta  sigma
  = gsl_cdf_lognormal_Pinv (double p) (double zeta) (double sigma)
    if realp p && realp zeta && realp sigma;

lognormal_Qinv  q  zeta  sigma
  = gsl_cdf_lognormal_Qinv (double q) (double zeta) (double sigma)
    if realp q && realp zeta && realp sigma;

/* .. _chisq_P: _chisq_Q: _chisq_Pinv: _chisq_Qinv:
   
   ``chisq_P  x  nu``
     implements ``gsl_cdf_chisq_P``.
     
   ``chisq_Q  x  nu``
     implements ``gsl_cdf_chisq_Q``.
     
   ``chisq_Pinv  p  nu``
     implements ``gsl_cdf_chisq_Pinv``.
     
   ``chisq_Qinv  q  nu``
     implements ``gsl_cdf_chisq_Qinv``.
*/

chisq_P  x  nu
  = gsl_cdf_chisq_P (double x) (double nu) if realp x && realp nu;

chisq_Q  x  nu
  = gsl_cdf_chisq_Q (double x) (double nu) if realp x && realp nu;

chisq_Pinv  p  nu
  = gsl_cdf_chisq_P (double p) (double nu) if realp p && realp nu;

chisq_Qinv  q  nu
  = gsl_cdf_chisq_Qinv (double q) (double nu) if realp q && realp nu;

/* .. _fdist_P: _fdist_Q: _fdist_Pinv: _fdist_Qinv:
   
   ``fdist_P  x  nu1  nu2``
     implements ``gsl_cdf_fdist_P``.
     
   ``fdist_Q  x  nu1  nu2``
     implements ``gsl_cdf_fdist_Q``.
          
   ``fdist_Pinv  p  nu1  nu2``
     implements ``gsl_cdf_fdist_Pinv``.
     
   ``fdist_Qinv  q  nu1  nu2``
     implements ``gsl_cdf_fdist_Qinv``.
*/

fdist_P  x  nu1  nu2
  = gsl_cdf_fdist_P (double x) (double nu1) (double nu2)
    if realp x && realp nu1 && realp nu2;

fdist_Q  x  nu1  nu2
  = gsl_cdf_fdist_Q (double x) (double nu1) (double nu2)
    if realp x && realp nu1 && realp nu2;

fdist_Pinv  p  nu1  nu2
  = gsl_cdf_fdist_Pinv (double p) (double nu1) (double nu2)
    if realp p && realp nu1 && realp nu2;

fdist_Qinv  q  nu1  nu2
  = gsl_cdf_fdist_Qinv (double q) (double nu1) (double nu2)
    if realp q && realp nu1 && realp nu2;

/* .. _tdist_P: _tdist_Q: _tdist_Pinv: _tdist_Qinv:
   
   ``tdist_P  x  nu``
     implements ``gsl_cdf_tdist_P``.
     
   ``tdist_Q  x  nu``
     implements ``gsl_cdf_tdist_Q``.
     
   ``tdist_Pinv  p  nu``
     implements ``gsl_cdf_tdist_Pinv``.
     
   ``tdist_Qinv  q  nu``
     implements ``gsl_cdf_tdist_Qinv``.
*/

tdist_P  x  nu
  = gsl_cdf_tdist_P (double x) (double nu) if realp x && realp nu;

tdist_Q  x  nu
  = gsl_cdf_tdist_Q (double x) (double nu) if realp x && realp nu;

tdist_Pinv  p  nu
  = gsl_cdf_tdist_Pinv (double p) (double nu) if realp p && realp nu;

tdist_Qinv  q  nu
  = gsl_cdf_tdist_Qinv (double q) (double nu) if realp q && realp nu;

/* .. _beta_P: _beta_Q: _beta_Pinv: _beta_Qinv:
   
   ``beta_P  x  a  b``
     implements ``gsl_cdf_beta_P``.
     
   ``beta_Q  x  a  b``
     implements ``gsl_cdf_beta_Q``.
     
   ``beta_Pinv  p  a  b``
     implements ``gsl_cdf_beta_Pinv``.
     
   ``beta_Qinv  q  a  b``
     implements ``gsl_cdf_beta_Qinv``.
*/

beta_P  x  a  b
  = gsl_cdf_beta_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

beta_Q  x  a  b
  = gsl_cdf_beta_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

beta_Pinv  p  a  b
  = gsl_cdf_beta_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

beta_Qinv  q  a  b
  = gsl_cdf_beta_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

/* .. _logistic_P: _logistic_Q: _logistic_Pinv: _logistic_Qinv:
   
   ``logistic_P  x  a``
     implements ``gsl_cdf_logistic_P``.
     
   ``logistic_Q  x  a``
     implements ``gsl_cdf_logistic_Q``.
     
   ``logistic_Pinv  p  a``
     implements ``gsl_cdf_logistic_Pinv``.
          
   ``logistic_Qinv  q  a``
     implements ``gsl_cdf_logistic_Qinv``.
*/

logistic_P  x  a
  = gsl_cdf_logistic_P (double x) (double a) if realp x && realp a;

logistic_Q  x  a
  = gsl_cdf_logistic_Q (double x) (double a) if realp x && realp a;

logistic_Pinv  p  a
  = gsl_cdf_logistic_Pinv (double p) (double a) if realp p && realp a;

logistic_Qinv  q  a
  = gsl_cdf_logistic_Qinv (double q) (double a) if realp q && realp a;

/* .. _pareto_P: _pareto_Q: _pareto_Pinv: _pareto_Qinv:
   
   ``pareto_P  x  a  b``
     implements ``gsl_cdf_pareto_P``.
     
   ``pareto_Q  x  a  b``
     implements ``gsl_cdf_pareto_Q``.
     
   ``pareto_Pinv  p  a  b``
     implements ``gsl_cdf_pareto_Pinv``.
     
   ``pareto_Qinv  q  a  b``
     implements ``gsl_cdf_pareto_Qinv``.
*/

pareto_P  x  a  b
  = gsl_cdf_pareto_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

pareto_Q  x  a  b
  = gsl_cdf_pareto_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

pareto_Pinv  p  a  b
  = gsl_cdf_pareto_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

pareto_Qinv  q  a  b
  = gsl_cdf_pareto_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

/* .. _weibull_P: _weibull_Q: _weibull_Pinv: _weibull_Qinv:
   
   ``weibull_P  x  a  b``
     implements ``gsl_cdf_weibull_P``.
     
   ``weibull_Q  x  a  b``
     implements ``gsl_cdf_weibull_Q``.
     
   ``weibull_Pinv  p  a  b``
     implements ``gsl_cdf_weibull_Pinv``.
     
   ``weibull_Qinv  q  a  b``
     implements ``gsl_cdf_weibull_Qinv``.
*/

weibull_P  x  a  b
  = gsl_cdf_weibull_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

weibull_Q  x  a  b
  = gsl_cdf_weibull_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

weibull_Pinv  p  a  b
  = gsl_cdf_weibull_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

weibull_Qinv  q  a  b
  = gsl_cdf_weibull_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

/* .. _gumbel1_P: _gumbel1_Q: _gumbel1_Pinv: _gumbel1_Qinv:
   
   ``gumbel1_P  x  a  b``
     implements ``gsl_cdf_gumbel1_P``.
     
   ``gumbel1_Q  x  a  b``
     implements ``gsl_cdf_gumbel1_Q``.
     
   ``gumbel1_Pinv  p  a  b``
     implements ``gsl_cdf_gumbel1_Pinv``.
     
   ``gumbel1_Qinv  q  a  b``
     implements ``gsl_cdf_gumbel1_Qinv``.
*/

gumbel1_P  x  a  b
  = gsl_cdf_gumbel1_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

gumbel1_Q  x  a  b
  = gsl_cdf_gumbel1_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

gumbel1_Pinv  p  a  b
  = gsl_cdf_gumbel1_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

gumbel1_Qinv  q  a  b
  = gsl_cdf_gumbel1_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

/* .. _gumbel2_P: _gumbel2_Q: _gumbel2_Pinv: _gumbel2_Qinv:
   
   ``gumbel2_P  x  a  b``
     implements ``gsl_cdf_gumbel2_P``.
     
   ``gumbel2_Q  x  a  b``
     implements ``gsl_cdf_gumbel2_Q``.
 
   ``gumbel2_Pinv  p  a  b``
     implements ``gsl_cdf_gumbel2_Pinv``.

   ``gumbel2_Qinv  q  a  b``
     implements ``gsl_cdf_gumbel2_Qinv``.
*/

gumbel2_P  x  a  b
  = gsl_cdf_gumbel2_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

gumbel2_Q  x  a  b
  = gsl_cdf_gumbel2_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

gumbel2_Pinv  p  a  b
  = gsl_cdf_gumbel2_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

gumbel2_Qinv  q  a  b
  = gsl_cdf_gumbel2_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

/* .. _poisson_P: _poisson_Q:
   
   ``poisson_P  k::int  mu``
     implements ``gsl_cdf_poisson_P``.
     
   ``poisson_Q  k::int  mu``
     implements ``gsl_cdf_poisson_Q``.
*/

poisson_P  k::int  mu
  = gsl_cdf_poisson_P k (double mu) if realp mu && k >= 0;

poisson_Q  k::int  mu
  = gsl_cdf_poisson_Q k (double mu) if realp mu && k >= 0;

/* .. _binomial_P: _binomial_Q:
   
   ``binomial_P  k::int  p  n::int``
     implements ``gsl_cdf_binomial_P``.
     
   ``binomial_Q  k::int  q  n::int``
     implements ``gsl_cdf_binomial_Q``.
*/

binomial_P  k::int  p  n::int
  = gsl_cdf_binomial_P k (double p) n if realp p && k >= 0 && n > 0;

binomial_Q  k::int  q  n::int
  = gsl_cdf_binomial_Q k (double q) n if realp q && k >= 0 && n > 0;

/* .. _negative_binomial_P: _negative_binomial_Q:
   
   ``negative_binomial_P  k::int  p  n``
     implements ``gsl_cdf_negative_binomial_P``.
      
   ``negative_binomial_Q  k::int  p  n``
     implements ``gsl_cdf_negative_binomial_Q``.
*/

negative_binomial_P  k::int  p  n
  = gsl_cdf_negative_binomial_P k (double p) (double n)
    if realp p && realp n && k >= 0;

negative_binomial_Q  k::int  p  n
  = gsl_cdf_negative_binomial_Q k (double p) (double n)
    if realp p && realp n && k >= 0;

/* .. _pascal_P:
      _pascal_Q:
   
   ``pascal_P  k::int  p  n::int``
     implements ``gsl_cdf_pascal_P``.
 
   ``pascal_Q  k::int  p  n::int``
     implements ``gsl_cdf_pascal_Q``.
*/

pascal_P  k::int  p  n::int
  = gsl_cdf_pascal_P k (double p) n if realp p && k >= 0;

pascal_Q  k::int  p  n::int
  = gsl_cdf_pascal_Q k (double p) n if realp p && k >= 0;

/* .. _geometric_P: _geometric_Q:
   
   ``geometric_P  k::int  p``
     implements ``gsl_cdf_geometric_P``.
     
   ``geometric_Q  k::int  p``
     implements ``gsl_cdf_geometric_Q``.
*/

geometric_P  k::int  p
  = gsl_cdf_geometric_P k (double p) if realp p && k >= 1;

geometric_Q  k::int  p
  = gsl_cdf_geometric_Q k (double p) if realp p && k >= 1;

/* .. _hypergeometric_P: _hypergeometric_Q:
   
   ``hypergeometric_P  k::int  n1::int  n2::int  t::int``
     implements ``gsl_cdf_hypergeometric_P``.
          
   ``hypergeometric_Q  k::int  n1::int  n2::int  t::int``
     implements ``gsl_cdf_hypergeometric_Q``.
*/

hypergeometric_P  k::int  n1::int  n2::int  t::int
  = gsl_cdf_hypergeometric_P k n1 n2 t
    if k >= 0 && n1 >= 0 && n2 >= 0 && t >= 0;

hypergeometric_Q  k::int  n1::int  n2::int  t::int
  = gsl_cdf_hypergeometric_Q k n1 n2 t
    if k >= 0 && n1 >= 0 && n2 >= 0 && t >= 0;

/*  ..
   
   Examples
   ~~~~~~~~
   
   The following illustrates the use of each function in the ``randist`` module.
   The pdf functions are illustrated first.
      
   ::
     
     > using gsl::stats;
     > using namespace gsl::ran;
     > ugaussian_pdf 1.2;
     0.194186054983213
     > gaussian_pdf (-1.3) 1.5;
     0.182690978264686
     > gaussian_tail_pdf 2.0 1.0 1.5;
     0.433042698395299
     > ugaussian_tail_pdf 2.0 1.0;
     0.34030367841782
     > bivariate_gaussian_pdf 1.2 0.9 1.0 1.0 0.95;
     0.184646843689817
     > exponential_pdf 1.0 0.5;
     0.270670566473225
     > laplace_pdf 1.5 2.0;
     0.118091638185254
     > exppow_pdf 0.0 1.0 1.5;
     0.553866083716236
     > cauchy_pdf (-1.0) 1.0;
     0.159154943091895
     > rayleigh_pdf 2.5 1.0;
     0.109842334058519
     > rayleigh_tail_pdf 1.5 1.0 1.0;
     0.802892142778485
     > landau_pdf 1.1;
     0.140968737919623
     > gamma_pdf 1.0 1.0 1.5;
     0.342278079355061
     > flat_pdf 1.0 0.5 2.5;
     0.5
     > lognormal_pdf 0.01 0.0 1.0;
     0.000990238664959182
     > chisq_pdf 1.0 2.0;
     0.303265329856317
     > fdist_pdf 0.5 3.0 2.0;
     0.480970043785452
     > tdist_pdf 0.1 10.0;
     0.386975225815181
     > beta_pdf 0.5 4.0 1.0;
     0.499999999999999
     > logistic_pdf (-1.0) 2.0;
     0.117501856100797
     > pareto_pdf 0.01 3.0 2.0;
     0.0
     > weibull_pdf  0.01 1.0 1.0;
     0.990049833749168
     > gumbel1_pdf 0.01 1.0 1.0;
     0.367861108816436
     > gumbel2_pdf 0.01 1.0 1.0;
     3.72007597602084e-40
     > dirichlet_pdf {0.1,0.2,0.8} {2.0,2.0,2.0};
     0.00501316294425874
     > dirichlet_lnpdf {0.1,0.2,0.8} {2.0,2.0,2.0};
     -5.29568823688856
     > poisson_pdf 4 0.4;
     0.000715008049104682
     > bernoulli_pdf 1 0.7;
     0.7
     > binomial_pdf 3 0.5 9;
     0.1640625
     > multinomial_pdf {0.1,0.2,0.7} {2,2,2};
     0.0
     > multinomial_lnpdf {0.1,0.2,0.7} {2,2,2};
     -1728120799.71174
     > negative_binomial_pdf 10 0.5 3.5;
     0.0122430486923836
     > pascal_pdf 10 0.5 3;
     0.00805664062499999
     > geometric_pdf 5 0.4;
     0.05184
     > hypergeometric_pdf 1 5 20 3;
     0.413043478260872
     > logarithmic_pdf 10 0.7; 
     0.00234619293712492
     > test_discrete
     >   = v
     >     when
     >       px = discrete_preproc {0.1,0.3,0.4};
     >       v = discrete_pdf 0 px +
     >           discrete_pdf 1 px +
     >           discrete_pdf 2 px;
     >       _ = discrete_free px
     >     end;
     > test_discrete;
     1.0
       
   The cumulative distribution functions are shown.
   
   ::
     
     > ugaussian_P  (-1.3);
     0.0968004845856103
     > ugaussian_Q  (-1.3);
     0.90319951541439
     > ugaussian_Pinv  0.84;
     0.994457883209753
     > ugaussian_Qinv  0.84;
     -0.994457883209753
     > gaussian_P  (1.3)  1.5;
     0.806937662858093
     > gaussian_Q  (1.3)  1.5;
     0.193062337141907
     > gaussian_Pinv  0.4  5.0;
     -1.266735515679
     > gaussian_Qinv  0.4 5.0;
     1.266735515679
     > exponential_P  1.0  0.5;
     0.864664716763387
     > exponential_Q  1.0  0.5;
     0.135335283236613
     > exponential_Pinv  0.6  0.5;
     0.458145365937077
     > exponential_Qinv  0.6  0.5;
     0.255412811882995
     > laplace_P  1.5  2.0;
     0.763816723629493
     > laplace_Q  1.5  2.0;
     0.236183276370507
     > laplace_Pinv  0.6  2.0;
     0.446287102628419
     > laplace_Qinv  0.4  2.0;
     0.446287102628419
     > exppow_P  0.0  1.0  2.5;
     0.5
     > exppow_Q  0.0  1.0  0.5;
     0.5
     > cauchy_P  (-1.0)  1.0;
     0.25
     > cauchy_Q  (-1.0)  1.0;
     0.75
     > cauchy_Pinv  0.75  1.0;
     1.0
     > cauchy_Qinv  0.25  1.0;
     1.0
     > rayleigh_P  1.5  2.0;
     0.245160398010993
     > rayleigh_Q  0.5  1.0;
     0.882496902584595
     > rayleigh_Pinv  0.5  1.0;
     1.17741002251547
     > rayleigh_Qinv  0.5  1.0;
     1.17741002251547
     > gamma_P  1.0  1.0  3.0;
     0.283468689426211
     > gamma_Q  1.0  1.0  3.0;
     0.716531310573789
     > gamma_Pinv  0.5  1.0  1.0;
     0.693147180559945
     > gamma_Qinv  0.5  1.0  1.0;
     0.693147180559945
     > flat_P  2.0  1.2  4.8;
     0.222222222222222
     > flat_Q  2.0  1.2  4.8;
     0.777777777777778
     > flat_Pinv  0.2  0.5  2.5;
     0.9
     > flat_Qinv  0.2  0.5  2.5;
     2.1
     > lognormal_P  0.01  0.0  1.0;
     2.06064339597172e-06
     > lognormal_Q  0.01  0.0  1.0;
     0.999997939356604
     > lognormal_Pinv  0.1  0.0  1.0;
     0.27760624185201
     > lognormal_Qinv  0.1  0.0  1.0;
     3.60222447927916
     > chisq_P  1.0  2.0;
     0.393469340287367
     > chisq_Q  1.0  2.0;
     0.606530659712633
     > chisq_Pinv  0.5  2.0;
     0.221199216928595
     > chisq_Qinv  0.5  2.0;
     1.38629436111989
     > fdist_P  1.0  3.0  2.0;
     0.46475800154489
     > fdist_Q  1.0  3.0  2.0;
     0.53524199845511
     > fdist_Pinv  0.5  3.0  2.0;
     1.13494292261288
     > fdist_Qinv  0.5  3.0  2.0;
     1.13494292261288
     > tdist_P  2.1  10.0;
     0.968961377898891
     > tdist_Q  (-2.1)  10.0;
     0.968961377898891
     > tdist_Pinv  0.68  10.0;
     0.482264205919689
     > tdist_Qinv  0.68  10.0;
     -0.482264205919689
     > beta_P  0.75  2.0  2.0;
     0.84375
     > beta_Q  0.75  2.0  2.0;
     0.15625
     > beta_Pinv  0.75  2.0  2.0;
     0.673648177666931
     > beta_Qinv  0.25  2.0  2.0;
     0.673648177666931
     > logistic_P  (-1.0)  2.0;
     1
     > logistic_Q  (-1.0)  2.0;
     0.622459331201855
     > logistic_Pinv  0.75  1.0;
     1.09861228866811
     > logistic_Qinv  0.25  1.0;
     1.09861228866811
     > pareto_P  2.01  3.0  2.0;
     0.0148512406901899
     > pareto_Q  2.01  3.0  2.0;
     0.98514875930981
     > pareto_Pinv  0.1  3.0  2.0;
     2.07148833730257
     > pareto_Qinv  0.1  3.0  2.0;
     4.30886938006377
     > weibull_P  1.01  1.0  2.0;
     0.639441117518024
     > weibull_Q  1.01  2.0  3.0;
     0.879160657465162
     > weibull_Pinv  0.1  1.0  2.0;
     0.324592845974501
     > weibull_Qinv  0.1  1.0  2.0;
     1.51742712938515
     > gumbel1_P  1.01  1.0  1.0;
     0.694739044426344
     > gumbel1_Q  1.01  1.0  1.0;
     0.305260955573656
     > gumbel1_Pinv  0.1  1.0  1.0;
     -0.834032445247956
     > gumbel1_Qinv  0.1  1.0  1.0;
     2.25036732731245
     > gumbel2_P  1.01  1.0  1.0;
     0.371539903071873
     > gumbel2_Q  1.01  1.0  1.0;
     0.628460096928127
     > gumbel2_Pinv  0.1  1.0  1.0;
     0.434294481903252
     > gumbel2_Qinv  0.1  1.0  1.0;
     9.4912215810299
     > poisson_P  4  0.4;
     0.999938756672898
     > poisson_Q  4  0.6;
     0.000394486018340255
     > binomial_P  3  0.5  10;
     0.171874999999999
     > binomial_Q  3  0.5  10;
     0.828125000000001
     > negative_binomial_P  10  0.5  3.0;
     0.98876953125
     > negative_binomial_Q  10  0.5  3.0;
     0.01123046875
     > pascal_P  10  0.5  3;
     0.98876953125
     > pascal_Q  10  0.5  3;
     0.01123046875
     > geometric_P  5  0.4;
     0.92224
     > geometric_Q  5  0.6;
     0.01024
     > hypergeometric_P  1  5  20  3;
     0.908695652173913
     > hypergeometric_Q  1  5  20  3;
     0.0913043478260873
*/
