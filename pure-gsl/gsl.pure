
/* gsl.pure: GSL wrapper for the Pure programming language. */

/* Copyright (c) 2008 by Albert Graef <Dr.Graef@t-online.de>.
   Copyright (c) 2008 by Robert E. Rucker <erucker@bmc.edu>.

   This file is part of the Pure programming language and system.

   Pure is free software: you can redistribute it and/or modify it under the
   terms of the GNU General Public License as published by the Free Software
   Foundation, either version 3 of the License, or (at your option) any later
   version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
   details.

   You should have received a copy of the GNU General Public License along
   with this program.  If not, see <http://www.gnu.org/licenses/>. */

using "lib:gsl";

/* Additional matrix operators: element-wise multiplication, division,
   exponentiation, and left division. Note that left division is denoted '\\',
   since the backslash is already used for lambdas in Pure. */

infixl 7 .* ./ \\;
infixr 8 .^ ;

/* Additional number predicates. gsl_complexp checks if a Pure expression
   represents a valid GSL complex value (which is a Pure complex value whose
   real and imaginary components are either double or machine int values).
   gsl_scalarp checks for any kind of Pure number which passes muster as a
   scalar in GSL land (i.e., int, double, GSL complex value). */

extern bool gsl_complexp(expr*);
gsl_scalarp x = intp x || doublep x || gsl_complexp x;

/* Complex functions. */

extern expr* wrap_gsl_complex_sqrt(expr*) = gsl_complex_sqrt;

/* Utility matrices. zeros and ones create matrices with all elements zero or
   one, respectively, and eye creates identity matrices. These functions can
   be invoked either with a pair (n,m) denoting the desired number of rows or
   columns, or an integer n in which case a square nxn matrix is created. The
   result is always a double matrix. */

zeros (n::int,m::int)	= dmatrix (n,m);
zeros n::int		= zeros (n,n);

extern void gsl_matrix_set_all(dmatrix*, double);
ones (n::int,m::int)	= x when
			    x = dmatrix (n,m);
			    _ = gsl_matrix_set_all x 1.0;
			  end;
ones n::int		= ones (n,n);

extern void gsl_matrix_set_identity(dmatrix*);
eye (n::int,m::int)	= x when
			    x = dmatrix (n,m);
			    _ = gsl_matrix_set_identity x;
			  end;
eye n::int		= eye (n,n);

/* Complex and integer matrix variations of the above. */

czeros (n::int,m::int)	= cmatrix (n,m);
czeros n::int		= czeros (n,n);

extern void wrap_gsl_matrix_complex_set_all(cmatrix*, expr*)
 = gsl_matrix_complex_set_all;
cones (n::int,m::int)	= x when
			    x = cmatrix (n,m);
			    _ = gsl_matrix_complex_set_all x 1.0;
			  end;
cones n::int		= cones (n,n);

extern void gsl_matrix_complex_set_identity(cmatrix*);
ceye (n::int,m::int)	= x when
			    x = cmatrix (n,m);
			    _ = gsl_matrix_complex_set_identity x;
			  end;
ceye n::int		= ceye (n,n);

izeros (n::int,m::int)	= imatrix (n,m);
izeros n::int		= izeros (n,n);

extern void gsl_matrix_int_set_all(imatrix*, int);
iones (n::int,m::int)	= x when
			    x = imatrix (n,m);
			    _ = gsl_matrix_int_set_all x 1;
			  end;
iones n::int		= iones (n,n);

extern void gsl_matrix_int_set_identity(imatrix*);
ieye (n::int,m::int)	= x when
			    x = imatrix (n,m);
			    _ = gsl_matrix_int_set_identity x;
			  end;
ieye n::int		= ieye (n,n);

/* Matrix-scalar operations. */

extern int gsl_matrix_add_constant(dmatrix*, double);
extern int wrap_gsl_matrix_complex_add_constant(cmatrix*, expr*)
 = gsl_matrix_complex_add_constant;
extern int gsl_matrix_int_add_constant(imatrix*, double);

a + x::matrix		|
x::matrix + a		= if gsl_complexp a then
			    // complex matrix result
			    (x when x = pack (cmatrix x);
			       _ = gsl_matrix_complex_add_constant x a end)
			  else if imatrixp x && intp a then
			    // int matrix result
			    (x when x = pack x;
			       _ = gsl_matrix_int_add_constant x (double a)
			     end)
			  else
			    // other numeric matrices; ints get promoted to
			    // double here
			    (x when
			       x = pack (if imatrixp x then dmatrix x else x);
			       a = double a;
			       _ = case matrix_type x of
			             1 = gsl_matrix_add_constant x a;
			             2 = gsl_matrix_complex_add_constant x a;
			             3 = gsl_matrix_add_constant x a;
			           end
			     end)
			  if nmatrixp x && gsl_scalarp a;
// symbolic cases
a + x::matrix		= map (\x->a+x) x if ~matrixp a;
x::matrix + a		= map (\x->x+a) x if ~matrixp a;

a - x::matrix		= (-x)+a if nmatrixp x && gsl_scalarp a;
x::matrix - a		= x+(-a) if nmatrixp x && gsl_scalarp a;
a - x::matrix		= map (\x->a-x) x if ~matrixp a;
x::matrix - a		= map (\x->x-a) x if ~matrixp a;

extern int gsl_matrix_scale(dmatrix*, double);
extern int wrap_gsl_matrix_complex_scale(cmatrix*, expr*)
 = gsl_matrix_complex_scale;
extern int gsl_matrix_int_scale(imatrix*, double);

a * x::matrix		|
x::matrix * a		= if gsl_complexp a then
			    // complex matrix result
			    (x when x = pack (cmatrix x);
			       _ = gsl_matrix_complex_scale x a end)
			  else if imatrixp x && intp a then
			    // int matrix result
			    (x when x = pack x;
			       _ = gsl_matrix_int_scale x (double a) end)
			  else
			    // other numeric matrices; ints get promoted to
			    // double here
			    (x when
			       x = pack (if imatrixp x then dmatrix x else x);
			       a = double a;
			       _ = case matrix_type x of
			             1 = gsl_matrix_scale x a;
			             2 = gsl_matrix_complex_scale x a;
			             3 = gsl_matrix_scale x a;
			           end
			     end)
			  if nmatrixp x && gsl_scalarp a;
// symbolic cases
a * x::matrix		= map (\x->a*x) x if ~matrixp a;
x::matrix * a		= map (\x->x*a) x if ~matrixp a;

a / x::matrix		= a*ones(dim x)./x if nmatrixp x && gsl_scalarp a;
x::matrix / a		= x*(1/a) if nmatrixp x && gsl_scalarp a;
a / x::matrix		= map (\x->a/x) x if ~matrixp a;
x::matrix / a		= map (\x->x/a) x if ~matrixp a;

/* Some additional matrix-scalar operations which aren't in GSL, but are
   provided as matrix-matrix operations below. */

a ^ x::matrix		= (a*ones(dim x)).^x if nmatrixp x && gsl_scalarp a;
x::matrix ^ a		= x.^(a*ones(dim x)) if nmatrixp x && gsl_scalarp a;
a ^ x::matrix		= map (\x->a^x) x if ~matrixp a;
x::matrix ^ a		= map (\x->x^a) x if ~matrixp a;

/* Integer matrix-scalar operations. */

a div x::matrix		= (a*iones(dim x)) div x if imatrixp x && intp a;
x::matrix div a		= x div (a*iones(dim x)) if imatrixp x && intp a;
a div x::matrix		= map (\x->a div x) x if ~matrixp a;
x::matrix div a		= map (\x->x div a) x if ~matrixp a;

a mod x::matrix		= (a*iones(dim x)) mod x if imatrixp x && intp a;
x::matrix mod a		= x mod (a*iones(dim x)) if imatrixp x && intp a;
a mod x::matrix		= map (\x->a mod x) x if ~matrixp a;
x::matrix mod a		= map (\x->x mod a) x if ~matrixp a;

a << x::matrix		= (a*iones(dim x)) << x if imatrixp x && intp a;
x::matrix << a		= x << (a*iones(dim x)) if imatrixp x && intp a;
a << x::matrix		= map (\x->a << x) x if ~matrixp a;
x::matrix << a		= map (\x->x << a) x if ~matrixp a;

a >> x::matrix		= (a*iones(dim x)) >> x if imatrixp x && intp a;
x::matrix >> a		= x >> (a*iones(dim x)) if imatrixp x && intp a;
a >> x::matrix		= map (\x->a >> x) x if ~matrixp a;
x::matrix >> a		= map (\x->x >> a) x if ~matrixp a;

a and x::matrix		= (a*iones(dim x)) and x if imatrixp x && intp a;
x::matrix and a		= x and (a*iones(dim x)) if imatrixp x && intp a;
a and x::matrix		= map (\x->a and x) x if ~matrixp a;
x::matrix and a		= map (\x->x and a) x if ~matrixp a;

a or x::matrix		= (a*iones(dim x)) or x if imatrixp x && intp a;
x::matrix or a		= x or (a*iones(dim x)) if imatrixp x && intp a;
a or x::matrix		= map (\x->a or x) x if ~matrixp a;
x::matrix or a		= map (\x->x or a) x if ~matrixp a;

/* Matrix-matrix operations. */

extern int gsl_matrix_add(dmatrix*, dmatrix*);
extern int gsl_matrix_complex_add(cmatrix*, cmatrix*);
extern int gsl_matrix_int_add(imatrix*, imatrix*);

x::matrix + y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= x when
			    x = pack x;
			    _ = case matrix_type x of
			      1 = gsl_matrix_add x y;
			      2 = gsl_matrix_complex_add x y;
			      3 = gsl_matrix_int_add x y;
			    end;
			  end if nmatrixp x && matrix_type x == matrix_type y;
// mixed numeric cases
			= cmatrix x + y if nmatrixp x && cmatrixp y;
			= x + cmatrix y if cmatrixp x && nmatrixp y;
			= dmatrix x + y if imatrixp x && dmatrixp y;
			= x + dmatrix y if dmatrixp x && imatrixp y;
// symbolic matrix operations
			= zipwith (+) x y;

extern int gsl_matrix_sub(dmatrix*, dmatrix*);
extern int gsl_matrix_complex_sub(cmatrix*, cmatrix*);
extern int gsl_matrix_int_sub(imatrix*, imatrix*);

x::matrix - y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= x when
			    x = pack x;
			    _ = case matrix_type x of
			      1 = gsl_matrix_sub x y;
			      2 = gsl_matrix_complex_sub x y;
			      3 = gsl_matrix_int_sub x y;
			    end;
			  end if nmatrixp x && matrix_type x == matrix_type y;
// mixed numeric cases
			= cmatrix x - y if nmatrixp x && cmatrixp y;
			= x - cmatrix y if cmatrixp x && nmatrixp y;
			= dmatrix x - y if imatrixp x && dmatrixp y;
			= x - dmatrix y if dmatrixp x && imatrixp y;
// symbolic matrix operations
			= zipwith (-) x y;

extern int gsl_matrix_mul_elements(dmatrix*, dmatrix*);
extern int gsl_matrix_complex_mul_elements(cmatrix*, cmatrix*);
extern int gsl_matrix_int_mul_elements(imatrix*, imatrix*);

x::matrix .* y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= x when
			    x = pack x;
			    _ = case matrix_type x of
			      1 = gsl_matrix_mul_elements x y;
			      2 = gsl_matrix_complex_mul_elements x y;
			      3 = gsl_matrix_int_mul_elements x y;
			    end;
			  end if nmatrixp x && matrix_type x == matrix_type y;
// mixed numeric cases
			= cmatrix x .* y if nmatrixp x && cmatrixp y;
			= x .* cmatrix y if cmatrixp x && nmatrixp y;
			= dmatrix x .* y if imatrixp x && dmatrixp y;
			= x .* dmatrix y if dmatrixp x && imatrixp y;
// symbolic matrix operations
			= zipwith (*) x y;

extern int gsl_matrix_div_elements(dmatrix*, dmatrix*);
extern int gsl_matrix_complex_div_elements(cmatrix*, cmatrix*);

x::matrix ./ y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= dmatrix x ./ dmatrix y if imatrixp x && imatrixp y;
			= x when
			    x = pack x;
			    _ = case matrix_type x of
			      1 = gsl_matrix_div_elements x y;
			      2 = gsl_matrix_complex_div_elements x y;
			    end;
			  end if nmatrixp x && matrix_type x == matrix_type y;
// mixed numeric cases
			= cmatrix x ./ y if nmatrixp x && cmatrixp y;
			= x ./ cmatrix y if cmatrixp x && nmatrixp y;
			= dmatrix x ./ y if imatrixp x && dmatrixp y;
			= x ./ dmatrix y if dmatrixp x && imatrixp y;
// symbolic matrix operations
			= zipwith (/) x y;

/* Element-wise exponentiation. This isn't in GSL so we provide it in
   gsl.c. */

extern int gsl_matrix_pow_elements(dmatrix*, dmatrix*);
extern int gsl_matrix_complex_pow_elements(cmatrix*, cmatrix*);

x::matrix .^ y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= dmatrix x .^ dmatrix y if imatrixp x && imatrixp y;
			= x when
			    x = pack x;
			    _ = case matrix_type x of
			      1 = gsl_matrix_pow_elements x y;
			      2 = gsl_matrix_complex_pow_elements x y;
			    end;
			  end if nmatrixp x && matrix_type x == matrix_type y;
// mixed numeric cases
			= cmatrix x .^ y if nmatrixp x && cmatrixp y;
			= x .^ cmatrix y if cmatrixp x && nmatrixp y;
			= dmatrix x .^ y if imatrixp x && dmatrixp y;
			= x .^ dmatrix y if dmatrixp x && imatrixp y;
// symbolic matrix operations
			= zipwith (^) x y;

/* Element-wise operations on int matrices. These aren't in GSL so we provide
   them in gsl.c. */

extern int gsl_matrix_int_div(imatrix*, imatrix*);
extern int gsl_matrix_int_mod(imatrix*, imatrix*);
extern int gsl_matrix_int_shl(imatrix*, imatrix*);
extern int gsl_matrix_int_shr(imatrix*, imatrix*);
extern int gsl_matrix_int_or(imatrix*, imatrix*);
extern int gsl_matrix_int_and(imatrix*, imatrix*);
extern int gsl_matrix_int_not(imatrix*);

x::matrix div y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= if r==0 then x else 1 div 0 when
			    x = pack x;
			    r = gsl_matrix_int_div x y;
			  end if imatrixp x && imatrixp y;
			= zipwith (div) x y;

x::matrix mod y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= if r==0 then x else 1 mod 0 when
			    x = pack x;
			    r = gsl_matrix_int_mod x y;
			  end if imatrixp x && imatrixp y;
			= zipwith (mod) x y;

x::matrix << y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= x when
			    x = pack x;
			    _ = gsl_matrix_int_shl x y;
			  end if imatrixp x && imatrixp y;
			= zipwith (<<) x y;

x::matrix >> y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= x when
			    x = pack x;
			    _ = gsl_matrix_int_shr x y;
			  end if imatrixp x && imatrixp y;
			= zipwith (>>) x y;

x::matrix and y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= x when
			    x = pack x;
			    _ = gsl_matrix_int_and x y;
			  end if imatrixp x && imatrixp y;
			= zipwith (and) x y;

x::matrix or y::matrix	= throw (bad_matrix_value y) if dim x~=dim y;
			= x when
			    x = pack x;
			    _ = gsl_matrix_int_or x y;
			  end if imatrixp x && imatrixp y;
			= zipwith (or) x y;

not x::matrix		= x when
			    x = pack x;
			    _ = gsl_matrix_int_not x;
			  end if imatrixp x;
			= map (not) x;

/* Unary minus. */

-x::matrix		= (-1)*x if nmatrixp x;
			= map neg x;

/* Matrix multiplication is implemented via the BLAS interface (actually a
   thin wrapper around the BLAS routines, as we don't need all the arguments).
   BLAS doesn't support integer matrices, currently we emulate these by
   converting to double matrices and then back to integer. */

extern int gsl_matrix_multiply(dmatrix*, dmatrix*, dmatrix*);
extern int gsl_matrix_complex_multiply(cmatrix*, cmatrix*, cmatrix*);

x::matrix * y::matrix	= throw (bad_matrix_value y) if dim x!1~=dim y!0;
			= z when
			    mat = [dmatrix,cmatrix,dmatrix]!(matrix_type x-1);
			    z = mat (dim x!0,dim y!1);
			    _ = if null z then () else
			    (case matrix_type x of
			       1 = gsl_matrix_multiply x y z;
			       2 = gsl_matrix_complex_multiply x y z;
			       3 = gsl_matrix_multiply
			           (dmatrix x) (dmatrix y) z;
			     end);
			    z = if imatrixp x then imatrix z else z;
			  end if nmatrixp x && matrix_type x == matrix_type y;
// mixed numeric cases
			= cmatrix x * y if nmatrixp x && cmatrixp y;
			= x * cmatrix y if cmatrixp x && nmatrixp y;
			= dmatrix x * y if imatrixp x && dmatrixp y;
			= x * dmatrix y if dmatrixp x && imatrixp y;
// symbolic matrix multiplication
			= redim (dim x!0,dim y!1)
			  {dot u v | u = rows x; v = cols y}
			  with dot x::matrix y::matrix =
			    foldl (+) 0 [x!i*y!i | i=0..#x-1];
			  end;

/* Powers of matrices. x must be a square matrix, k a nonnegative integer. */

pow x::matrix k::int	= throw (bad_matrix_value x) if dim x!0~=dim x!1;
			= case matrix_type x of
			    1 = eye (dim x!0);
			    2 = ceye (dim x!0);
			    _ = ieye (dim x!0);
			  end if k==0;
			= x if k==1;
			= if k mod 2 then y*y*x else y*y
			  when y = pow x (k>>1) end if k>1;
pow x::matrix k::bigint	= pow x (int k);

/* Singular value decompositions. For a given nxm matrix x, these yield a
   singular-value decomposition u,s,v of the matrix such that x==u*s*v', where
   u and v are orthogonal matrices of dimensions nxm and nxn, respectively,
   and s is a nxn diagonal matrix which has the singular values in its
   diagonal, in descending order. Note that GSL implements this only for
   double matrices right now. Also, GSL only handles the case of square or
   overdetermined systems, but we work around that in our wrapper functions by
   just adding a suitable number of zero rows in the underdetermined case.  */

/* This uses the Golub-Reinsch algorithm. */

extern int wrap_gsl_linalg_SV_decomp
(dmatrix* A, dmatrix* V, dmatrix* S, dmatrix* work) = gsl_linalg_SV_decomp;

svd x::matrix		= throw (bad_matrix_value x)
			    if cmatrixp x || smatrixp x;
			= u!!(0..n-1,0..m-1),s,v when
			    n,m = dim x;
			    u,s,v = svd {dmatrix x;dmatrix (m-n,m)};
			  end if dim x!0<dim x!1;
			= u,s,v when n,m = dim x;
			    u = pack (dmatrix x); v = dmatrix (m,m);
			    s = dmatrix (m,m); w = dmatrix m;
			    _ = gsl_linalg_SV_decomp u v s w;
			  end;

/* This uses the modified Golub-Reinsch algorithm, which is faster if n>>m but
   needs O(m^2) extra memory as internal workspace. */

extern int wrap_gsl_linalg_SV_decomp_mod
(dmatrix* A, dmatrix* X, dmatrix* V, dmatrix* S, dmatrix* work)
 = gsl_linalg_SV_decomp_mod;

svd_mod x::matrix	= throw (bad_matrix_value x)
			    if cmatrixp x || smatrixp x;
			= u!!(0..n-1,0..m-1),s,v when
			    n,m = dim x;
			    u,s,v = svd_mod {dmatrix x;dmatrix (m-n,m)};
			  end if dim x!0<dim x!1;
			= u,s,v when n,m = dim x;
			    u = pack (dmatrix x); v = dmatrix (m,m);
			    s = dmatrix (m,m); w = dmatrix m;
			    y = dmatrix (m,m);
			    _ = gsl_linalg_SV_decomp_mod u y v s w;
			  end;

/* This uses one-sided Jacobi orthogonalization which provides better relative
   accuracy but is slower. */

extern int wrap_gsl_linalg_SV_decomp_jacobi
(dmatrix* A, dmatrix* V, dmatrix* S) = gsl_linalg_SV_decomp_jacobi;

svd_jacobi x::matrix	= throw (bad_matrix_value x)
			    if cmatrixp x || smatrixp x;
			= u!!(0..n-1,0..m-1),s,v when
			    n,m = dim x;
			    u,s,v = svd_jacobi {dmatrix x;dmatrix (m-n,m)};
			  end if dim x!0<dim x!1;
			= u,s,v when n,m = dim x;
			    u = pack (dmatrix x); v = dmatrix (m,m);
			    s = dmatrix (m,m);
			    _ = gsl_linalg_SV_decomp_jacobi u v s;
			  end;

/* Solve the system Ax=b, using the SVD of A. Our wrapper svd_solve takes the
   result (u,s,v) of a svd call, and a column vector b of the appropriate
   dimension. The result is another column vector solving the system (possibly
   in the least-squares sense). */

extern int wrap_gsl_linalg_SV_solve
(dmatrix* U, dmatrix* V, dmatrix* S, dmatrix* b, dmatrix* x)
 = gsl_linalg_SV_solve;

svd_solve (u::matrix,s::matrix,v::matrix) b::matrix
			= throw (bad_matrix_value u)
			    if ~dmatrixp u;
			= throw (bad_matrix_value s)
			    if ~dmatrixp s ||
			      dim s!0 ~= dim u!1 || dim s!1 ~= dim u!1;
			= throw (bad_matrix_value v)
			    if ~dmatrixp v ||
			      dim v!0 ~= dim u!1 || dim v!1 ~= dim u!1;
			= throw (bad_matrix_value b)
			    if cmatrixp b || smatrixp b ||
			      ~colvectorp b || dim b!0 ~= dim u!0;
			= x when x = dmatrix (dim u!1,1);
			    _ = gsl_linalg_SV_solve u v s b x;
			  end if dmatrixp b;
			= svd_solve (u,s,v) (dmatrix b) if imatrixp b;

/* Pseudo inverse of a matrix. */

pinv x::matrix		= v*s*u' when
			    u,s,v = svd x;
			    s = map (\x->if x==0 then x else 1/x) (diag s);
			    s = diagmat s;
			  end if nmatrixp x;

/* Right and left matrix division. */

x::matrix / y::matrix	= x*pinv y if nmatrixp x && nmatrixp y;
x::matrix \\ y::matrix	= pinv x*y if nmatrixp x && nmatrixp y;

/* General and elementary functions. */

namespace C;
extern void gsl_sort(double*, size_t, size_t);
extern void gsl_sort_int(int*, size_t, size_t);
namespace;

using namespace C;

namespace gsl;

public
  sort;

/* The GSL manual recommends using a better sort. 
   This sort is unstable.
*/

sort m::matrix
  = v $$ m
    with
      v = gsl_sort_int (pointer m) 1 (#m) if imatrixp m;
      v = gsl_sort (pointer m) 1 (#m) if dmatrixp m;
    end
    if rowvectorp m;

/* Random distributions. */

namespace C;

extern double gsl_ran_gaussian_pdf(double, double);
extern double gsl_ran_ugaussian_pdf(double);
extern double gsl_cdf_ugaussian_P(double);
extern double gsl_cdf_gaussian_P(double, double);
extern double gsl_cdf_ugaussian_Q(double);
extern double gsl_cdf_gaussian_Q(double, double);
extern double gsl_cdf_ugaussian_Pinv(double);
extern double gsl_cdf_gaussian_Pinv(double, double);
extern double gsl_cdf_ugaussian_Qinv(double);
extern double gsl_cdf_gaussian_Qinv(double, double);

extern double gsl_ran_gaussian_tail_pdf(double, double, double);
extern double gsl_ran_ugaussian_tail_pdf(double, double);

extern double gsl_ran_bivariate_gaussian_pdf
  (double, double, double, double, double);

extern double gsl_ran_exponential_pdf(double, double);
extern double gsl_cdf_exponential_P(double, double);
extern double gsl_cdf_exponential_Q(double, double);
extern double gsl_cdf_exponential_Pinv(double, double);
extern double gsl_cdf_exponential_Qinv(double, double);

extern double gsl_ran_laplace_pdf(double, double);
extern double gsl_cdf_laplace_P(double, double);
extern double gsl_cdf_laplace_Q(double, double);
extern double gsl_cdf_laplace_Pinv(double, double);
extern double gsl_cdf_laplace_Qinv(double, double);

extern double gsl_ran_exppow_pdf(double, double, double);
extern double gsl_cdf_exppow_P(double, double, double);
extern double gsl_cdf_exppow_Q(double, double, double);

extern double gsl_ran_cauchy_pdf(double, double);
extern double gsl_cdf_cauchy_P(double, double);
extern double gsl_cdf_cauchy_Q(double, double);
extern double gsl_cdf_cauchy_Pinv(double, double);
extern double gsl_cdf_cauchy_Qinv(double, double);

extern double gsl_ran_rayleigh_pdf(double, double);
extern double gsl_cdf_rayleigh_P(double, double);
extern double gsl_cdf_rayleigh_Q(double, double);
extern double gsl_cdf_rayleigh_Pinv(double, double);
extern double gsl_cdf_rayleigh_Qinv(double, double);

extern double gsl_ran_rayleigh_tail_pdf(double, double, double);

extern double gsl_ran_landau_pdf(double);

extern double gsl_ran_gamma_pdf(double, double, double);
extern double gsl_cdf_gamma_P(double, double, double);
extern double gsl_cdf_gamma_Q(double, double, double);
extern double gsl_cdf_gamma_Pinv(double, double, double);
extern double gsl_cdf_gamma_Qinv(double, double, double);

extern double gsl_ran_flat_pdf(double, double, double);
extern double gsl_cdf_flat_P(double, double, double);
extern double gsl_cdf_flat_Q(double, double, double);
extern double gsl_cdf_flat_Pinv(double, double, double);
extern double gsl_cdf_flat_Qinv(double, double, double);

extern double gsl_ran_lognormal_pdf(double, double, double);
extern double gsl_cdf_lognormal_P(double, double, double);
extern double gsl_cdf_lognormal_Q(double, double, double);
extern double gsl_cdf_lognormal_Pinv(double, double, double);
extern double gsl_cdf_lognormal_Qinv(double, double, double);

extern double gsl_ran_chisq_pdf(double, double);
extern double gsl_cdf_chisq_P(double, double);
extern double gsl_cdf_chisq_Q(double, double);
extern double gsl_cdf_chisq_Pinv(double, double);
extern double gsl_cdf_chisq_Qinv(double, double);

extern double gsl_ran_fdist_pdf(double, double, double);
extern double gsl_cdf_fdist_P(double, double, double);
extern double gsl_cdf_fdist_Q(double, double, double);
extern double gsl_cdf_fdist_Pinv(double, double, double);
extern double gsl_cdf_fdist_Qinv(double, double, double);

extern double gsl_ran_tdist_pdf(double, double);
extern double gsl_cdf_tdist_P(double, double);
extern double gsl_cdf_tdist_Q(double, double);
extern double gsl_cdf_tdist_Pinv(double, double);
extern double gsl_cdf_tdist_Qinv(double, double);

extern double gsl_ran_beta_pdf(double, double, double);
extern double gsl_cdf_beta_P(double, double, double);
extern double gsl_cdf_beta_Q(double, double, double);
extern double gsl_cdf_beta_Pinv(double, double, double);
extern double gsl_cdf_beta_Qinv(double, double, double);

extern double gsl_ran_logistic_pdf(double, double);
extern double gsl_cdf_logistic_P(double, double);
extern double gsl_cdf_logistic_Q(double, double);
extern double gsl_cdf_logistic_Pinv(double, double);
extern double gsl_cdf_logistic_Qinv(double, double);

extern double gsl_ran_pareto_pdf(double, double, double);
extern double gsl_cdf_pareto_P(double, double, double);
extern double gsl_cdf_pareto_Q(double, double, double);
extern double gsl_cdf_pareto_Pinv(double, double, double);
extern double gsl_cdf_pareto_Qinv(double, double, double);

extern double gsl_ran_weibull_pdf(double, double, double);
extern double gsl_cdf_weibull_P(double, double, double);
extern double gsl_cdf_weibull_Q(double, double, double);
extern double gsl_cdf_weibull_Pinv(double, double, double);
extern double gsl_cdf_weibull_Qinv(double, double, double);

extern double gsl_ran_gumbel1_pdf(double, double, double);
extern double gsl_cdf_gumbel1_P(double, double, double);
extern double gsl_cdf_gumbel1_Q(double, double, double);
extern double gsl_cdf_gumbel1_Pinv(double, double, double);
extern double gsl_cdf_gumbel1_Qinv(double, double, double);

extern double gsl_ran_gumbel2_pdf(double, double, double);
extern double gsl_cdf_gumbel2_P(double, double, double);
extern double gsl_cdf_gumbel2_Q(double, double, double);
extern double gsl_cdf_gumbel2_Pinv(double, double, double);
extern double gsl_cdf_gumbel2_Qinv(double, double, double);

extern double gsl_ran_dirichlet_pdf(size_t, double*, double*);
extern double gsl_ran_dirichlet_lnpdf(size_t, double*, double*);

extern gsl_ran_discrete_t *gsl_ran_discrete_preproc(size_t, double*);
extern double gsl_ran_discrete_pdf(size_t, gsl_ran_discrete_t*);
extern void gsl_ran_discrete_free(gsl_ran_discrete_t *);

extern double gsl_ran_poisson_pdf(int, double);
extern double gsl_cdf_poisson_P(int, double);
extern double gsl_cdf_poisson_Q(int, double);

extern double gsl_ran_bernoulli_pdf(int, double);

extern double gsl_ran_binomial_pdf(int, double, int);
extern double gsl_cdf_binomial_P(int, double, int);
extern double gsl_cdf_binomial_Q(int, double, int);

extern double gsl_ran_multinomial_pdf(size_t, double*, int*);
extern double gsl_ran_multinomial_lnpdf(size_t, double*, int*);

extern double gsl_ran_negative_binomial_pdf(int, double, double);
extern double gsl_cdf_negative_binomial_P(int, double, double);
extern double gsl_cdf_negative_binomial_Q(int, double, double);

extern double gsl_ran_pascal_pdf(int, double, int);
extern double gsl_cdf_pascal_P(int, double, int);
extern double gsl_cdf_pascal_Q(int, double, int);

extern double gsl_ran_geometric_pdf(int, double);
extern double gsl_cdf_geometric_P(int, double);
extern double gsl_cdf_geometric_Q(int, double);

extern double gsl_ran_hypergeometric_pdf(int, int, int, int);
extern double gsl_cdf_hypergeometric_P(int, int, int, int);
extern double gsl_cdf_hypergeometric_Q(int, int, int, int);

extern double gsl_ran_logarithmic_pdf(int, double);
namespace;

namespace gsl;

/* P.d.f. macro. */

private
  apply2_ran;

def apply2_ran  f  m1  m2  =
  if rowvectorp m1 && rowvectorp m2 && #m1 == #m2 then
    (v
     when
       x1, x2 = dmatrix m1, dmatrix m2;
       v = f (#m1) (pointer x1) (pointer x2);
     end)
  else
    f m1 m2;

public
  ran_ugaussian_pdf
  ran_gaussian_pdf
  ran_gaussian_tail_pdf
  ran_ugaussian_tail_pdf
  ran_bivariate_gaussian_pdf
  ran_exponential_pdf
  ran_laplace_pdf
  ran_exppow_pdf
  ran_cauchy_pdf
  ran_rayleigh_pdf
  ran_rayleigh_tail_pdf
  ran_landau_pdf
  ran_gamma_pdf
  ran_flat_pdf
  ran_lognormal_pdf
  ran_chisq_pdf
  ran_fdist_pdf
  ran_tdist_pdf
  ran_beta_pdf
  ran_logistic_pdf
  ran_pareto_pdf
  ran_weibull_pdf
  ran_gumbel1_pdf
  ran_gumbel2_pdf
  ran_dirichlet_pdf
  ran_dirichlet_lnpdf
  ran_discrete_preproc
  ran_discrete_pdf
  ran_discrete_free
  ran_poisson_pdf
  ran_bernoulli_pdf
  ran_binomial_pdf
  ran_multinomial_pdf
  ran_multinomial_lnpdf
  ran_negative_binomial_pdf
  ran_pascal_pdf
  ran_geometric_pdf
  ran_hypergeometric_pdf
  ran_logarithmic_pdf;

  cdf_ugaussian_P
  cdf_gaussian_P
  cdf_ugaussian_Q
  cdf_gaussian_Q
  cdf_ugaussian_Pinv
  cdf_gaussian_Pinv
  cdf_ugaussian_Qinv
  cdf_gaussian_Qinv
  cdf_exponential_P
  cdf_exponential_Q
  cdf_exponential_Pinv
  cdf_exponential_Qinv
  cdf_laplace_P
  cdf_laplace_Q
  cdf_laplace_Pinv
  cdf_laplace_Qinv
  cdf_exppow_P
  cdf_exppow_Q
  cdf_cauchy_P
  cdf_cauchy_Q
  cdf_cauchy_Pinv
  cdf_cauchy_Qinv
  cdf_rayleigh_P
  cdf_rayleigh_Q
  cdf_rayleigh_Pinv
  cdf_rayleigh_Qinv
  cdf_gamma_P
  cdf_gamma_Q
  cdf_gamma_Pinv
  cdf_gamma_Qinv
  cdf_flat_P
  cdf_flat_Q
  cdf_flat_Pinv
  cdf_flat_Qinv
  cdf_lognormal_P
  cdf_lognormal_Q
  cdf_lognormal_Pinv
  cdf_lognormal_Qinv
  cdf_chisq_P
  cdf_chisq_Q
  cdf_chisq_Pinv
  cdf_chisq_Qinv
  cdf_fdist_P
  cdf_fdist_Q
  cdf_fdist_Pinv
  cdf_fdist_Qinv
  cdf_tdist_P
  cdf_tdist_Q
  cdf_tdist_Pinv
  cdf_tdist_Qinv
  cdf_beta_P
  cdf_beta_Q
  cdf_beta_Pinv
  cdf_beta_Qinv
  cdf_logistic_P
  cdf_logistic_Q
  cdf_logistic_Pinv
  cdf_logistic_Qinv
  cdf_pareto_P
  cdf_pareto_Q
  cdf_pareto_Pinv
  cdf_pareto_Qinv
  cdf_weibull_P
  cdf_weibull_Q
  cdf_weibull_Pinv
  cdf_weibull_Qinv
  cdf_gumbel1_P
  cdf_gumbel1_Q
  cdf_gumbel1_Pinv
  cdf_gumbel1_Qinv
  cdf_gumbel2_P
  cdf_gumbel2_Q
  cdf_gumbel2_Pinv
  cdf_gumbel2_Qinv
  cdf_poisson_P
  cdf_poisson_Q
  cdf_binomial_P
  cdf_binomial_Q
  cdf_negative_binomial_P
  cdf_negative_binomial_Q
  cdf_pascal_P
  cdf_pascal_Q
  cdf_geometric_P
  cdf_geometric_Q
  cdf_hypergeometric_P
  cdf_hypergeometric_Q;

ran_ugaussian_pdf  x
  = gsl_ran_ugaussian_pdf (double x) if realp x;

ran_gaussian_pdf  x  sigma
  = gsl_ran_gaussian_pdf (double x) (double sigma) if realp x && realp sigma;

ran_gaussian_tail_pdf  x  a  sigma
  = gsl_ran_gaussian_tail_pdf (double x) (double a) (double sigma)
    if realp x && realp a && realp sigma;

ran_ugaussian_tail_pdf  x  a
  = gsl_ran_ugaussian_tail_pdf (double x) (double a) if realp x && realp a;

ran_bivariate_gaussian_pdf  x  y  sigma_x  sigma_y  rho
  = gsl_ran_bivariate_gaussian_pdf
      (double x) (double y) (double sigma_x) (double sigma_y) (double rho)
    if realp x && realp y && realp sigma_x && realp sigma_y && realp rho;

ran_exponential_pdf  x  mu
  = gsl_ran_exponential_pdf (double x) (double mu) if realp x && realp mu;

ran_laplace_pdf  x  a
  = gsl_ran_laplace_pdf (double x) (double a) if realp x && realp a;

ran_exppow_pdf  x  a  b
  = gsl_ran_exppow_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

ran_cauchy_pdf  x  a
  = gsl_ran_cauchy_pdf (double x) (double a) if realp x && realp a;

ran_rayleigh_pdf  x  sigma
  = gsl_ran_rayleigh_pdf (double x) (double sigma) if realp x && realp sigma;

ran_rayleigh_tail_pdf  x  a  sigma
  = gsl_ran_rayleigh_tail_pdf (double x) (double a) (double sigma)
    if realp x && realp a && realp sigma;

ran_landau_pdf  x
  = gsl_ran_landau_pdf x if realp x;

ran_gamma_pdf  x  a  b
  = gsl_ran_gamma_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

ran_flat_pdf  x  a  b
  = gsl_ran_flat_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

ran_lognormal_pdf  x  zeta  sigma
  = gsl_ran_lognormal_pdf (double x) (double zeta) (double sigma)
    if realp x && realp zeta && realp sigma;

ran_chisq_pdf  x  nu
  = gsl_ran_chisq_pdf (double x) (double nu) if realp x && realp nu;

ran_fdist_pdf  x  nu1  nu2
  = gsl_ran_fdist_pdf (double x) (double nu1) (double nu2)
    if realp x && realp nu1 && realp nu2;

ran_tdist_pdf  x  nu
  = gsl_ran_tdist_pdf (double x) (double nu) if realp x && realp nu;

ran_beta_pdf  x  a  b
  = gsl_ran_beta_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

ran_logistic_pdf  x  a
  = gsl_ran_logistic_pdf (double x) (double a) if realp x && realp a;

ran_pareto_pdf  x  a  b
  = gsl_ran_pareto_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

ran_weibull_pdf  x  a  b
  = gsl_ran_weibull_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

ran_gumbel1_pdf  x  a  b
  = gsl_ran_gumbel1_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

ran_gumbel2_pdf  x  a  b
  = gsl_ran_gumbel2_pdf (double x) (double a) (double b)
    if realp x && realp a && realp b;

ran_dirichlet_pdf  alpha::matrix  theta::matrix
  = apply2_ran gsl_ran_dirichlet_pdf alpha theta;

ran_dirichlet_lnpdf  alpha::matrix  theta::matrix
  = apply2_ran gsl_ran_dirichlet_lnpdf alpha theta;

ran_discrete_preproc  p::matrix
  = v
    when
      x = dmatrix p;
      v = gsl_ran_discrete_preproc (#p) (pointer x);
    end
    if rowvectorp p;

ran_discrete_pdf  k::int  p::pointer
  = gsl_ran_discrete_pdf k p if k >= 0;

ran_discrete_free  p::pointer
  = gsl_ran_discrete_free p;

ran_poisson_pdf  k::int  mu
  = gsl_ran_poisson_pdf k (double mu) if realp mu && k >= 0;

ran_bernoulli_pdf  k::int  p
  = gsl_ran_bernoulli_pdf k (double p) if realp p && k >= 0;

ran_binomial_pdf  k::int  p  n::int
  = gsl_ran_binomial_pdf k (double p) n if realp p && k >= 0 && n > 0;

ran_negative_binomial_pdf  k::int  p  n
  = gsl_ran_negative_binomial_pdf k (double p) (double n)
    if realp p && realp n && k >= 0;

ran_multinomial_pdf  p::matrix  n::matrix
  = apply2_ran gsl_ran_multinomial_pdf p n;

ran_multinomial_lnpdf  p::matrix  n::matrix
  = apply2_ran gsl_ran_multinomial_lnpdf p n;

ran_pascal_pdf  k::int  p  n::int
  = gsl_ran_pascal_pdf k (double p) n if realp p && k >= 0;

ran_geometric_pdf  k::int  p
  = gsl_ran_geometric_pdf k (double p) if realp p && k >= 1;

ran_hypergeometric_pdf  k::int  n1::int  n2::int  t::int
  = gsl_ran_hypergeometric_pdf k n1 n2 t
    if k >= 0 && n1 >= 0 && n2 >= 0 && t >= 0;

ran_logarithmic_pdf  k::int  p
  = gsl_ran_logarithmic_pdf k (double p) if k >= 1 && realp p;

cdf_ugaussian_P  x
  = gsl_cdf_ugaussian_P (double x) if realp x;

cdf_gaussian_P  x  sigma
  = gsl_cdf_gaussian_P (double x) (double sigma) if realp x && realp sigma;

cdf_ugaussian_Q  x
  = gsl_cdf_ugaussian_Q (double x) if realp x;

cdf_gaussian_Q  x  sigma
  = gsl_cdf_gaussian_Q (double x) (double sigma) if realp x && realp sigma;

cdf_ugaussian_Pinv  p
  = gsl_cdf_ugaussian_Pinv (double p) if realp p;

cdf_gaussian_Pinv  p  sigma
  = gsl_cdf_gaussian_Pinv (double p) (double sigma) if realp p && realp sigma;

cdf_ugaussian_Qinv  q
  = gsl_cdf_ugaussian_Qinv (double q) if realp q;

cdf_gaussian_Qinv  q  sigma
  = gsl_cdf_gaussian_Qinv (double q) (double sigma) if realp q && realp sigma;

cdf_exponential_P  x  mu
  = gsl_cdf_exponential_P (double x) (double mu) if realp x && realp mu;

cdf_exponential_Q  x  mu
  = gsl_cdf_exponential_Q (double x) (double mu) if realp x && realp mu;

cdf_exponential_Pinv  p  mu
  = gsl_cdf_exponential_Pinv (double p) (double mu) if realp p && realp mu;

cdf_exponential_Qinv  q  mu
  = gsl_cdf_exponential_Qinv (double q) (double mu) if realp q && realp mu;

cdf_laplace_P  x  a
  = gsl_cdf_laplace_P (double x) (double a) if realp x && realp a;

cdf_laplace_Q  x  a
  = gsl_cdf_laplace_Q (double x) (double a) if realp x && realp a;

cdf_laplace_Pinv  p  a
  = gsl_cdf_laplace_Pinv (double p) (double a) if realp p && realp a;

cdf_laplace_Qinv  q  a
  = gsl_cdf_laplace_Qinv (double q) (double a)
    if realp q && realp a;

cdf_exppow_P  x  a  b
  = gsl_cdf_exppow_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

cdf_exppow_Q  x  a  b
  = gsl_cdf_exppow_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

cdf_cauchy_P  x  a
  = gsl_cdf_cauchy_P (double x) (double a) if realp x && realp a;

cdf_cauchy_Q  x  a
  = gsl_cdf_cauchy_Q (double x) (double a) if realp x && realp a;

cdf_cauchy_Pinv  p  a
  = gsl_cdf_cauchy_Pinv (double p) (double a) if realp p && realp a;

cdf_cauchy_Qinv  q  a
  = gsl_cdf_cauchy_Qinv (double q) (double a) if realp q && realp a;

cdf_rayleigh_P  x  sigma
  = gsl_cdf_rayleigh_P (double x) (double sigma) if realp x && realp sigma;

cdf_rayleigh_Q  x  sigma
  = gsl_cdf_rayleigh_Q (double x) (double sigma) if realp x && realp sigma;

cdf_rayleigh_Pinv  p  sigma
  = gsl_cdf_rayleigh_Pinv (double p) (double sigma) if realp p && realp sigma;

cdf_rayleigh_Qinv  q  sigma
  = gsl_cdf_rayleigh_Qinv (double q) (double sigma) if realp q && realp sigma;

cdf_gamma_P  x  a  b
  = gsl_cdf_gamma_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

cdf_gamma_Q  x  a  b
  = gsl_cdf_gamma_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

cdf_gamma_Pinv  p  a  b
  = gsl_cdf_gamma_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

cdf_gamma_Qinv  q  a  b
  = gsl_cdf_gamma_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

cdf_flat_P  x  a  b
  = gsl_cdf_flat_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

cdf_flat_Q  x  a  b
  = gsl_cdf_flat_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

cdf_flat_Pinv  p  a  b
  = gsl_cdf_flat_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

cdf_flat_Qinv  q  a  b
  = gsl_cdf_flat_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

cdf_lognormal_P  x  zeta  sigma
  = gsl_cdf_lognormal_P (double x) (double zeta) (double sigma)
    if realp x && realp zeta && realp sigma;

cdf_lognormal_Q  x  zeta  sigma
  = gsl_cdf_lognormal_Q (double x) (double zeta) (double sigma)
    if realp x && realp zeta && realp sigma;

cdf_lognormal_Pinv  p  zeta  sigma
  = gsl_cdf_lognormal_Pinv (double p) (double zeta) (double sigma)
    if realp p && realp zeta && realp sigma;

cdf_lognormal_Qinv  q  zeta  sigma
  = gsl_cdf_lognormal_Qinv (double q) (double zeta) (double sigma)
    if realp q && realp zeta && realp sigma;

cdf_chisq_P  x  nu
  = gsl_cdf_chisq_P (double x) (double nu) if realp x && realp nu;

cdf_chisq_Q  x  nu
  = gsl_cdf_chisq_Q (double x) (double nu) if realp x && realp nu;

cdf_chisq_Pinv  p  nu
  = gsl_cdf_chisq_P (double p) (double nu) if realp p && realp nu;

cdf_chisq_Qinv  q  nu
  = gsl_cdf_chisq_Qinv (double q) (double nu) if realp q && realp nu;

cdf_fdist_P  x  nu1  nu2
  = gsl_cdf_fdist_P (double x) (double nu1) (double nu2)
    if realp x && realp nu1 && realp nu2;

cdf_fdist_Q  x  nu1  nu2
  = gsl_cdf_fdist_Q (double x) (double nu1) (double nu2)
    if realp x && realp nu1 && realp nu2;

cdf_fdist_Pinv  p  nu1  nu2
  = gsl_cdf_fdist_Pinv (double p) (double nu1) (double nu2)
    if realp p && realp nu1 && realp nu2;

cdf_fdist_Qinv  q  nu1  nu2
  = gsl_cdf_fdist_Qinv (double q) (double nu1) (double nu2)
    if realp q && realp nu1 && realp nu2;

cdf_tdist_P  x  nu
  = gsl_cdf_tdist_P (double x) (double nu) if realp x && realp nu;

cdf_tdist_Q  x  nu
  = gsl_cdf_tdist_Q (double x) (double nu) if realp x && realp nu;

cdf_tdist_Pinv  p  nu
  = gsl_cdf_tdist_Pinv (double p) (double nu) if realp p && realp nu;

cdf_tdist_Qinv  q  nu
  = gsl_cdf_tdist_Qinv (double q) (double nu) if realp q && realp nu;

cdf_beta_P  x  a  b
  = gsl_cdf_beta_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

cdf_beta_Q  x  a  b
  = gsl_cdf_beta_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

cdf_beta_Pinv  p  a  b
  = gsl_cdf_beta_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

cdf_beta_Qinv  q  a  b
  = gsl_cdf_beta_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

cdf_logistic_P  x  a
  = gsl_cdf_logistic_P (double x) (double a) if realp x && realp a;

cdf_logistic_Q  x  a
  = gsl_cdf_logistic_Q (double x) (double a) if realp x && realp a;

cdf_logistic_Pinv  p  a
  = gsl_cdf_logistic_Pinv (double p) (double a) if realp p && realp a;

cdf_logistic_Qinv  q  a
  = gsl_cdf_logistic_Qinv (double q) (double a) if realp q && realp a;

cdf_pareto_P  x  a  b
  = gsl_cdf_pareto_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

cdf_pareto_Q  x  a  b
  = gsl_cdf_pareto_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

cdf_pareto_Pinv  p  a  b
  = gsl_cdf_pareto_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

cdf_pareto_Qinv  q  a  b
  = gsl_cdf_pareto_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

cdf_weibull_P  x  a  b
  = gsl_cdf_weibull_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

cdf_weibull_Q  x  a  b
  = gsl_cdf_weibull_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

cdf_weibull_Pinv  p  a  b
  = gsl_cdf_weibull_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

cdf_weibull_Qinv  q  a  b
  = gsl_cdf_weibull_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

cdf_gumbel1_P  x  a  b
  = gsl_cdf_gumbel1_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

cdf_gumbel1_Q  x  a  b
  = gsl_cdf_gumbel1_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

cdf_gumbel1_Pinv  p  a  b
  = gsl_cdf_gumbel1_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

cdf_gumbel1_Qinv  q  a  b
  = gsl_cdf_gumbel1_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

cdf_gumbel2_P  x  a  b
  = gsl_cdf_gumbel2_P (double x) (double a) (double b)
    if realp x && realp a && realp b;

cdf_gumbel2_Q  x  a  b
  = gsl_cdf_gumbel2_Q (double x) (double a) (double b)
    if realp x && realp a && realp b;

cdf_gumbel2_Pinv  p  a  b
  = gsl_cdf_gumbel2_Pinv (double p) (double a) (double b)
    if realp p && realp a && realp b;

cdf_gumbel2_Qinv  q  a  b
  = gsl_cdf_gumbel2_Qinv (double q) (double a) (double b)
    if realp q && realp a && realp b;

cdf_poisson_P  k::int  mu
  = gsl_cdf_poisson_P k (double mu) if realp mu && k >= 0;

cdf_poisson_Q  k::int  mu
  = gsl_cdf_poisson_Q k (double mu) if realp mu && k >= 0;

cdf_binomial_P  k::int  p  n::int
  = gsl_cdf_binomial_P k (double p) n if realp p && k >= 0 && n > 0;

cdf_binomial_Q  k::int  q  n::int
  = gsl_cdf_binomial_Q k (double q) n if realp q && k >= 0 && n > 0;

cdf_negative_binomial_P  k::int  p  n
  = gsl_cdf_negative_binomial_P k (double p) (double n)
    if realp p && realp n && k >= 0;

cdf_negative_binomial_Q  k::int  p  n
  = gsl_cdf_negative_binomial_Q k (double p) (double n)
    if realp p && realp n && k >= 0;

cdf_pascal_P  k::int  p  n::int
  = gsl_cdf_pascal_P k (double p) n if realp p && k >= 0;

cdf_pascal_Q  k::int  p  n::int
  = gsl_cdf_pascal_Q k (double p) n if realp p && k >= 0;

cdf_geometric_P  k::int  p
  = gsl_cdf_geometric_P k (double p) if realp p && k >= 1;

cdf_geometric_Q  k::int  p
  = gsl_cdf_geometric_Q k (double p) if realp p && k >= 1;

cdf_hypergeometric_P  k::int  n1::int  n2::int  t::int
  = gsl_cdf_hypergeometric_P k n1 n2 t
    if k >= 0 && n1 >= 0 && n2 >= 0 && t >= 0;

cdf_hypergeometric_Q  k::int  n1::int  n2::int  t::int
  = gsl_cdf_hypergeometric_Q k n1 n2 t
    if k >= 0 && n1 >= 0 && n2 >= 0 && t >= 0;

/* Statsistics. */

namespace C;

extern double gsl_stats_mean(double*, size_t, size_t);

extern double gsl_stats_variance(double*, size_t, size_t);
extern double gsl_stats_variance_m(double*, size_t, size_t, double);

extern double gsl_stats_sd(double*, size_t, size_t);
extern double gsl_stats_sd_m(double*, size_t, size_t, double);

extern double gsl_stats_tss(double*, size_t, size_t);
extern double gsl_stats_tss_m(double*, size_t, size_t, double);

extern double gsl_stats_variance_with_fixed_mean
  (double*, size_t, size_t, double);
extern double gsl_stats_sd_with_fixed_mean(double*, size_t, size_t, double);

extern double gsl_stats_absdev(double*, size_t, size_t);
extern double gsl_stats_absdev_m(double*, size_t, size_t, double);

extern double gsl_stats_skew(double*, size_t, size_t);
extern double gsl_stats_skew_m_sd(double*, size_t, size_t, double, double);

extern double gsl_stats_kurtosis(double*, size_t, size_t);
extern double gsl_stats_kurtosis_m_sd(double*, size_t, size_t, double, double);

extern double gsl_stats_lag1_autocorrelation(double*, size_t, size_t);
extern double gsl_stats_lag1_autocorrelation_m(double*, size_t, size_t, double);

extern double gsl_stats_covariance(double*, size_t, double*, size_t, size_t);
extern double gsl_stats_covariance_m
  (double*, size_t, double*, size_t, size_t, double, double);

extern double gsl_stats_wmean(double*, size_t, double*, size_t, size_t);
extern double gsl_stats_wvariance(double*, size_t, double*, size_t, size_t);
extern double gsl_stats_wvariance_m
  (double*, size_t, double*, size_t, size_t, double);
extern double gsl_stats_wsd(double*, size_t, double*, size_t, size_t);
extern double gsl_stats_wsd_m(double*, size_t, double*, size_t, size_t, double);
extern double gsl_stats_wvariance_with_fixed_mean
  (double*, size_t, double*, size_t, size_t, double);
extern double gsl_stats_wsd_with_fixed_mean
  (double*, size_t, double*, size_t, size_t, double);
extern double gsl_stats_wabsdev(double*, size_t, double*, size_t, size_t);
extern double gsl_stats_wabsdev_m
  (double*, size_t, double*, size_t, size_t, double);
extern double gsl_stats_wskew(double*, size_t, double*, size_t, size_t);
extern double gsl_stats_wskew_m_sd
  (double*, size_t, double*, size_t, size_t, double, double);
extern double gsl_stats_wkurtosis(double*, size_t, double*, size_t, size_t);
extern double gsl_stats_wkurtosis_m_sd
  (double*, size_t, double*, size_t, size_t, double, double);

extern double gsl_stats_correlation(double*, size_t, double*, size_t, size_t);

extern double gsl_stats_median_from_sorted_data(double*, size_t, size_t);
extern double gsl_stats_quantile_from_sorted_data
  (double*, size_t, size_t, double);

extern int gsl_stats_int_max(int*, size_t, size_t);
extern double gsl_stats_max(double*, size_t, size_t);

extern int gsl_stats_int_min(int*, size_t, size_t);
extern double gsl_stats_min(double*, size_t, size_t);

extern expr* wrap_gsl_stats_int_minmax(int*, size_t, size_t);
extern expr* wrap_gsl_stats_minmax(double*, size_t, size_t);

extern int gsl_stats_int_max_index(int*, size_t, size_t);
extern int gsl_stats_max_index(double*, size_t, size_t);

extern int gsl_stats_int_min_index(int*, size_t, size_t);
extern int gsl_stats_min_index(double*, size_t, size_t);

extern expr* wrap_gsl_stats_int_minmax_index(int*, size_t, size_t);
extern expr* wrap_gsl_stats_minmax_index(double*, size_t, size_t);
namespace;

namespace gsl;

private
  apply1
  dapply1
  dapply1_d
  dapply1_dd
  dapply2
  dapply2_d
  dapply2_dd;

/* Statistics macros. */

def apply1  f  m  =
  if rowvectorp m then
    (v when v = f (pointer m) 1 (#m) end)
  else
    f m;

def dapply1  f  m  =
  if rowvectorp m then
    (v when 
         x = dmatrix m;
         v = f (pointer x) 1 (#m)
       end)
  else
    f m;
  
def dapply1_d  f  m  d  =
  if rowvectorp m then
    (v when
         x = dmatrix m;
         v = f (pointer x) 1 (#m) (double d)
       end)
  else
    f m d;

def dapply1_dd  f  m  d1  d2  =
  if rowvectorp m then
    (v when
         x = dmatrix m;
         v = f (pointer x) 1 (#m) (double d1) (double d2)
       end)
  else
    f m d1 d2;

def dapply2  f  m1  m2  =
  if rowvectorp m1 && rowvectorp m2 && #m1 == #m2 then
    (v when
         x1, x2 = dmatrix m1, dmatrix m2;
         v = f (pointer x1) 1 (pointer x2) 1 (#m1);
       end)
  else
    f m1 m2;

def dapply2_d  f  m1  m2  d  =
  if rowvectorp m1 && rowvectorp m2 && #m1 == #m2 then
    (v when
         x1, x2 = dmatrix m1, dmatrix m2;
         v = f (pointer x1) 1 (pointer x2) 1 (#m1) (double d);
       end)
  else
    f m1 m2 d;

def dapply2_dd  f  m1  m2  d1  d2  =
  if rowvectorp m1 && rowvectorp m2 && #m1 == #m2 then
    (v when
         x1, x2 = dmatrix m1, dmatrix m2;
         v = f (pointer x1) 1 (pointer x2) 1 (#m1) (double d1) (double d2);
       end)
  else
    f m1 m2 d1 d2;

public
  stats_mean
  stats_variance
  stats_variance_m
  stats_sd
  stats_sd_m
  stats_tss
  stats_tss_m
  stats_variance_with_fixed_mean
  stats_sd_with_fixed_mean
  stats_absdev
  stats_absdev_m
  stats_skew
  stats_skew_m_sd
  stats_kurtosis
  stats_kurtosis_m_sd
  stats_lag1_autocorrelation
  stats_lag1_autocorrelation_m
  stats_covariance
  stats_covariance_m
  stats_wmean
  stats_wvariance
  stats_wvariance_m
  stats_wsd
  stats_wsd_m
  stats_wvariance_with_fixed_mean
  stats_wsd_with_fixed_mean
  stats_wabsdev
  stats_wabsdev_m
  stats_wskew
  stats_wskew_m_sd
  stats_wkurtosis
  stats_wkurtosis_m_sd
  stats_max
  stats_min
  stats_minmax
  stats_max_index
  stats_min_index
  stats_minmax_index
  stats_median_from_sorted_data
  stats_quantile_from_sorted_data
  stats_correlation;

stats_mean  m::matrix
  = dapply1 gsl_stats_mean m;

stats_variance  m::matrix
  = dapply1 gsl_stats_variance m;

stats_variance_m  m::matrix  mean
  = dapply1_d gsl_stats_variance_m m mean;

stats_sd  m::matrix
  = dapply1 gsl_stats_sd m;

stats_sd_m  m::matrix  mean
  = dapply1_d gsl_stats_sd_m m mean;

stats_tss  m::matrix
  = dapply1 gsl_stats_tss m;

stats_tss_m  m::matrix  mean
  = dapply1_d gsl_stats_tss_m m mean;

stats_variance_with_fixed_mean  m::matrix  mean
  = dapply1_d gsl_stats_variance_with_fixed_mean m mean;

stats_sd_with_fixed_mean  m::matrix  mean
  = dapply1_d gsl_stats_sd_with_fixed_mean m mean;

stats_absdev  m::matrix
  = dapply1 gsl_stats_absdev m;

stats_absdev_m  m::matrix  mean
  = dapply1_d gsl_stats_absdev_m m mean;

stats_skew  m::matrix
  = dapply1 gsl_stats_skew m;

stats_skew_m_sd  m::matrix  mean  sd
  = dapply1_dd gsl_stats_skew_m_sd m mean sd if sd >= 0.0;

stats_kurtosis  m::matrix
  = dapply1 gsl_stats_kurtosis m;

stats_kurtosis_m_sd  m::matrix  mean  sd
  = dapply1_dd gsl_stats_kurtosis_m_sd m mean sd if sd >= 0.0;

stats_lag1_autocorrelation  m::matrix
  = dapply1 gsl_stats_lag1_autocorrelation m;

stats_lag1_autocorrelation_m  m::matrix  mean
  = dapply1_d gsl_stats_lag1_autocorrelation_m m mean;

stats_covariance  m1::matrix  m2::matrix
  = dapply2 gsl_stats_covariance m1 m2;

stats_covariance_m  m1::matrix  m2::matrix  mean1  mean2
  = dapply2_dd gsl_stats_covariance_m m1 m2 mean1 mean2;

stats_wmean  w::matrix  m::matrix
  = dapply2 gsl_stats_wmean w m;

stats_wvariance  w::matrix  m::matrix
  = dapply2 gsl_stats_wvariance w m;

stats_wvariance_m  w::matrix  m::matrix  mean
  = dapply2_d gsl_stats_wvariance_m w m mean;

stats_wsd  weights::matrix  m::matrix
  = dapply2 gsl_stats_wsd weights m;

stats_wsd_m  weights::matrix  m::matrix  weighted_mean
  = dapply2_d gsl_stats_wsd_m weights m weighted_mean;

stats_wvariance_with_fixed_mean  weights::matrix  m::matrix  mean
  = dapply2_d gsl_stats_wvariance_with_fixed_mean weights m mean;

stats_wsd_with_fixed_mean  weights::matrix  m::matrix  mean
  = dapply2_d gsl_stats_wsd_with_fixed_mean weights m mean;

stats_wabsdev  weights::matrix  m::matrix
  = dapply2 gsl_stats_wabsdev weights m;

stats_wskew  weights::matrix  m::matrix
  = dapply2 gsl_stats_wskew weights m;

stats_wskew_m_sd  weights::matrix  m::matrix  mean  sd
  = dapply2_dd gsl_stats_wskew_m_sd weights m mean sd if sd >= 0.0;

stats_wkurtosis  weights::matrix  m::matrix
  = dapply2 gsl_stats_wkurtosis weights m;

stats_wkurtosis_m_sd  weights::matrix  m::matrix mean sd
  = dapply2_dd gsl_stats_wkurtosis_m_sd weights m mean sd if sd >= 0.0;

stats_max  m::matrix
  = apply1 gsl_stats_int_max m if imatrixp m;
  = apply1 gsl_stats_max m if dmatrixp m;

stats_min  m::matrix
  = apply1 gsl_stats_int_min m if imatrixp m;
  = apply1 gsl_stats_min m if dmatrixp m;

stats_minmax  m::matrix
  = apply1 wrap_gsl_stats_int_minmax m if imatrixp m;
  = apply1 wrap_gsl_stats_minmax m if dmatrixp m;

stats_min_index  m::matrix
  = apply1 gsl_stats_int_min_index m if imatrixp m;
  = apply1 gsl_stats_min_index m if dmatrixp m;
  
stats_max_index  m::matrix
  = apply1 gsl_stats_int_max_index m if imatrixp m;
  = apply1 gsl_stats_max_index m if dmatrixp m;

stats_minmax_index  m::matrix
  = apply1 wrap_gsl_stats_int_minmax_index m if imatrixp m;
  = apply1 wrap_gsl_stats_minmax_index m if dmatrixp m;

stats_correlation  m1::matrix  m2::matrix
  = dapply2 gsl_stats_correlation m1 m2;

stats_median_from_sorted_data  m::matrix
  = dapply1 gsl_stats_median_from_sorted_data m;

stats_quantile_from_sorted_data  m::matrix  f::double
  = dapply1_d gsl_stats_quantile_from_sorted_data m f
    if f >= 0.0 && f <= 1.0;
