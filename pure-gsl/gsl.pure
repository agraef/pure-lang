
/* gsl.pure: GSL wrapper for the Pure programming language. */

/* Copyright (c) 2008 by Albert Graef <Dr.Graef@t-online.de>.
   Copyright (c) 2008 by Robert E. Rucker <erucker@bmc.edu>.

   This file is part of the Pure programming language and system.

   Pure is free software: you can redistribute it and/or modify it under the
   terms of the GNU General Public License as published by the Free Software
   Foundation, either version 3 of the License, or (at your option) any later
   version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
   details.

   You should have received a copy of the GNU General Public License along
   with this program.  If not, see <http://www.gnu.org/licenses/>. */

using "lib:gsl";

/* Complex functions. */

extern expr* wrap_complex_sqrt(expr*) = gsl_complex_sqrt;

/* Matrix-matrix operations. */

extern int gsl_matrix_add(dmatrix*, dmatrix*);
extern int gsl_matrix_complex_add(cmatrix*, cmatrix*);
extern int gsl_matrix_int_add(imatrix*, imatrix*);

x::matrix + y::matrix	= throw (bad_matrix_value y) if dim x!=dim y;
			= x when
			    x = pack x;
			    _ = case matrix_type x of
			      1 = gsl_matrix_add x y;
			      2 = gsl_matrix_complex_add x y;
			      3 = gsl_matrix_int_add x y;
			    end;
			  end if nmatrixp x && matrix_type x == matrix_type y;
// mixed numeric cases
			= cmatrix x + y if nmatrixp x && cmatrixp y;
			= x + cmatrix y if cmatrixp x && nmatrixp y;
			= dmatrix x + y if imatrixp x && dmatrixp y;
			= x + dmatrix y if dmatrixp x && imatrixp y;
// symbolic matrix operations
			= zipwith (+) x y;

/* Matrix multiplication is implemented via the BLAS interface (actually a
   thin wrapper around the BLAS routines, as these seem unnecessarily
   complicated). This API doesn't support integer matrices, so we emulate
   these by converting to double matrices and then back to integer. Also note
   that these routines take an extra third argument for the result matrix. */

extern int gsl_matrix_multiply(dmatrix*, dmatrix*, dmatrix*);
extern int gsl_matrix_complex_multiply(cmatrix*, cmatrix*, cmatrix*);

x::matrix * y::matrix	= throw (bad_matrix_value y) if dim x!1!=dim y!0;
			= z when
			    mat = [dmatrix,cmatrix,dmatrix]!(matrix_type x-1);
			    z = mat (dim x!0,dim y!1);
			    _ = if null z then () else
			    (case matrix_type x of
			       1 = gsl_matrix_multiply x y z;
			       2 = gsl_matrix_complex_multiply x y z;
			       3 = gsl_matrix_multiply
			           (dmatrix x) (dmatrix y) z;
			     end);
			    z = if imatrixp x then imatrix z else z;
			  end if nmatrixp x && matrix_type x == matrix_type y;
// mixed numeric cases
			= cmatrix x * y if nmatrixp x && cmatrixp y;
			= x * cmatrix y if cmatrixp x && nmatrixp y;
			= dmatrix x * y if imatrixp x && dmatrixp y;
			= x * dmatrix y if dmatrixp x && imatrixp y;
// symbolic matrix multiplication
			= redim (dim x!0,dim y!1)
			  {dot u v | u = rows x; v = cols y}
			  with dot x::matrix y::matrix =
			    foldl (+) 0 [x!i*y!i | i=0..#x-1];
			  end;

/* Singular value decompositions. For a given nxm matrix x, these yield a
   singular-value decomposition u,s,v of the matrix such that x==u*s*v', where
   u and v are orthogonal matrices of dimensions nxm and nxn, respectively,
   and s is a nxn diagonal matrix which has the singular values in its
   diagonal, in descending order. Note that GSL implements this only for
   double matrices right now. Also, GSL only handles the case of square or
   overdetermined systems, but we work around that in our wrapper functions by
   just adding a suitable number of zero rows in the underdetermined case.  */

/* This uses the Golub-Reinsch algorithm. */

extern int wrap_gsl_linalg_SV_decomp
(dmatrix* A, dmatrix* V, dmatrix* S, dmatrix* work) = gsl_linalg_SV_decomp;

svd x::matrix		= throw (bad_matrix_value x)
			    if cmatrixp x || smatrixp x;
			= u!!(0..n-1,0..m-1),s,v when
			    n,m = dim x;
			    u,s,v = svd {dmatrix x;dmatrix (m-n,m)};
			  end if dim x!0<dim x!1;
			= u,s,v when n,m = dim x;
			    u = pack (dmatrix x); v = dmatrix (m,m);
			    s = dmatrix (m,m); w = dmatrix m;
			    _ = gsl_linalg_SV_decomp u v s w;
			  end;

/* This uses the modified Golub-Reinsch algorithm, which is faster if n>>m but
   needs O(m^2) extra memory as internal workspace. */

extern int wrap_gsl_linalg_SV_decomp_mod
(dmatrix* A, dmatrix* X, dmatrix* V, dmatrix* S, dmatrix* work)
 = gsl_linalg_SV_decomp_mod;

svd_mod x::matrix	= throw (bad_matrix_value x)
			    if cmatrixp x || smatrixp x;
			= u!!(0..n-1,0..m-1),s,v when
			    n,m = dim x;
			    u,s,v = svd_mod {dmatrix x;dmatrix (m-n,m)};
			  end if dim x!0<dim x!1;
			= u,s,v when n,m = dim x;
			    u = pack (dmatrix x); v = dmatrix (m,m);
			    s = dmatrix (m,m); w = dmatrix m;
			    y = dmatrix (m,m);
			    _ = gsl_linalg_SV_decomp_mod u y v s w;
			  end;

/* This uses one-sided Jacobi orthogonalization which provides better relative
   accuracy but is slower. */

extern int wrap_gsl_linalg_SV_decomp_jacobi
(dmatrix* A, dmatrix* V, dmatrix* S) = gsl_linalg_SV_decomp_jacobi;

svd_jacobi x::matrix	= throw (bad_matrix_value x)
			    if cmatrixp x || smatrixp x;
			= u!!(0..n-1,0..m-1),s,v when
			    n,m = dim x;
			    u,s,v = svd_jacobi {dmatrix x;dmatrix (m-n,m)};
			  end if dim x!0<dim x!1;
			= u,s,v when n,m = dim x;
			    u = pack (dmatrix x); v = dmatrix (m,m);
			    s = dmatrix (m,m);
			    _ = gsl_linalg_SV_decomp_jacobi u v s;
			  end;

/* Solve the system Ax=b, using the SVD of A. Our wrapper svd_solve takes the
   result (u,s,v) of a svd call, and a column vector b of the appropriate
   dimension. The result is another column vector solving the system (possibly
   in the least-squares sense). */

extern int wrap_gsl_linalg_SV_solve
(dmatrix* U, dmatrix* V, dmatrix* S, dmatrix* b, dmatrix* x)
 = gsl_linalg_SV_solve;

svd_solve (u::matrix,s::matrix,v::matrix) b::matrix
			= throw (bad_matrix_value u)
			    if not dmatrixp u;
			= throw (bad_matrix_value s)
			    if not dmatrixp s ||
			      dim s!0 != dim u!1 || dim s!1 != dim u!1;
			= throw (bad_matrix_value v)
			    if not dmatrixp v ||
			      dim v!0 != dim u!1 || dim v!1 != dim u!1;
			= throw (bad_matrix_value b)
			    if cmatrixp b || smatrixp b ||
			      not colvectorp b || dim b!0 != dim u!0;
			= x when x = dmatrix (dim u!1,1);
			    _ = gsl_linalg_SV_solve u v s b x;
			  end if dmatrixp b;
			= svd_solve (u,s,v) (dmatrix b) if imatrixp b;

/* Pseudo inverse of a matrix. */

pinv x::matrix		= v*map pinv s*u' when u,s,v = svd x end
			  with pinv x = if x==0 then x else 1/x end;
