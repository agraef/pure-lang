#! /usr/bin/env pure

#! --nowarn

using system, regex, getopt, dict;

/* Command to invoke the C preprocessor. We use this to extract #defines from
   an input file as well as all its includes, so the -fdirectives-only option
   is required to keep those intact. This is pretty much tied to gcc right
   now, but as dump-ast also uses gcc you'll need it anyway. */
const gcc = "@gcc@";
const cpp = sprintf "%s -E -fdirectives-only" gcc;

// This path is set at build time. For the uninstalled version we assume the
// current directory.
let dumper = "./dump-ast";

// Allow override at runtime. This is used by run-tests.
extern char *getenv(char*);
let dumper = if stringp env then env else dumper
  when env = getenv "DUMP_AST" end;

// This is also set at build time.
let version = "@version@";

let copyright = sprintf
  "pure-gen version %s Copyright (c) 2009-2014 Scott E. Dillard, Albert Graef"
  version;

// Set up PATH so that we pick up the proper C preprocessor.
#! --if *-mingw32
extern int _putenv(void*) = putenv;
#! --else
extern int putenv(void*);
#! --endif

null env ||
  (putenv $ byte_cstring $ sprintf
#! --if *-mingw32
   "PATH=%s;%s"
#! --else
   "PATH=%s:%s"
#! --endif
   (env,getenv "PATH"))
when env = getenv "PURECPP" end;

/* Default template for C code generation.

   %h = header name, %r = return type, %w = wrapper function name, %p = formal
   params, %n = real function name, %a = arguments, %% escapes a single %.

   A %% on a line by itself separates the "frontmatter" (code to be inserted
   at the beginning of the C file, right after the #include of the header
   file) from the function template in the main part of the code. */

let default_template =
  "#include %h\n%%\n\n%r %w(%p)\n{\n  return %n(%a);\n}\n";

/* An alternative template for wrapper functions returning struct values. */

let default_alt_template =
  "\n%r* %w(%p)\n{\n  static %r ret;\n  ret = %n(%a); return &ret;\n}\n";

/* Messaging. */

let warn, verbose, echo_cpp = false, false, false;
warning n::int s::string = fprintf stderr "Warning: %s\n" s if n<=warn;
echo 1 s::string = puts s if verbose;
echo 2 s::string = puts s if echo_cpp;

let cache = ref emptydict;
warn_once n msg::string = warning n msg if msgcache msg
with
  msgcache msg::string  = 0 if member (get cache) msg;
			= put cache (insert (get cache) (msg=>())) $$ 1;
end;

/******************************************************************/

// Haskell Maybe type constructor
nonfix Nothing;

// Language.C AST terminals
// typedef storage spec, denotes typedefs
nonfix CTypedef;
// const qualifier
nonfix CConstQual;
// basic C types
nonfix CVoidType CCharType CShortType CIntType CLongType CFloatType
  CFloat128Type CDoubleType CSignedType CUnsigType CBoolType;
// struct/union types (these aren't used right now)
nonfix CStructTag CUnionTag;
// constant expressions, we evaluate these
nonfix CPlusOp CMinOp CNegOp CAddOp CSubOp CMulOp CDivOp CRmdOp CShlOp
  CShrOp CLeOp CGrOp CLeqOp CGeqOp CEqOp CNeqOp CAndOp COrOp CLndOp CLorOp
  CXorOp;

// these mirror the ffi type values
nonfix unsupported_t void_t uint8_t sint8_t uint16_t sint16_t
  uint32_t sint32_t uint64_t sint64_t
  uchar_t schar_t ushort_t sshort_t uint_t sint_t ulong_t slong_t
  float_t double_t longdouble_t float128_t pointer_t string_t;
// special pure_expr and GSL matrix types
nonfix expr_t;
nonfix dmatrix_t cmatrix_t imatrix_t;

// to_ffi_type does a preliminary conversion from Language.C types (types
// specified in the C spec) to ffi types (real types on the machine.)
// short, long, signed and unsigned can also be used as modifiers,
// in which case the _t suffix is dropped.

to_ffi_type x fname =
  case x of
  //these come from Language.C
  CVoidType     = void_t;
  CCharType     = schar_t;
  CShortType    = sshort_t;
  CIntType      = sint_t;
  CLongType     = slong_t;
  CFloatType    = float_t;
  CFloat128Type = float128_t;
  CDoubleType   = double_t;
  CSignedType   = sint_t;
  CUnsigType    = uint_t;
  CBoolType     = sint_t; //??? char?
  CTypeDef str  = CTypeDef str; //these are resolved in a second pass
  CEnumType (CEnum (Just tag) (Just enum_defs) _)
	        = enum_type tag (scan_enums enum_defs) fname;
  CEnumType (CEnum Nothing (Just enum_defs) _)
	        = enum_type "<anonymous>" (scan_enums enum_defs) fname;
  CEnumType (CEnum _ _ _)
	        = sint_t;
  CSUType (CStructUnion _ (Just tag) _ _) = struct_or_union $ "struct "+tag;
  CSUType (CStructUnion _ Nothing _ _) = struct_or_union "<anonymous>";
  _             = warn_once 1 $ "unsupported type "+str x $$ unsupported_t;
  end;

/* FIXME: This dictionary *must* be properly initialized using decl_enums
   before scan_enums gets invoked through any of the other declaration
   processing functions. We should really make this an argument to scan_enums,
   but the necessary plumbing is just horrible, so we prefer to have this as a
   global here. */
let enumdefs = emptydict;
scan_enums defs =
  /* We need to take care of the case of an unresolved enum symbol here.
     Assume that it's a #defined symbol which will hopefully be resolved in
     resolve_indirects. */
  [(if stringp v then indirect else constant) n v when v = enumdefs!n end |
   n,_ = defs; member enumdefs n /* == true, but who knows */];

enum_vals (basic_type t) = enum_vals t;
enum_vals (const_type t) = enum_vals t;
enum_vals (enum_type _ v fname) = [x fname | x = v];
enum_vals _ = [];

// pure_type takes an ffi type and makes a string suitable for a pure
// extern declaration

//these mirror the ffi type values
pure_type t =
case t of
  void_t     = "void";
  uint8_t    = "char";
  sint8_t    = "char";
  uint16_t   = "short";
  sint16_t   = "short";
  uint32_t   = "int";
  sint32_t   = "int";
  uint64_t   = "int64";
  sint64_t   = "int64";
  float_t    = "float";
  // Pure doesn't support long double or __float128, just map it to double.
  // This works fine with -fc, otherwise we catch this elsewhere.
  longdouble_t | float128_t |
  double_t   = "double";
  pointer_t  = "void*";
  uchar_t    = "char";
  schar_t    = "char";
  ushort_t   = "short";
  sshort_t   = "short";
  uint_t     = "int";
  sint_t     = "int";
  ulong_t    = "long";
  slong_t    = "long";
  expr_t     = "expr";
  dmatrix_t  = "dmatrix";
  cmatrix_t  = "cmatrix";
  imatrix_t  = "imatrix";
  // Pure doesn't care about const.
  const_type t = pure_type t;
  ptr_type (const_type t) = pure_type (ptr_type t);
  ptr_type longdouble_t = "void/*long double*/*";
  ptr_type float128_t = "void/*__float128*/*";
  ptr_type (func_type _ _ _) = "void*";
  ptr_type (struct_or_union n) =
    /* NOTE: We map 'struct id' to just 'id' here. This seems more useful than
       just generating a void* pointer, now that Pure cross-checks C pointer
       types. */
    case split " " n of
      [n] | ["struct",n] = n+"*" if n~="<anonymous>";
      _ = sprintf "void/*%s*/*" n otherwise;
    end;
  ptr_type t = pure_type t + "*";
  // struct values get mapped to pointers in the C wrapper
  t@(struct_or_union n) = pure_type (ptr_type t);
  _          = warning 0 ("pure_type error : "+str t) $$ "void";
end;

// The corresponding C types:
c_basetype t =
case t of
  uint8_t    = "unsigned char";
  sint8_t    = "char";
  uint16_t   = "unsigned short";
  sint16_t   = "short";
  uint32_t   = "unsigned int";
  sint32_t   = "int";
  uint64_t   = "unsigned long long";
  sint64_t   = "long long";
  uchar_t    = "unsigned char";
  schar_t    = "char";
  ushort_t   = "unsigned short";
  sshort_t   = "short";
  uint_t     = "unsigned int";
  sint_t     = "int";
  ulong_t    = "unsigned long";
  slong_t    = "long";
  const_type t = c_basetype t+" const";
  ptr_type longdouble_t = "long double*";
  ptr_type float128_t = "__float128*";
  ptr_type (func_type _ _ _) = "void*";
  ptr_type t = c_basetype t + "*";
  struct_or_union n = n;
  expr_t = "pure_expr";
  dmatrix_t = "gsl_matrix";
  cmatrix_t = "gsl_matrix_complex";
  imatrix_t = "gsl_matrix_int";
  _ = pure_type t;
end;

c_type t =
case t of
  // translate struct value parameters to pointers
  const_type (struct_or_union n) = n+" const *";
  struct_or_union n = n+"*";
  _ = c_basetype t;
end;

// Special version for return values. This is just c_basetype for now.
c_rettype t = c_basetype t;

// complete_ffi_type finishes the conversion by collecting typespecifiers such
// as long, unsigned, etc. This also strips away the "basic_type" specifier,
// which is used mostly for typedef resolution.

complete_ffi_type (basic_type x)  = complete_ffi_type x;



// ffi only knows "pointer_t" but pure's extern decls can take typed pointers
//complete_ffi_type (ptr_type _)    = pointer_t;
complete_ffi_type (const_type t) = const_type (complete_ffi_type t);
complete_ffi_type (ptr_type t) = ptr_type (complete_ffi_type t);

complete_ffi_type (func_type r a v) = func_type (complete_ffi_type r)
				      (map complete_ffi_type a) v;
complete_ffi_type (struct_or_union "pure_expr") = expr_t;
complete_ffi_type (struct_or_union "gsl_matrix") = dmatrix_t;
complete_ffi_type (struct_or_union "gsl_matrix_complex") = cmatrix_t;
complete_ffi_type (struct_or_union "gsl_matrix_int") = imatrix_t;
complete_ffi_type t@(struct_or_union n) = t if n~="<anonymous>";
complete_ffi_type (structure n f) =
  structure n (zip ns (map complete_ffi_type fs))
  when (ns,fs) = unzip f end;

complete_ffi_type x =
  case x of
  //this is kind of a mess, due to all the different ways one might
  //specify an int: int, long int, long, singed long, signed long int...
  unsupported_t   = unsupported_t;
  pointer_t   = pointer_t;
  void_t   = void_t;
  schar_t  = schar_t;
  sshort_t = sshort_t;
  slong_t  = slong_t;
  sint_t   = sint_t;
  uint_t   = uint_t;
  long double_t        = longdouble_t;
  (long (sint_t))      = slong_t;
  (long (slong_t))     = sint64_t;
  (long (long sint_t)) = sint64_t;
  float_t  = float_t;
  float128_t  = float128_t;
  double_t = double_t;
  signed schar_t    = schar_t;
  signed sshort_t   = sshort_t;
  signed sint_t     = sint_t;
  signed slong_t    = slong_t;
  signed (short (sint_t))     = sshort_t;
  signed (long (sint_t))      = slong_t;
  signed (long (slong_t))     = sint64_t;
  signed (long (long sint_t)) = sint64_t;
  short (signed (sint_t))     = sshort_t;
  long (signed (sint_t))      = slong_t;
  long (signed (slong_t))     = sint64_t;
  long (signed (long sint_t)) = sint64_t;
  unsigned schar_t  = uchar_t;
  unsigned sshort_t = ushort_t;
  unsigned sint_t   = uint_t;
  unsigned slong_t  = ulong_t;
  unsigned (short (sint_t))     = ushort_t;
  unsigned (long (sint_t))      = ulong_t;
  unsigned (long (slong_t))     = uint64_t;
  unsigned (long (long sint_t)) = uint64_t;
  short (unsigned (sint_t))     = ushort_t;
  long (unsigned (sint_t))      = ulong_t;
  long (unsigned (slong_t))     = uint64_t;
  long (unsigned (long sint_t)) = uint64_t;

  enum_type _ v _ = if any negative v then sint_t else uint_t
  with negative (constant _ x) = x<0; negative _ = false end;

  _ = warn_once 1 ("unsupported type "+str x) $$ unsupported_t;

  end;


// exception value signifying an unknown or unrecognized C type
nonfix unknown_decl_type;

// The primitive type of a declaration. Returns an ffi type, with specifiers.
// We do need to keep track of the const qualifier, to make the C compiler
// happy.
type_spec ( (CTypeQual CConstQual) : more ) fname = const_type $ type_spec more fname;
// Skip all other qualifiers like volatile etc.
type_spec ( (CTypeQual _) : more ) fname = type_spec more fname;

type_spec ( (CTypeSpec CShortType) :  []  ) _ = sshort_t;
type_spec ( (CTypeSpec CShortType) : more ) fname = short $ type_spec more fname;

type_spec ( (CTypeSpec CLongType) :  []  ) _ = slong_t;
type_spec ( (CTypeSpec CLongType) : more ) fname = long $ type_spec more fname;

type_spec ( (CTypeSpec CUnsigType) :  []  ) _ = uint_t;
type_spec ( (CTypeSpec CUnsigType) : more ) fname = unsigned $ type_spec more fname;

type_spec ( (CTypeSpec CSignedType) :  []  ) _ = sint_t;
type_spec ( (CTypeSpec CSignedType) : more ) fname = signed $ type_spec more fname;

type_spec ( (CTypeSpec t) : _ ) fname = to_ffi_type t fname;
 //I don't really know what else could be in the list here

type_spec ( _ : more ) fname = type_spec more fname;
type_spec [] _ = throw unknown_decl_type;



// decl_type : Grab a simplified type representation from a declaration.
// Result is a list of the following terms:
//    basic_type t: t is a c primitive type or a typedef
//    ptr_type t: t is again one of basic_type, ptr_type or func_type
//    func_type ret args va: ret is again one basic_type, ptr_type or
//      func_type, args is a list of such terms, and va is a flag which is
//      true if the function is variadic (... syntax).
// If the type cannot be described in the above terms, an exception
// "unknown_decl_type" is thrown.
//
// The returned list contains one type for each object declared in this
// declaration, e.g. "int *x, y;" yields
// [ ptr_type(basic_type sint_t), basic_type sint_t ]

// Move the const qualifier out of the typespec, some code depends on this.
basic_type (const_type t) = const_type (basic_type t);

decl_types (CFDefExt _) = [];
decl_types (CDeclExt d fname) = decl_types1 d fname;

decl_types1 d@(CDecl decl_specs [] ) fname =
  catch (\_->warning 2 $ sprintf "Unknown declaration type: %s" (str d) $$ [])
  [ basic_type (type_spec decl_specs fname) ];
decl_types1 d@(CDecl decl_specs init_declr_list ) fname =
  catch (\_->warning 2 $ sprintf "Unknown declaration type: %s" (str d) $$ [])
  (decl_types2 d fname);

decl_types2 d@(CDecl decl_specs init_declr_list) fname =
  case init_declr_list of
    (Just (CDeclr _ derivs _ arg_attrs), Nothing, Nothing) : more =
        apply_derivs (type_spec decl_specs fname) derivs : decl_types2 (CDecl decl_specs more) fname;
    [] = [];
    _ = [];
  end
  with
    //basic_type : get the type of a declaration, ignoring storage and access
    //modifiers (except const)
    apply_derivs t [] = basic_type t;
    apply_derivs t ( (CPtrDeclr m  ) : derivs ) |
    apply_derivs t ( (CArrDeclr m _) : derivs )
    //treat arrays as pointers,even if they are proper array objects
    = const_type (ptr_type $ apply_derivs t derivs)
        if any ((===) CConstQual) m;
    = ptr_type $ apply_derivs t derivs;
    apply_derivs t ( (CFunDeclr args _) : derivs ) =
      case args of
        Right (arg_decls,va) =
	  func_type (apply_derivs t derivs)
	  (catmap (flip decl_types1 fname) arg_decls) va;
        Left _      = //old-style K&R declaration.
          throw unknown_decl_type;
      end;
  end;



// decl_idents : Grab the names of things declared in a declaration. Returns a
// list of strings (identifiers) which may be empty if the declaration is
// anonymous (i.e., a function parameter) or may contain multiple identifiers
// if the declaration declares multiple things, e.g. "int x,y,z;"

decl_idents (CFDefExt _) = [];
decl_idents (CDeclExt d _) = decl_idents d;
decl_idents d@(CDecl _ init_declr_list) =
  case init_declr_list of
    (Just (CDeclr (Just ident) _ _ _), _, _) : more =
        ident : decl_idents (CDecl decl_specs more);
    _ = [];
  end;



is_typedef ( (CStorageSpec CTypedef) : decl_specs) = 1;
is_typedef ( _ : decl_specs) = is_typedef decl_specs;
is_typedef [] = 0;


// typedefs : returns a list of (name=>type) bindings, possibly empty if this
// declaration was not a typedef
typedefs (CFDefExt _) = [];
typedefs (CDeclExt d fname) = typedefs1 d fname;
typedefs1 d@(CDecl decl_specs _) fname =
  if is_typedef decl_specs
  then zip (decl_idents d) (decl_types1 d fname)
  else [];

// same for implicit enum types (no proper typedef), this returns just the
// enum type without type name (as a singleton list) or the empty list if none
enumtypedefs (CFDefExt _) = [];
enumtypedefs (CDeclExt d fname) = enumtypedefs1 d fname;
enumtypedefs1 d@(CDecl decl_specs _) fname =
  case decl_specs of
    [CTypeSpec (CEnumType (CEnum (Just tag) (Just enum_defs) _))]
      = [enum_type tag (scan_enums enum_defs) fname];
    [CTypeSpec (CEnumType (CEnum Nothing (Just enum_defs) _))]
      = [enum_type "<anonymous>" (scan_enums enum_defs) fname];
    _ = [];
  end;

// func_decl : returns the list of triples (name,type,fname) for all
// function declarations in this declaration.
func_decl (CFDefExt _) = [];
func_decl (CDeclExt d fname) = func_decl1 d fname;
func_decl1 d@(CDecl decl_specs _) fname
= [] if is_typedef decl_specs; // skip typedefs
= [decl,fname | decl = zip (decl_idents d) (decl_types1 d fname);
                is_func_decl decl]
  with
    is_func_decl (_,func_type ret args va) = true;
    is_func_decl _ = false otherwise;
  end;

//resolve a typedef : d is a dictionary
resolve_typedef d t fname = lookup t
  with
    lookup (basic_type (CTypeDef n)) =
      catch ( \_ -> warning 2 $ "could not resolve typedef: "+n+
                                ", defaulting to void*" $$ pointer_t  )
            ( patch_typedef n $ lookup (d!n) );

    lookup (basic_type (CSUType _ (CStructUnion _ (Just name) _ _))) =
      basic_type (struct_or_union $ "struct "+name);
    lookup (basic_type (CSUType _ (CStructUnion _ Nothing _ _))) =
      basic_type (struct_or_union "<anonymous>");
    lookup t@(struct_or_union _ _) = t;
    lookup (basic_type (CEnumType (CEnum (Just tag) (Just enum_defs) _))) =
      basic_type (enum_type tag (scan_enums enum_defs) fname);
    lookup (basic_type (CEnumType n)) = sint_t;
    lookup t@(enum_type n _ _) = t;
    lookup t@(basic_type _) = t;
    lookup (const_type t) = const_type (lookup t);
    lookup (ptr_type t) = ptr_type (lookup t);
    lookup (func_type ret args va) =
      func_type (lookup ret) (map lookup args) va;
    lookup x = warning 0 ("resolve_typedef error: "+str x) $$ void_t;

    // Patch up typedefs for anonymous structs, so that we use the typedef
    // name for the struct instead. This is needed to make the gsl matrix
    // typemapping work.
    patch_typedef n (basic_type (struct_or_union _)) =
      basic_type (struct_or_union n);
    patch_typedef n t = t otherwise;
  end;

resolve_decl_typedefs tydefs decls =
  map (\(n,t,fname) -> (n , resolve_typedef tydefs t fname, fname) ) decls;

resolve_struct_typedefs tydefs (structure name fields) =
  structure name $ resolve_decl_typedefs tydefs fields;





// Gather the declared structs or unions. C allows structs to be declared just
// about anywhere but we only grab them from three toplevel declarations:
//   struct X { .. };
//   typedef struct Y { .. } X;
//   typedef struct { .. } X;
// In any case, the struct is bound to the name X.
//
// The result is either [] or [structure name fields] where
// fields are a list of (name,type) tuples
//
// Does not handle nested structs or unions yet.

decl_struct (CFDefExt _) = [];
decl_struct (CDeclExt d fname) = decl_struct1 d fname;
decl_struct1 d@(CDecl ( (CStorageSpec CTypedef ) :
                        (CTypeSpec (CSUType strct)) : _ )
		init_declr_list) fname
    =
  case strct of
    //struct name
    CStructUnion _ (Just _) (Just fields) _  | //struct has a tag
    CStructUnion _ Nothing (Just fields)  _  = //struct is anonymous.
      [ structure name $
        zip (catmap decl_idents fields) (catmap (flip decl_types1 fname) fields) ];
    _ = [];
  end
  when
    name = head $ decl_idents d;
  end;

decl_struct1 d@(CDecl ( (CTypeSpec (CSUType strct)) : _ ) [] ) fname =
  case strct of
    CStructUnion _ (Just name) (Just fields) _  =
      [ structure name $
        zip (catmap decl_idents fields) (catmap (flip decl_types1 fname) fields) ];
    _ = [];
  end;

decl_struct1 d _ = [];




// Scrape enum constants. Takes a list of top-level declarations (CDeclExt)
// and produces a dictionary of name=>value pairs. This has to be run over the
// whole list because some constants will be defined in terms of others.
decl_enums =
  foldl get_enum emptydict;

get_enum dict (CFDefExt _) = dict;

get_enum dict (CDeclExt d _) = get_enum dict d;

get_enum dict d@(CDecl ( (CStorageSpec CTypedef ) :
                         (CTypeSpec (CEnumType enum)) : _ )
                       init_declr_list)
    =
  case enum of
    CEnum _ (Just vals) _ = calc_enum_values dict () vals;
    _ = dict; // nothing to see here, move along
  end ;

get_enum dict d@(CDecl ( (CTypeSpec (CEnumType enum)) : _ ) []) =
  case enum of
    CEnum _ (Just vals) _ = calc_enum_values dict () vals;
    _ = dict; // nothing to see here, move along
  end;

get_enum dict _ = dict;


calc_enum_values dict prev ((name,Just e):more) =
  case eval_expr dict e of
    val::int = calc_enum_values (insert dict (name => val)) val more;
    x = warning 0 $ "Couldn't evaluate enum expression for "+name+" : "+str e
          $$ calc_enum_values dict prev more;
  end;

calc_enum_values dict () ((name,Nothing):more) =
   calc_enum_values (insert dict (name=>0)) 0 more;

calc_enum_values dict prev ((name,Nothing):more) =
    calc_enum_values (insert dict (name=>(prev+1))) (prev+1) more;

calc_enum_values dict _ [] = dict;

eval_expr d (CVar n) =
  catch
  (\e  ->
   // If we can't resolve this enum then it's probably a #defined symbol which
   // will hopefully be resolved in resolve_indirects later.
   warning 2$"Couldn't lookup name "+n+" in enum definition."$$n
  ) (d!n);

eval_expr d (CConst (CIntConst x)) = x;
eval_expr d (CConst (CCharConst x)) = ord x;

eval_expr d (CUnary  CPlusOp x) =     eval_expr d x;
eval_expr d (CUnary  CMinOp x) = neg (eval_expr d x);
eval_expr d (CUnary  CNegOp x) = ~ (eval_expr d x);
eval_expr d (CUnary  CCompOp x) = not (eval_expr d x);

eval_expr d (CBinary CAddOp e1 e2) = (eval_expr d e1) +   (eval_expr d e2);
eval_expr d (CBinary CSubOp e1 e2) = (eval_expr d e1) -   (eval_expr d e2);
eval_expr d (CBinary CMulOp e1 e2) = (eval_expr d e1) *   (eval_expr d e2);
eval_expr d (CBinary CDivOp e1 e2) = (eval_expr d e1) /   (eval_expr d e2);
eval_expr d (CBinary CRmdOp e1 e2) = (eval_expr d e1) mod (eval_expr d e2);
eval_expr d (CBinary CShlOp e1 e2) = (eval_expr d e1) <<  (eval_expr d e2);
eval_expr d (CBinary CShrOp e1 e2) = (eval_expr d e1) >>  (eval_expr d e2);
eval_expr d (CBinary CLeOp  e1 e2) = (eval_expr d e1) <   (eval_expr d e2);
eval_expr d (CBinary CGrOp  e1 e2) = (eval_expr d e1) >   (eval_expr d e2);
eval_expr d (CBinary CLeqOp e1 e2) = (eval_expr d e1) <=  (eval_expr d e2);
eval_expr d (CBinary CGeqOp e1 e2) = (eval_expr d e1) >=  (eval_expr d e2);
eval_expr d (CBinary CEqOp  e1 e2) = (eval_expr d e1) ==  (eval_expr d e2);
eval_expr d (CBinary CNeqOp e1 e2) = (eval_expr d e1) ~=  (eval_expr d e2);
eval_expr d (CBinary CAndOp e1 e2) = (eval_expr d e1) and (eval_expr d e2);
eval_expr d (CBinary COrOp  e1 e2) = (eval_expr d e1) or  (eval_expr d e2);
eval_expr d (CBinary CLndOp e1 e2) = (eval_expr d e1~=0)&&(eval_expr d e2~=0);
eval_expr d (CBinary CLorOp e1 e2) = (eval_expr d e1~=0)||(eval_expr d e2~=0);
eval_expr d (CBinary CXorOp e1 e2) = xor (eval_expr d e1) (eval_expr d e2)
  with
  xor a b = (a and not b) or (not a and b); // why exclude poor xor?
  end;
eval_expr d x = warning 0$"Unknown expression type "+str x+" in enum definition. Defaulting to 0." $$ 0;


// Dissect cpp lines (#define's and # lineno only).
extern int atoi(char*);
split_cpp_line s = regexg (process.tail.tail.regs)
"^#( (([0-9]+) \\\"([^\"]+)\\\"( .*)?)|[ \t]*define[ \t]+([A-Za-z_0-9]+)[ \t]+([^ \t].*))$" REG_EXTENDED s 0
with
  process ((2,_,_):(3,_,lno):(4,_,fname):_) = cpp_line (atoi lno) fname;
  process [(6,_,name),(7,_,val)] = cpp_define name val;
  process _ = ();
end;

// Grab all #define'd constants. lns is a list of strings, the
// lines of the file. Thus, this can't deal with #defines that span
// multiple lines.
scrape_defines lns = reverse defs
when defs,_ = foldl scrape_define ([],"") lns end
with
  scrape_define (out,fname) ln =
    case split_cpp_line ln of
      [cpp_define name val] = echo 2 $ sprintf "#define %s %s" (name,val) $$
        catch
          (\_ -> (warning 2 $ sprintf "Can't parse %s" ln) $$ (out,fname))
          ( check_constant name val fname : out, fname );
      [cpp_line lno fname] = echo 2 $ sprintf "# %d \"%s\"" (lno,fname) $$
        (out,fname);
      _ = (out,fname);
    end when ln = trim ln end;
end;

// Check for a constant value (either another #define'd constant, or a number).
check_constant name val::string fname
  = check_string name val fname
      if regex "^\".*\"$" REG_NOSUB val 0;
  = indirect name val fname
      if regex "^[A-Za-z_][A-Za-z_0-9]*$" REG_NOSUB val 0;
  = check_number name val fname;
check_number name val::string fname
  = check_number name (substr val 1 (#val-2)) fname
      if regex "^[(].*[)]$" REG_NOSUB val 0;
  = constant name (sscanf val "%i") fname
      if regex "^[+-]?([1-9][0-9]*|0[0-7]*|0[xX][0-9a-fA-F]+)[uUlL]*([ \t].*)?$"
	(REG_EXTENDED or REG_NOSUB) val 0;
  = constant name (sscanf val "%g") fname
      if regex "^[+-]?([0-9]*\\.?[0-9]*([Ee][+-]?[0-9]+)?)[dDfFlL]*([ \t].*)?$"
	(REG_EXTENDED or REG_NOSUB) val 0;
  = throw (bad_number val);
check_string name val::string fname
  = constant name str fname when str::string = eval val end;

// Some constants are defined in terms of others.  Here we resolve those
// indirections.
nonfix unknown_const;
resolve_indirects constants =
  filter ((~==) unknown_const) $ map (lookup dict) constants
  when
    dict = foldl build emptydict constants;
  end
  with
  build d i@(indirect n _ _) =
    /*puts ("adding ["+n+"] to dict") $$*/
    insert d (n=>i) ;
  build d c@(constant n _ _) =
    /*puts ("adding ["+n+"] to dict") $$*/
    insert d (n=>c) ;
  lookup _ c@(constant _ _ _) = c;
  lookup d (indirect n c src) = if n==c then unknown_const // #define x x
    else catch
      (\_ ->
          warning 2 $ "Target of indirected constant not found: \""+
                      n+"\" => \""+c+"\"" $$
          unknown_const )
      ( case d!c of
        (constant _ v _) = constant n v src;
        (indirect _ i _) = if c==i then unknown_const // #define x x
                           else lookup d (indirect n i src);
        end );
  end;



nmspacepfx nmspace = if null nmspace then "" else nmspace+"::";


// Output a constant declaration.
// If after stripping the prefix the constant name starts with a number, then
// add a leading underscore.
const_decl pfx nmspace (constant name val _) =
  case strip_prefix pfx name of
    name =
      if regex "^[0-9]" REG_NOSUB name 0
        then "const "+nmspacepfx nmspace+"_"+name+" = "+str val+";\n"
        else "const "+nmspacepfx nmspace+name+" = "+str val+";\n"
      ;
  end;

is_struct (const_type t) = is_struct t;
is_struct (struct_or_union _) = true;
is_struct _ = false;

needs_wrapper t = t === longdouble_t || t === float128_t || is_struct t;

//output a function declaration for the native pure extern interface
pure_extern_decl pfx::string nmspace::string (name, func_type ret args va, _)
= warning 0 $ sprintf "%s: unsupported argument type" name $$ ()
    if any ((===) unsupported_t) (ret:args);
= warning 0 $
  sprintf "%s: struct argument or return type, try -fc-auto" name $$ ()
    if any is_struct (ret:args);
= warning 0 $
  sprintf "%s: long double argument or return type, try -fc-auto" name $$ ()
    if any ((===) longdouble_t) (ret:args);
= warning 0 $
  sprintf "%s: __float128 argument or return type, try -fc-auto" name $$ ()
    if any ((===) float128_t) (ret:args);
= "extern "+pure_type ret+" "+name+"("+arg_str args va+")"+
  (if alias == name then "" else " = "+alias)+";"
when alias = strip_prefix pfx name end
with
  arg_str [void_t] va = if va then "..." else "";
  arg_str args va = (join ", " $ map pure_type args) +
    (if va then if null args then "..." else ", ..." else "");
end;

//output a function declaration for the native pure extern interface,
//prepending the prefix "Pure_" (or the prefix specified with -P) to the
//function name
Pure_extern_decl pfx::string nmspace::string (name, func_type ret args va, _)
= warning 0 $ sprintf "%s: unsupported argument type" name $$ ()
    if any ((===) unsupported_t) (ret:args);
= "extern "+pure_type ret+" "+wrap_prefix+name+"("+arg_str args va+")"+
  (if alias == wrap_prefix+name then "" else " = "+alias)+";"
when alias = strip_prefix pfx name end
with
  arg_str [void_t] va = if va then "..." else "";
  arg_str args va = (join ", " $ map pure_type args) +
    (if va then if null args then "..." else ", ..." else "");
end;

Pure_extern_decl_auto pfx nmspace x@(name, func_type ret args va, _)
= Pure_extern_decl pfx nmspace x if any needs_wrapper (ret:args);
= pure_extern_decl pfx nmspace x otherwise;

ffi_type (const_type t) = ffi_type t;
ffi_type (ptr_type (const_type t)) = ffi_type (ptr_type t);
ffi_type (ptr_type schar_t) = string_t;
ffi_type (ptr_type uchar_t) = string_t;
ffi_type (ptr_type _) = pointer_t;
// struct values get mapped to pointers in the C wrapper
ffi_type t@(struct_or_union n) = pointer_t;
ffi_type t = t otherwise;

//output a function declaration for the ffi interface
ffi_extern_decl pfx::string nmspace::string (name, func_type ret args va, _)
= warning 0 $ sprintf "%s: unsupported argument type" name $$ ()
    if any ((===) unsupported_t) (ret:args);
= warning 0 $
  sprintf "%s: struct argument or return type, try -fc-auto" name $$ ()
    if any is_struct (ret:args);
= warning 0 $
  sprintf "%s: long double argument or return type, try -fc-auto" name $$ ()
    if any ((===) longdouble_t) (ret:args);
= warning 0 $
  sprintf "%s: __float128 argument or return type, try -fc-auto" name $$ ()
    if any ((===) float128_t) (ret:args);
= "let "+nmspacepfx nmspace+strip_prefix pfx name+" = fcall \""+
  name+"\" FFI_DEFAULT_ABI "+str (ffi_type ret)+" ("+arg_str args+");"
with
  arg_str [void_t] = "";
  arg_str args = join ", " $ map (str.ffi_type) args;
end;

//output a function declaration for the ffi interface,
//prepending the prefix "Pure_" (or the prefix specified with -P) to the
//function name
Pure_ffi_extern_decl pfx::string nmspace::string (name, func_type ret args va, _)
= warning 0 $ sprintf "%s: unsupported argument type" name $$ ()
    if any ((===) unsupported_t) (ret:args);
= "let "+nmspacepfx nmspace+strip_prefix pfx name+" = fcall \""+
  wrap_prefix+name+"\" FFI_DEFAULT_ABI "+str (ffi_type ret)+
  " ("+arg_str args+");"
with
  arg_str [void_t] = "";
  arg_str args = join ", " $ map (str.ffi_type) args;
end;

Pure_ffi_extern_decl_auto pfx nmspace x@(name, func_type ret args va, _)
= Pure_ffi_extern_decl pfx nmspace x if any needs_wrapper (ret:args);
= ffi_extern_decl pfx nmspace x otherwise;


//output the C portion of a function
//TODO: at this point the typedefs have been resolved. It would be better
//if they were not.

replace_template template header_name ret_type wrapper_name formal_params name arg_names
  = regsub repl "(%%)|(%h)|(%r)|(%w)|(%p)|(%n)|(%a)" REG_EXTENDED template 0
with
  repl info = subst!(regs info!1!0-1)
  when
    subst = ["%",header_name,ret_type,wrapper_name,formal_params,name,
	     arg_names];
  end;
end;

c_impl (name, func_type ret args va, _)
= () if any ((===) unsupported_t) (ret:args);
= code
when
  va && warning 1 (sprintf "%s: varargs not supported in C wrappers" name);

  ret_str = c_rettype ret;

  formal_params =
    if args === [void_t] then "" else
    join ", " $ zipwith (\x y -> c_type x+" arg"+str y) args (0..inf);

  arg_names =
    if args === [void_t] then "" else
    join ", " $
    zipwith (\k t -> (if is_struct t then "*" else "") + "arg" + str k)
    (0..#args-1) args;

  code = replace_template (if is_struct ret then alt_template else template)
         (str in_name) ret_str (wrap_prefix+name) formal_params name arg_names;
end;

c_impl_auto x@(name, func_type ret args va, _)
= c_impl x if any needs_wrapper (ret:args);
= () otherwise;

/* Select constant and function declarations based on a regex match on the
   symbol, as well as a glob pattern match on the filename. */

let cflags = REG_NOSUB or REG_EXTENDED;
let fnflags = FNM_PATHNAME;
matches (fnpat,fnpatx) (pat,patx) x = matches fnpat pat x &&
				      ~matches fnpatx patx x;
matches fnpat pat (constant name _ fname) = valid_name fname name &&
  fnmatches fnpat fname fnflags && regchk pat (regex pat cflags name 0);
matches fnpat pat (name, _, fname) = valid_name fname name &&
  fnmatches fnpat fname fnflags && regchk pat (regex pat cflags name 0);

fnmatches pats name flags = true if null pats;
			  = any (\pat->fnmatch pat name flags) pats;

// some regex functions (BSD, notably) give an error for empty patterns, so
// we handle this case by always returning 1 (indicating success) instead
regchk "" _ = 1;
// other errors give a warning (once), but then we also make regex return 1
regchk pat (regerr _ _) = 1 when
  warn_once 0 (sprintf "error in regular expression '%s'" pat);
end;
regchk _ x = x;

// Filter out builtins and stuff commonly found in system header files.
const sys_excludes = ["","<built-in>"];
const junk_symbols = ["unix","linux"];
valid_name fname name = true if all_opt;
		      = false if substr name 0 1 == "_";
		      = ~any ((==) fname) sys_excludes &&
		        ~any ((==) name) junk_symbols;

//misc helpful stuff


//get all lines in a file
fgetlines f = reverse $ get []
  with
  get a =
    case fgets f of
    s::string = get (s:a);
    _ = a;
    end
  end;

// convert string to uppercase
extern int toupper(int) = ctoupper;
toupper s::string = string $ map (chr.ctoupper.ord) s;

strip_prefix pfx::string str::string =
  if str ~= pfx && toupper (substr str 0 (#pfx)) == toupper pfx then
    strip_us $ substr str (#pfx) (#str)
  else str
with
  strip_us str = if null str || str == "_" ||str!0 ~= "_" then str
                 else tail str;
end;

// remove trailing newline
trim ln = if null ln || last ln~="\n" then ln else init ln;

//need these for nub
constant a _ _ < constant b _ _ = a < b;
constant a _ _ > constant b _ _ = a > b;
constant a _ _ == constant b _ _ = a == b;

nub xs = reverse $ go [] emptydict xs
  with
  go a d (x:xs) = go a d xs if member d x;
                = go (x:a) (insert d (x=>x)) xs otherwise;
  go a _ [] = a;
  end;


/******************************************************************/

// Command line options and parameters.

let opts = [("--help", "-h", NOARG),
            ("--version", "-V", NOARG),
            ("--all", "-a", NOARG),
            ("--include", "-I", REQARG),
            ("--define", "-D", REQARG),
            ("--undefine", "-U", REQARG),
            ("--cpp", "-C", REQARG),
            ("--interface", "-f", REQARG),
            ("--output", "-o", REQARG),
            ("--c-output", "-c", REQARG),
            ("--lib-name", "-l", REQARG),
            ("--noclobber", "-N", NOARG),
            ("--namespace", "-m", REQARG),
            ("--prefix", "-p", REQARG),
            ("--select", "-s", REQARG),
            ("--exclude", "-x", REQARG),
            ("--wrap", "-P", REQARG),
            ("--template", "-t", REQARG),
            ("--alt-template", "-T", REQARG),
            ("--dry-run", "-n", NOARG),
            ("--warnings", "-w", OPTARG),
            ("--verbose", "-v", NOARG),
            ("--echo", "-e", NOARG)];

let dfls = ["--interface" => "extern",
            "--namespace" => "",
            "--prefix" => "",
            "--select" => "",
            "--wrap" => "Pure_",
            "--all" => "0",
            "--noclobber" => "0",
            "--dry-run" => "0",
            "--warnings" => "1",
            "--verbose" => "0",
            "--echo" => "0"];

invalid_option x = fprintf stderr "Error: unrecognized option '%s'\nType 'pure-gen -h' for help.\n" x $$ exit 1;

basename s::string = last path if ~null path when path = split "/" s end;
		   = s otherwise;
dirname s::string = join "/" $ init path if ~null path when path = split "/" s end;
		  = "" otherwise;
strip_ext s::string = head name if ~null name when name = split "." s end;
		    = s otherwise;

let prog, args = case argv of
                   prog:args = prog, args;
                   _ = "pure-gen.pure", []
                 end;
let opts, args = catch invalid_option $ getopt opts args;

// Filter out -l and the cpp options, these must be treated separately

let libnames = [x | opt@(k=>x) = opts; k=="--lib-name"];

is_cpp_opt ("--include"=>x) = true;
is_cpp_opt ("--define"=>x) = true;
is_cpp_opt ("--undefine"=>x) = true;
is_cpp_opt ("--cpp"=>x) = true;
is_cpp_opt _ = false otherwise;

let cpp_opts = join " " [format_cpp_opt opt | opt = opts; is_cpp_opt opt]
with
  format_cpp_opt ("--include"=>x) = sprintf "-I %s" (str x);
  format_cpp_opt ("--define"=>x) = sprintf "-D %s" (str x);
  format_cpp_opt ("--undefine"=>x) = sprintf "-U %s" (str x);
  format_cpp_opt ("--cpp"=>x) = x;
end;

is_normal_opt ("--lib-name"=>x) = 0;
is_normal_opt opt = ~is_cpp_opt opt otherwise;

// Create a dictionary of the remaining options, for easier processing.
let opts = foldl insert (dict dfls) (filter is_normal_opt opts);

if member opts "--version" then
puts copyright $$ exit 0
else ();

if member opts "--help" then
puts copyright $$
puts $ "Usage: pure-gen [options] <input-file>.h\n\
General options:\n\
-h, --help         Print this message and exit.\n\
-V, --version      Print version number and exit.\n\
-e, --echo         Echo preprocessor lines.\n\
-v, --verbose      Show parameters and progress information.\n\
-w, --warnings     Display warnings (level = 0, 1 [default] or 2).\n\
Preprocessor options:\n\
-I, --include      Add include path. Passed to the C preprocessor.\n\
-D, --define       Define symbol. Passed to the C preprocessor.\n\
-U, --undefine     Undefine symbol. Passed to the C preprocessor.\n\
-C, --cpp          Pass through other preprocessor options and arguments.\n\
Generator options:\n\
-f, --interface    Interface type ('extern', 'c', 'ffi' or 'c-ffi').\n\
-l, --lib-name     Add library module to be imported.\n\
-m, --namespace    Module namespace in which symbols should be declared.\n\
-p, --prefix       Module name prefix to be removed from C symbols.\n\
-P, --wrap         Prefix to be prepended to C wrapper symbols.\n\
-a, --all          Include \"hidden\" symbols.\n\
-s, --select       Filename/regex pattern of C symbols to be included.\n\
-x, --exclude      Filename/regex pattern of C symbols to be excluded.\n\
-t, --template     Specify C template file (see manpage for details).\n\
-T, --alt-template Specify alternate C template file.\n\
Output options:\n\
-n, --dry-run      Only parse without generating any output.\n\
-N, --noclobber    Append output to existing files.\n\
-o, --output       Pure output (.pure) filename.\n\
-c, --c-output     C wrapper (.c) filename (-fc).\n\
Defaults:\n\
-f extern, -P Pure_, -o <input-file>.pure, -c <input-file>.c.\n\
-l <c-file> (without extension) for -fc, none otherwise.\n\
Hint: Use -fc-auto or -fc-ffi-auto to only generate C wrappers if needed.\n\
Type 'man pure-gen' for more help." $$
exit 0
else ();

//let compiling = 1;

if ~compiling && #args~=1 then
fprintf stderr "Error: %s source file specified\nType 'pure-gen -h' for help.\n" (if null args then "no" else "more than one") $$ exit 1
else ();

if member opts "--interface" &&
  all ((~=) (opts!"--interface"))
  ["extern","ffi","c","c-ffi","c-auto","c-ffi-auto"] then
fprintf stderr "Error: invalid interface type (-f) '%s'\nType 'pure-gen -h' for help.\n" (opts!"--interface") $$ exit 1
else ();

// Get options, provide reasonable defaults.

extern int atoi(char*);
checknum name opt = x if str x==opt when x = atoi opt end;
		  = fprintf stderr "Error: bad %s option value '%s'\nType 'pure-gen -h' for help.\n" (name,opt) $$ exit 1;
defnum x name::string = checknum name opt if ~null opt
when opt = opts!name end;
defnum x _ = x otherwise;

split_pat x::string
= x!!(0..i-1), x!!(i+2..#x-1) if i>=0 when i = index x "::" end;
= x!!(0..i-1), x!!(i+1..#x-1) if i>=0 when i = index x ";" end;
= "", x;

let iface_opt = opts!"--interface";
let in_name = if compiling then "none" else head args;
let base = strip_ext $ basename in_name;
let out_name = if member opts "--output" then opts!"--output"
               else base + ".pure";
let c_name = if member opts "--c-output" then opts!"--c-output"
             else base + ".c";
let c_base = strip_ext $ basename c_name;
let libnames =
  if ~null libnames then libnames
  else if any ((==) (opts!"--interface"))
    ["c","c-ffi","c-auto","c-ffi-auto"] then [c_base]
  else [];
let [glob_pat, regex_pat] = list $ split_pat $ opts!"--select";
let [glob_patx, regex_patx] = if member opts "--exclude" then
  list $ split_pat $ opts!"--exclude" else [(),()];
let nmspace = opts!"--namespace";
let funpfx = opts!"--prefix";
let funpat = regex_pat, regex_patx;
let cstpfx = opts!"--prefix";
let cstpat = regex_pat, regex_patx;
let fnpatx = if glob_patx ~== () then split "," glob_patx else ();
let fnpat = split "," glob_pat, fnpatx;
let wrap_prefix = opts!"--wrap";
let all_opt = defnum 1 "--all";
let noclobber = defnum 1 "--noclobber";
let dry_run = defnum 1 "--dry-run";
let warn = defnum 1 "--warnings";
let verbose = defnum 1 "--verbose";
let echo_cpp = defnum 1 "--echo";

split_template template::string = frontmatter, template when
  lines = split "\n" template;
  lines1 = takewhile (\x->x~="%%") lines;
  lines2 = dropwhile (\x->x~="%%") lines;
  lines1,lines2 = if null lines2 then lines2,lines1 else lines1,tail lines2;
  frontmatter = join "\n" lines1;
  template = join "\n" lines2;
end;

let frontmatter, template = split_template template
when
  template = if member opts "--template" then
               fget (fopen (opts!"--template") "r")
             else default_template;
  template = if stringp template then template
             else fprintf stderr
               "Template file '%s' not found, using default template\n"
               (opts!"--template") $$ default_template;
end;

let alt_frontmatter, alt_template = split_template template
when
  template = if member opts "--alt-template" then
               fget (fopen (opts!"--alt-template") "r")
             else default_alt_template;
  template = if stringp template then template
             else fprintf stderr
               "Template file '%s' not found, using default template\n"
               (opts!"--alt-template") $$ default_alt_template;
end;

let dry_run = dry_run || compiling;

if dry_run then echo 1 "** Dry run." else ();
echo 1 $ sprintf "Input file:         %s" in_name;
echo 1 $ sprintf "Interface type:     %s" iface_opt;
echo 1 $ sprintf "Library import:     %s" (if null libnames then "(none)" else "using "+join ", " [sprintf "\"lib:%s\"" ln | ln = libnames]);
echo 1 $ sprintf "Module namespace:   %s" (if null nmspace then "(none)" else nmspace);
echo 1 $ sprintf "Module name prefix: %s" (if null modprefix then "(none)" else modprefix when modprefix = opts!"--prefix" end);
echo 1 $ sprintf "Symbol selection:   %s" (if null sel then "(all)" else sel when sel = opts!"--select" end);
echo 1 $ sprintf "Symbol excludes:    %s" (if member opts "--exclude" then opts!"--exclude" else "(none)");
echo 1 $ sprintf "CPP options:        %s" (if null cpp_opts then "(none)" else cpp_opts);
if member opts "--template" then
echo 1 $ sprintf "C template file:    %s" (opts!"--template")
else ();
if member opts "--alt-template" then
echo 1 $ sprintf "Alt template file:  %s" (opts!"--alt-template")
else ();

/******************************************************************/

// check that the source file exists
if compiling || pointerp (fopen in_name "r") then ()
else
  fprintf stderr "Error: source file '%s' not found (%s)\n"
  (in_name,strerror errno) $$ exit 1;

// read the source and its includes, this is needed to grab the #defines
let lines = if compiling then []
  else fgetlines $ popen (sprintf "%s %s %s" (cpp,cpp_opts,in_name)) "r";

//build the AST

echo 1 "Loading syntax tree";
let ast = if compiling then []
  else fgetlines $ popen (sprintf "%s %s %s %s" (dumper,gcc,cpp_opts,in_name)) "r";

echo 1 "Parsing syntax tree";
let declarations = filter ((~==) ()) $ map check_eval ast
with
  check_eval s = res if null lasterr when res = eval s end;
               = warning 0 (sprintf "Parse error: '%s'." (trim s)) $$ ();
end;

// This has to be done before processing the other declarations.
echo 1 "Building enum dictionary";
let enumdefs = decl_enums declarations;


echo 1 "Building typedef dictionary";
let tydefs =
      foldl (\d (n,t) -> insert d (n=>t)) emptydict $
        catmap typedefs declarations;
// we also need to keep track of enums declared outside a proper typedef
let enumtydefs = catmap enumtypedefs declarations;


echo 1 "Gathering constant definitions";
let defines =
  nub $ resolve_indirects $ scrape_defines lines +
        catmap enum_vals (vals tydefs+enumtydefs);


echo 1 "Gathering function prototypes";
//all function prototypes
let func_protos =
      mapsnd complete_ffi_type $
        resolve_decl_typedefs tydefs $
          catmap func_decl declarations
  with
    mapsnd f = map (\(a,b,c) -> a,f b,c)
  end;


//Output the Pure part
let w = if dry_run then __none__ else if noclobber then "a" else "w";
let out_pure   = fopen out_name w;

let all_defines = filter (matches fnpat cstpat) defines;
let all_protos = unique $ filter (matches fnpat funpat) func_protos with
  unique (s, [], out) = reverse out;
  unique (s,  l@(x:xs), out) =
    if member s name then
      s!name ~== x &&
      warning 1 (sprintf "conflicting prototypes for %s" name) $$
      unique (s, xs, out)
    else unique (insert s (name=>x), xs, x:out)
    when name = x!0; end;
  unique l = unique (emptydict, l, []);
end;

let extern_decl = case iface_opt of
  "extern" = pure_extern_decl;
  "ffi" = fputs "using ffi;\n" out_pure $$ ffi_extern_decl;
  _ = if iface_opt=="c" || iface_opt=="c-auto" then
        (if iface_opt=="c" then Pure_extern_decl
	 else Pure_extern_decl_auto)
      else fputs "using ffi;\n" out_pure $$
        (if iface_opt=="c-ffi" then Pure_ffi_extern_decl
	 else Pure_ffi_extern_decl_auto)
  when
    //Output the C part
    out_c = fopen c_name w;
    if dry_run then () else echo 1 $ sprintf "Writing %s" c_name;

    fprintf out_c "%s\n" $
      replace_template frontmatter (str in_name) "" "" "" "" "";
    if ~null alt_frontmatter then
      fprintf out_c "\n%s\n" $
        replace_template alt_frontmatter (str in_name) "" "" "" "" ""
    else ();
    c_impl = if iface_opt=="c" || iface_opt=="c-ffi" then c_impl
             else c_impl_auto;
    do (flip fputs out_c) $ map c_impl all_protos;
  end;
end;
if dry_run then () else echo 1 $ sprintf "Writing %s" out_name;
fprintf out_pure "/* %s: */\n" in_name;
if ~null libnames then fprintf out_pure "using %s;\n" (join ", " [sprintf "\"lib:%s\"" ln | ln = libnames]) else ();
if ~null nmspace then fprintf out_pure "\nnamespace %s;\n" nmspace else ();

do (flip fputs out_pure . const_decl cstpfx nmspace) all_defines;

do (flip fputs out_pure) $
  map (\x -> extern_decl funpfx nmspace x + "\n") all_protos;

let n_const = #all_defines;
let n_func = #all_protos;
echo 1 $ sprintf "%d constants, %d externs" (n_const,n_func);

if ~compiling && n_const+n_func == 0 then
  warning 1 "empty output"
else ();
