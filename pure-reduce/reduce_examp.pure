
using math, reduce;

// Differentiation.
simplify $ df ((x+1)^2) x;
simplify $ df ((x+5)^3) x;
simplify $ df ((x-5)^3) x;

// Integration.
simplify $ intg 2 x;
simplify $ intg (x^2) x;
simplify $ intg (x^2.0) x;
simplify $ intg (x^2.09) x;
// This enables rounded results.
reduce::switch "rounded" 1;
simplify $ intg (x^2) x;
simplify $ intg (x^2.09) x;
// Switch back to exact results.
reduce::switch "rounded" 0;
simplify $ intg (sin x) x;
simplify $ intg (exp (2*x) ) x;

// Equation solving.
simplify $ solve (x^2+7) x;
simplify $ solve (x^2+7==17) x;
reduce::switch "rounded" 1;
simplify $ solve (x^2+7==17) x;
reduce::switch "rounded" 0;
simplify $ solve (log(sin(x+3))^5 == 8) x;

// Multiple equations.
let eqs = [3*x + 5*y == -4, 2*x + y == -10];
let sol:_ = simplify $ solve eqs [x, y]; sol;
// Convert the solution to a list of hash pairs.
let sol = [x=>y | x==y = sol]; sol;
// This format is more convenient to check the result with reduce_with.
map (eval.reduce_with sol) eqs;
map (eval.reduce_with sol) [u-v | u==v = eqs];

// Note the inaccuracies. This happens because the x/y terms evaluate to
// inexact (double) results in Pure. We can fix this with the following little
// helper function which translates x/y to x%y terms.
exact (x/y) = x%y;
exact (x@_ y) = 'x y when x = exact x; y = exact y end;
exact x = x otherwise;

let sol = exact sol; sol;
map (eval.reduce_with sol) eqs;

// Matrix examples.
simplify $ mat [1,2] [3,4];
// You can also write:
simplify {1,2;3,4};

// Symbolic matrices.
simplify $ x*{1,2;3,4};
simplify {(x-1)^2/(x+5);(x-1+cos x)^2/(x+5)};

// Determinants and eigenvectors.
simplify $ det {1,2;3,4};
simplify $ det (x*{1,2;3,4});
simplify $ mateigen {2,5;1,0} λ;
simplify $ mateigen (x*{2,5;1,0}) λ;

// Lisp evaluation. This should be used with utmost care, as the PROC interface
// easily crashes if you try to execute some non-existing Lisp function!
lisp ('car (list a b c d e));
// Pure lists are automagically converted to Lisp lists. The result is always
// returned as a Pure list.
lisp ('cdr [a,b,[c,d],e]);

// Lisp evaluation can be used in the REDUCE system, in particular, to declare
// operator symbols and their properties (simplify won't do that). E.g.:
lisp ('operator [myop]);
lisp ('flag [myop] odd);
lisp ('prop myop); // => [odd:t,simpfn:simpiden]
simplify (myop (-x)); // => -myop x

// For the most common kinds of declarations, the reduce module already
// provides the 'declare' function which takes care of the necessary Lisp
// magic and is safe to use. The above example can also be done as follows:
declare operator myop;
declare odd myop;
simplify (myop (-x)); // => -myop x

// The depend/nodepend declarations are used to declare (or get rid of)
// dependencies between kernels:
declare depend [y,x];
simplify (df (y^2) x);
declare nodepend [y,x];

declare depend [z,cos x,y];
simplify (df (sin z) (cos x));
simplify (df (z^2) x);
