
/* A basic interface to the computer algebra system REDUCE available at
   http://www.reduce-algebra.com/. */

using "lib:reduce" ;

/* Low-level interface. ******************************************************/

/* This is the low-level "procedural" REDUCE interface (cf. csl/cslbase/proc.h
   in the REDUCE sources at http://reduce-algebra.svn.sourceforge.net). We
   declare these routines in their own namespace in order to keep the global
   namespace clean. */

namespace reduce;

/**************************************************************************
 * Copyright (C) 2010, Codemist Ltd.                     A C Norman       *
 *                                                                        *
 * Redistribution and use in source and binary forms, with or without     *
 * modification, are permitted provided that the following conditions are *
 * met:                                                                   *
 *                                                                        *
 *     * Redistributions of source code must retain the relevant          *
 *       copyright notice, this list of conditions and the following      *
 *       disclaimer.                                                      *
 *     * Redistributions in binary form must reproduce the above          *
 *       copyright notice, this list of conditions and the following      *
 *       disclaimer in the documentation and/or other materials provided  *
 *       with the distribution.                                           *
 *                                                                        *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    *
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT      *
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS      *
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE         *
 * COPYRIGHT OWNERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,   *
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,   *
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS  *
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND *
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR  *
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF     *
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
 * DAMAGE.                                                                *
 *************************************************************************/

//typedef int character_reader(void);
//typedef int character_writer(int);

/*
 * When a handle on an expression is returned to the user this is the
 * type it has. The type should be treated as opaque, please.
 */

//typedef void *PROC_handle;

/*
 * Before trying to do anything at all you must call cslstart. This will
 * allocate memory, load an initial heap image etc etc. The argc and argv
 * passed here are as per normal C startup. The key issue here is how
 * Reduce will find the file "reduce.img" that it needs to load. There are
 * two plausible ways you can achieve this.
 * (a) argv[0] should contain a (for choice) fully rooted path as in
 *     /usr/local/bin/reduce
 * or  c:\my-reduce\binaries\reduce.exe
 *     In that case the name of the supposed execitable has ".img" tagged
 *     onto it, so the image is expected to be at say /usr/local/bin/reduce.img
 *     If the application name is the name of a symbolic link then the
 *     image file is looked for in the dircetory that the link points to.
 * (b) You can put "-i" "/path/to/reduce.img" in two consecutive entries
 *     in argv to give an explicit indication of where the image file
 *     is to be found. This should override any attempt to look via
 *     argv[0].
 * Most users should not need to provide any further options, but options
 * are decoded just as for the ordinary version of the system.
 *
 * Any textual output generated during system-started is sent, character
 * by character, via the callback function. Eg pass an option "-v" in
 * argv and see a big banner.
 */

extern void cslstart(int argc, char **argv, int *wr);

/*
 * At the end of a run please call cslfinish to close down everything
 * in a reasonably orderly manner and release memory. I should cautiously
 * note that the system will have some memory leaks so cslfinish will
 * not return EVERYTHING that has been allocated - if this worries you
 * please search for and correct the defects. Again the callback function
 * is used to process any output generated during close-down.
 */

extern int cslfinish(int *wr);

/*
 * As a general-purpose escape it is possible to get a Lisp function
 * (with no arguments) called. This function does that re-binding
 * what would otherwise be terminal input and output to the two
 * callback functions. By writing your own custom Lisp function and then
 * calling it this way you get almost ultimate flexibility, if not
 * convenience! For used of the Reduce algebra system I hope that the
 * suite of more specialised functions listed later on will prove
 * easier to use.
 */

extern int execute_lisp_function(char *fname,int *r, int *w);


/*
 * The next collection of functions provide for interaction with the
 * Reduce algebra system using a model based on a Reverse Polish
 * Calculator. You use RPN-style calls to build a fragment of parse
 * tree and can them as Reduce to "simplify" it. Having simplified it
 * you can ask for a simple prefix-form of the result to be generated and
 * returned, and there are functions for traversing that.
 */

/*
 * Example:
 *  Task:   differentiate (x+1)^2 with respect to x
 *  Method: clear_stack();
 *          push_symbol("x");
 *          push_small_integer(1);
 *          make_function_call("plus",2);   function plus has 2 arguments.
 *          push_small_integer(2);
 *          make_function_call("expt",2);
 *          push_symbol("x");
 *          make_function_call("df",2);     "df" is for differentiate.
 *                                          To use this you need to learn
 *                                          the named Reduce uses for all
 *                                          relevant operations.
 *          simplify();                     up until now the form built
 *                                          has been just the prefix form
 *                                          (expt (plus x 1) 2).
 *          dup();                          because save will pop the stack
 *          save(1);                        save in "memory number 1".
 *          make_printable();               the simplified form is in
 *                                          a Reduce internal representation,
 *                                          so this restores it to simple
 *                                          prefix form.
 *          p = get_value();
 * now p holds a handle on the result, and it can be traversed
 * using functions atom(), first(), rest() and functions that extract the
 * name of a symbol or the value of an integer. You should assume that the
 * handle becomes invalid as soon as you call one of the other functions.
 * this is because they can all trigger garbage collection and that can
 * relocate data.
 * The functions used to build expressions all return zero on success or
 * an error-code otherwise. In the initial release the error-codes are
 * not documented other than via reading the source files. Furthermore the
 * consequence of a calculation seeking input or generating output is not
 * well sorted.
 */


/*
 * After having called cslstart() you can set the I/O callback functions
 * using this. If you set one or both to NULL this indicates use of
 * stdin/stdout as per usual rather than an callback, otherwise whenever
 * anybody wants to read or write they use these procedures. It is then
 * your responsibility to cope with whatever text gets exchanged!
 */

extern int PROC_set_callbacks(int *r, int *w);

/*
 * Load a Reduce "package".
 */

extern int PROC_load_package(char *name);

/*
 * Set of clear a Reduce switch. As on "on expandlogs;"
 * which you do via PROC_set_switch("expandlogs", 1);
 * Use 0 to switch something off and 1 to switch it on.
 */

extern int PROC_set_switch(char *name, int val);

/*
 * Set level of garbage collector noise. This might often be a bit irrelevant,
 * but
 *    0    no messages at all
 *    +1   messages whenever garbage collection happens
 *    +2   messages whenever a module of code is loaded
 *    +4   extra details in the garbage collector messages
 * Note that if an ALWAYS_NOISY option (probably set as a side effect
 * of the debugging command line option "-g") is in play then any
 * call here has +1 and +2 forced active.
 */

extern int PROC_gc_messages(int n);

/*
 *    stack = nil;
 */
extern int PROC_clear_stack();

/*
 *    stack = name . stack;
 */

extern int PROC_push_symbol(char *name);

/*
 *    stack = the-string . stack;
 */

extern int PROC_push_string(char *data);

/*
 *    stack = n . stack;
 * Small integers may be up to 28-bits of (signed) data, while
 * big integers can be almost any size and are denoted here by strings.
 * Eg:  PROC_push_small_integer(134217727);    largest positive small num
 *      PROC_push_small_integer(-134217728);   extreme negative case 
 *      PROC_push_big_integer("-12345678901234567890");
 */

extern int PROC_push_small_integer(int n);

extern int PROC_push_big_integer(char *n);

extern int PROC_push_floating(double n);

/*
 * Takes n items from the top of the stack and uses them as arguments
 * for a function as specified by the name. Leaves the result on the
 * top of the stack. Arguments will have been pushed with arg1 pushed
 * first and the last argument pushed last.
 */

extern int PROC_make_function_call(char *name, int n);

/*
 * Save whatever is on top of the stack in memory location n. At present
 * I provide 100 memory locations, whihc ar enumbered 0 to 99.
 */

extern int PROC_save(int n);

/*
 * Push the contents of memory location n onto the stack.
 */

extern int PROC_load(int n);

/*
 * Duplicate the top stack element.
 */

extern int PROC_dup();

/*
 * Discard the top stack element.
 */

extern int PROC_pop();

/*
 * The top item on the stack is replaced with what happens when Reduce
 * is asked to "simplify" or "evaluate" it. The result can then be stored
 * or combined with other items, but it will not in general be in a format
 * directly convenient for use by humans.
 */

extern int PROC_simplify();

/*
 * Replace the top item on the stack with a version of the same expression
 * in a reasonably simple prefix notation.
 * This representation is NOT intended for re-input to any calculation -
 * it is only intended for inspecial by the client code that is using Reduce
 * via this interface. To that end it may in the future return big integers
 * in a form where they have been converted to Lisp strings and may make
 * other transformations that would hurt attempts to re-use the expression.
 */

extern int PROC_make_printable();

/*
 * Return a handle to the top item on the stack, and pop the stack. This
 * will normally be called immediately after a call to PROC_make_printable.
 * the stack is popped because I view the "printable" version as unsuitable
 * for further use.
 */

extern void* PROC_get_value();

/*
 * The next few functions are predicates that may be applied to handles.
 * An "atom" is any non-composite form. A fixnum is a small integer, and
 * a symbol is a name.
 */

extern int PROC_atom(void* p);
extern int PROC_null(void* p);
extern int PROC_fixnum(void* p);
extern int PROC_floatnum(void* p);
extern int PROC_string(void* p);
extern int PROC_symbol(void* p);

/*
 * If something is not an atom it will be a list, and the following two
 * functions return the components of it. In general non-atomic items will
 * be structured as
 *     (fname arg1 arg2 ...)
 * with "well understood" function names "plus", "difference", "minus",
 * "times", "quotient", "expt" being used to denote use of the main
 * arithmetic connectives. A Lisp fanatic would have named the following
 * two functions PROC_car and PROC_cdr!
 */

extern void* PROC_first(void* p);
extern void* PROC_rest(void* p);

/*
 * If something is an atom then these make it possible to extract details
 * of what it represents. In due course I may support floating point values
 * and big numbers, but release 1 of those code concentrates on the basics.
 */

extern int PROC_integer_value(void* p);
extern double PROC_floating_value(void* p);
extern char *PROC_symbol_name(void* p);
extern char *PROC_string_data(void* p);

/*
 * I also provide some calls that support a sort of ultimate cop-out in
 * that they maye it possible to call Lisp code directly rather than
 * just invoking the Reduce simplifier. They also allow one to get back a
 * raw Lisp result which will have had gensym-names solidified but which
 * is otherwise unaltered. Note that the way this is achieved means that
 * things will FAIL if the Lisp result were to be a cyclic structure!
 */


/*
 * Replace the top item on the stack with whatever is obtained by using
 * the Lisp EVAL operation on it. Note that this is not intended for
 * casual use - if there is any functionality that you need PLEASE ask
 * me to put in a cleaner abstraction to support it.
 */

extern int PROC_lisp_eval();

/*
 * Return a handle to the top item on the stack, and pop the stack.
 * The value here will be a RAW LISP structure and NOT at all necessarily
 * anything neat.
 */

extern void* PROC_get_raw_value();

namespace;

/* High-level interface. *****************************************************/

/**************************************************************************
 * Copyright (C) 2012, Albert Graef <Dr.Graef@t-online.de>                *
 *                                                                        *
 * Redistribution and use in source and binary forms, with or without     *
 * modification, are permitted provided that the following conditions are *
 * met:                                                                   *
 *                                                                        *
 *     * Redistributions of source code must retain the relevant          *
 *       copyright notice, this list of conditions and the following      *
 *       disclaimer.                                                      *
 *     * Redistributions in binary form must reproduce the above          *
 *       copyright notice, this list of conditions and the following      *
 *       disclaimer in the documentation and/or other materials provided  *
 *       with the distribution.                                           *
 *                                                                        *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    *
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT      *
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS      *
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE         *
 * COPYRIGHT OWNERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,   *
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,   *
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS  *
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND *
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR  *
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF     *
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
 * DAMAGE.                                                                *
 *************************************************************************/

/* ..

   High-Level Interface to REDUCE
   ==============================

   The goal here is to make it easy to run REDUCE from Pure; to these ends,
   the most important features of the low-level PROC interface are wrapped in
   a convenient way. Currently the following functions are provided:

   .. function:: reduce::init image::string args::smatrix

      Initializes the REDUCE system. You need to specify the name of the
      REDUCE image file and any desired extra arguments as a string vector.
      This needs to be called once before doing anything else.

   .. function:: reduce::verbosity n

      Sets the verbosity level; 0 means no messages at all, and the following
      values may be or'ed together to pick what you need:

        1   messages whenever garbage collection happens
	2   messages whenever a module of code is loaded
	4   extra details in the garbage collector messages

   .. function:: reduce::load name::string

      Loads REDUCE packages. Please check the REDUCE documentation for
      details.

   .. function:: reduce::switch name:string val::int

      Lets you change global REDUCE options. Please check the REDUCE
      documentation for details.

   .. function:: simplify x

      This is the main entry point. Note that this is in the default namespace
      for convenience. It takes a REDUCE expression in Pure format and tries
      to simplify it using REDUCE. The result is then converted back to Pure
      format.

   In Pure land, REDUCE expressions are represented using standard curried
   notation; some special conversions are applied to make arithmetic
   operations such as +, * etc. work as expected. For convenience, the REDUCE
   terms ``arbint n`` and ``arbcomplex n`` are converted from/to Greek symbols
   ``αn`` and ``ζn``. (All these automatic conversions can also be turned off
   on the output side by disabling the ``mapped`` compilation option; this may
   be useful for debugging purposes.)

   See reduce_examp.pure for some basic examples. */

namespace reduce with

// These are repeated here to give them shorter names.

extern int PROC_load_package(char *name) = load;
extern int PROC_set_switch(char *name, int val) = switch;
extern int PROC_gc_messages(int n) = verbosity;

// Initialization: run this once before anything else.

init image::string args::smatrix =
  cslstart (#args+3) {"reduce","-i",image,args} NULL;

// Some special symbol lists, defined below.

public variadic_syms nonvariadic_syms reduce_syms pure_syms;

end;

// The following stuff is in the global namespace for convenience.
using namespace reduce;

// Some REDUCE symbols. On the Pure side, you can use either these or their
// Pure counterparts in the symbol lists below. (NOTE: intg is actually a Pure
// replacement for REDUCE's int which is already used as a conversion function
// in Pure.)  XXXTODO: Complete this list.
public arbint arbcomplex;
public df intg solve equal plus difference minus times quotient expt;
nonfix _rd_ _gr_ _gi_ _rn_ _mod_;

// Variadic symbols in REDUCE which may take any number of arguments, together
// with their Pure counterparts. XXXTODO: Complete this list.
let reduce::variadic_syms =
  {plus=>(+),difference=>(-),times=>(*),min=>min,max=>max};

// Remaining (non-variadic) symbols with their Pure counterparts. Only symbols
// which need to be remapped on the Pure side need to be listed here. XXXTODO:
// Complete this list.
let reduce::nonvariadic_syms =
  {int=>intg,minus=>neg,quotient=>(/),expt=>(^),equal=>(==)};

// All remapped symbols (from above).
let reduce::reduce_syms = {variadic_syms, nonvariadic_syms};

// Reverse mapping (Pure -> REDUCE).
let reduce::pure_syms = {y=>x | x=>y = reduce_syms};

// Exception constructor. This gets thrown on inputs and outputs which
// 'simplify' doesn't understand (yet).
public bad_reduce_value;

/* Uncomment this to get unmapped output in nested list format straight from
   REDUCE (useful for debugging purposes). */
//#! --disable mapped
/* Uncomment this to disable quoting of applications in the output (provided
   that 'mapped' is also enabled, disabling this will force the evaluation of
   reducible Pure subterms in the output). */
//#! --disable quoted
/* Uncomment this to disable the conversion from arbint and arbcomplex to
   Greek symbols on the Pure side. */
//#! --disable arbsymbols

simplify x = y when
  // Clear the stack (to be sure).
  PROC_clear_stack;
  // Push x on the REDUCE stack.
  from_expr x with
    // These are all the data types natively supported by the interface.
    // XXXTODO: Does it make sense to pass other Pure data structures such as
    // lists, tuples, matrices, maybe through some appropriate REDUCE
    // functions?
    from_expr x::int = PROC_push_small_integer x;
    from_expr x::bigint = PROC_push_big_integer (init $ str x);
    from_expr x::double = PROC_push_floating x;
    from_expr x::string = PROC_push_string x;
    from_expr x::appl = () when
      f:xs = a [] x with a xs (x@_ y) = a (y:xs) x; a xs x = x:xs end;
      do from_expr xs;
      PROC_make_function_call (from_sym f) (#xs);
    end;
    from_expr x::symbol =
      case head s, val (tail s) when s = str x end of
	"α",n::int = from_expr (arbint n);
	"ζ",n::int = from_expr (arbcomplex n);
	_ = PROC_push_symbol (from_sym x);
      end;
    from_expr x = error x otherwise;
    // Convert symbols, with mapping as needed.
    from_sym x = str (catch (cst x) (pure_syms!x));
  end;
  // Run REDUCE to simplify the expression.
  PROC_simplify;
  // Convert the stacktop from the internal REDUCE format into a format which
  // we can use.
  PROC_make_printable;
  // Convert the stacktop back to a Pure expression.
  y = to_expr (display PROC_get_value) with
    display p = [] if PROC_null p;
    = if PROC_symbol p then symval (PROC_symbol_name p)
      else if PROC_fixnum p then PROC_integer_value p
      else if PROC_floatnum p then PROC_floating_value p
      else if PROC_string p then strval (PROC_string_data p)
      else error p if PROC_atom p;
    = display (PROC_first p):display (PROC_rest p) otherwise;
    // Bigints are also returned as strings. We handle that here.
    strval x::string = case val x of
      x::int  = bigint x;
      x::bigint = x;
      _ = x;
    end;
    symval x::string = case val x of
      x::symbol = x;
      // Some REDUCE symbols aren't valid Pure symbols. We mangle them here.
      _ = val (string (map mangle x)) with
	mangle c = c if c=="_" || c>="0" && c<="9" ||
		       c>="a" && c<="z" || c>="A" && c<="Z";
	mangle ":" = "_";
	mangle _ = "__" otherwise;
      end;
    end;
#! --if mapped
#! --if quoted
    // quote applications in the result, to prevent evaluation of reducible
    // Pure subterms in the result
    x$y = 'x y;
#! --endif
    // Empty list, treated as () right now. XXXFIXME: Is this sensible?
    to_expr [] = ();
    // Special coefficient values.
    to_expr (_rd_ : x::double) = x;
    to_expr (_rd_ : mant::integer : exp::integer) = mant*2^exp;
    to_expr (_gr_ : re::double : im::double) = re+:im;
    to_expr (_gr_ :
	     (rmant::integer : rexp::integer) :
	     (imant::integer : iexp::integer)) = rmant*2^rexp +: imant*2^iexp;
    to_expr (_gi_ : re::integer : im::integer) = re+:im;
    to_expr (_rn_ : num::integer : den::integer) = num%den;
    // XXXFIXME: Maybe it's better to not loose the _mod_ symbol here?
    to_expr (_mod_ : num::integer) = num;
#! --if arbsymbols
    to_expr x@[f::symbol,n::int] = to_sym x
      if f === arbint || f === arbcomplex;
#! --endif
    // List with a variadic symbol in front, map this to the appropriate Pure
    // term (e.g. (plus a b c) -> a+b+c etc.).
    to_expr (f::symbol:xs::rlist) = foldl1 (to_expr f$) (map to_expr xs)
      if member variadic_syms f;
    // Other list (no variadic symbol), mapped to a plain application.
    to_expr xs::rlist = foldl1 ($) (map to_expr xs) otherwise;
    // Symbols.
    to_expr x::symbol = to_sym x;
    // XXXTODO: Any other back conversions that we want to do here?
#! --endif
    // Anything else: leave as is right now.
    to_expr x = x otherwise;
    // Convert symbols, with reverse mapping as needed.
    to_sym [f::symbol,n::int] = val ("α"+str n) if f === arbint;
    to_sym [f::symbol,n::int] = val ("ζ"+str n) if f === arbcomplex;
    to_sym x = catch (cst x) (reduce_syms!x);
  end;
  // Clear the stack once again (clean up).
  PROC_clear_stack;
end with
  // Error handler, this gets invoked if we choke on an input or output x we
  // don't understand (yet).
  error x = PROC_clear_stack $$ throw (bad_reduce_value x);
end;
