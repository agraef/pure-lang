
/* A basic interface to the computer algebra system Reduce available at
   http://www.reduce-algebra.com/. CSL Interface Copyright (C) 2010 by Codemist
   Ltd., A C Norman (see license statement below), Pure adaption Copyright (C)
   2012 by Kurt Pagani and Albert Graef. */

using "lib:reduce" ;

/* Low-level interface. ******************************************************/

/* This is the low-level "procedural" Reduce interface (cf. csl/cslbase/proc.h
   in the Reduce sources at http://reduce-algebra.svn.sourceforge.net). We
   declare these routines in their own namespace in order to keep the global
   namespace clean. */

namespace reduce;

/**************************************************************************
 * Copyright (C) 2010, Codemist Ltd.                     A C Norman       *
 *                                                                        *
 * Redistribution and use in source and binary forms, with or without     *
 * modification, are permitted provided that the following conditions are *
 * met:                                                                   *
 *                                                                        *
 *     * Redistributions of source code must retain the relevant          *
 *       copyright notice, this list of conditions and the following      *
 *       disclaimer.                                                      *
 *     * Redistributions in binary form must reproduce the above          *
 *       copyright notice, this list of conditions and the following      *
 *       disclaimer in the documentation and/or other materials provided  *
 *       with the distribution.                                           *
 *                                                                        *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    *
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT      *
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS      *
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE         *
 * COPYRIGHT OWNERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,   *
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,   *
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS  *
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND *
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR  *
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF     *
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
 * DAMAGE.                                                                *
 *************************************************************************/

/* ..

   Low-Level Interface
   ===================

   The low-level interface is a straight wrapper of the C entry points
   provided by the Reduce library, also known as the "procedural" or PROC_
   interface, for short. It uses an embedded version of Reduce which runs on a
   free and open-source Lisp flavour known as CSL_ (Codemist Standard
   Lisp). The external C routines are all declared in the ``reduce``
   namespace. Normally you shouldn't have to call these functions directly,
   since we provide a high-level, idiomatic Pure interface which makes calling
   Reduce from Pure much easier, see below.

   .. _PROC: http://reduce-algebra.svn.sourceforge.net/viewvc/reduce-algebra/trunk/csl/cslbase/proc.h?view=markup
   .. _CSL: http://lisp.codemist.co.uk/

*/

//typedef int character_reader(void);
//typedef int character_writer(int);

/*
 * When a handle on an expression is returned to the user this is the
 * type it has. The type should be treated as opaque, please.
 */

//typedef void *PROC_handle;

/*
 * Before trying to do anything at all you must call cslstart. This will
 * allocate memory, load an initial heap image etc etc. The argc and argv
 * passed here are as per normal C startup. The key issue here is how
 * Reduce will find the file "reduce.img" that it needs to load. There are
 * two plausible ways you can achieve this.
 * (a) argv[0] should contain a (for choice) fully rooted path as in
 *     /usr/local/bin/reduce
 * or  c:\my-reduce\binaries\reduce.exe
 *     In that case the name of the supposed execitable has ".img" tagged
 *     onto it, so the image is expected to be at say /usr/local/bin/reduce.img
 *     If the application name is the name of a symbolic link then the
 *     image file is looked for in the dircetory that the link points to.
 * (b) You can put "-i" "/path/to/reduce.img" in two consecutive entries
 *     in argv to give an explicit indication of where the image file
 *     is to be found. This should override any attempt to look via
 *     argv[0].
 * Most users should not need to provide any further options, but options
 * are decoded just as for the ordinary version of the system.
 *
 * Any textual output generated during system-started is sent, character
 * by character, via the callback function. Eg pass an option "-v" in
 * argv and see a big banner.
 */

extern void cslstart(int argc, char **argv, int *wr);

/*
 * At the end of a run please call cslfinish to close down everything
 * in a reasonably orderly manner and release memory. I should cautiously
 * note that the system will have some memory leaks so cslfinish will
 * not return EVERYTHING that has been allocated - if this worries you
 * please search for and correct the defects. Again the callback function
 * is used to process any output generated during close-down.
 */

extern int cslfinish(int *wr);

/*
 * As a general-purpose escape it is possible to get a Lisp function
 * (with no arguments) called. This function does that re-binding
 * what would otherwise be terminal input and output to the two
 * callback functions. By writing your own custom Lisp function and then
 * calling it this way you get almost ultimate flexibility, if not
 * convenience! For used of the Reduce algebra system I hope that the
 * suite of more specialised functions listed later on will prove
 * easier to use.
 */

extern int execute_lisp_function(char *fname,int *r, int *w);


/*
 * The next collection of functions provide for interaction with the
 * Reduce algebra system using a model based on a Reverse Polish
 * Calculator. You use RPN-style calls to build a fragment of parse
 * tree and can them as Reduce to "simplify" it. Having simplified it
 * you can ask for a simple prefix-form of the result to be generated and
 * returned, and there are functions for traversing that.
 */

/*
 * Example:
 *  Task:   differentiate (x+1)^2 with respect to x
 *  Method: clear_stack();
 *          push_symbol("x");
 *          push_small_integer(1);
 *          make_function_call("plus",2);   function plus has 2 arguments.
 *          push_small_integer(2);
 *          make_function_call("expt",2);
 *          push_symbol("x");
 *          make_function_call("df",2);     "df" is for differentiate.
 *                                          To use this you need to learn
 *                                          the named Reduce uses for all
 *                                          relevant operations.
 *          simplify();                     up until now the form built
 *                                          has been just the prefix form
 *                                          (expt (plus x 1) 2).
 *          dup();                          because save will pop the stack
 *          save(1);                        save in "memory number 1".
 *          make_printable();               the simplified form is in
 *                                          a Reduce internal representation,
 *                                          so this restores it to simple
 *                                          prefix form.
 *          p = get_value();
 * now p holds a handle on the result, and it can be traversed
 * using functions atom(), first(), rest() and functions that extract the
 * name of a symbol or the value of an integer. You should assume that the
 * handle becomes invalid as soon as you call one of the other functions.
 * this is because they can all trigger garbage collection and that can
 * relocate data.
 * The functions used to build expressions all return zero on success or
 * an error-code otherwise. In the initial release the error-codes are
 * not documented other than via reading the source files. Furthermore the
 * consequence of a calculation seeking input or generating output is not
 * well sorted.
 */


/*
 * After having called cslstart() you can set the I/O callback functions
 * using this. If you set one or both to NULL this indicates use of
 * stdin/stdout as per usual rather than an callback, otherwise whenever
 * anybody wants to read or write they use these procedures. It is then
 * your responsibility to cope with whatever text gets exchanged!
 */

extern int PROC_set_callbacks(int *r, int *w);

/*
 * Load a Reduce "package".
 */

extern int PROC_load_package(char *name);

/*
 * Set of clear a Reduce switch. As on "on expandlogs;"
 * which you do via PROC_set_switch("expandlogs", 1);
 * Use 0 to switch something off and 1 to switch it on.
 */

extern int PROC_set_switch(char *name, int val);

/*
 * Set level of garbage collector noise. This might often be a bit irrelevant,
 * but
 *    0    no messages at all
 *    +1   messages whenever garbage collection happens
 *    +2   messages whenever a module of code is loaded
 *    +4   extra details in the garbage collector messages
 * Note that if an ALWAYS_NOISY option (probably set as a side effect
 * of the debugging command line option "-g") is in play then any
 * call here has +1 and +2 forced active.
 */

extern int PROC_gc_messages(int n);

/*
 *    stack = nil;
 */
extern int PROC_clear_stack();

/*
 *    stack = name . stack;
 */

extern int PROC_push_symbol(char *name);

/*
 *    stack = the-string . stack;
 */

extern int PROC_push_string(char *data);

/*
 *    stack = n . stack;
 * Small integers may be up to 28-bits of (signed) data, while
 * big integers can be almost any size and are denoted here by strings.
 * Eg:  PROC_push_small_integer(134217727);    largest positive small num
 *      PROC_push_small_integer(-134217728);   extreme negative case 
 *      PROC_push_big_integer("-12345678901234567890");
 */

extern int PROC_push_small_integer(int n);

extern int PROC_push_big_integer(char *n);

extern int PROC_push_floating(double n);

/*
 * Takes n items from the top of the stack and uses them as arguments
 * for a function as specified by the name. Leaves the result on the
 * top of the stack. Arguments will have been pushed with arg1 pushed
 * first and the last argument pushed last.
 */

extern int PROC_make_function_call(char *name, int n);

/*
 * Save whatever is on top of the stack in memory location n. At present
 * I provide 100 memory locations, whihc ar enumbered 0 to 99.
 */

extern int PROC_save(int n);

/*
 * Push the contents of memory location n onto the stack.
 */

extern int PROC_load(int n);

/*
 * Duplicate the top stack element.
 */

extern int PROC_dup();

/*
 * Discard the top stack element.
 */

extern int PROC_pop();

/*
 * The top item on the stack is replaced with what happens when Reduce
 * is asked to "simplify" or "evaluate" it. The result can then be stored
 * or combined with other items, but it will not in general be in a format
 * directly convenient for use by humans.
 */

extern int PROC_simplify();

/*
 * Replace the top item on the stack with a version of the same expression
 * in a reasonably simple prefix notation.
 * This representation is NOT intended for re-input to any calculation -
 * it is only intended for inspecial by the client code that is using Reduce
 * via this interface. To that end it may in the future return big integers
 * in a form where they have been converted to Lisp strings and may make
 * other transformations that would hurt attempts to re-use the expression.
 */

extern int PROC_make_printable();

/*
 * Return a handle to the top item on the stack, and pop the stack. This
 * will normally be called immediately after a call to PROC_make_printable.
 * the stack is popped because I view the "printable" version as unsuitable
 * for further use.
 */

extern void* PROC_get_value();

/*
 * The next few functions are predicates that may be applied to handles.
 * An "atom" is any non-composite form. A fixnum is a small integer, and
 * a symbol is a name.
 */

extern int PROC_atom(void* p);
extern int PROC_null(void* p);
extern int PROC_fixnum(void* p);
extern int PROC_floatnum(void* p);
extern int PROC_string(void* p);
extern int PROC_symbol(void* p);

/*
 * If something is not an atom it will be a list, and the following two
 * functions return the components of it. In general non-atomic items will
 * be structured as
 *     (fname arg1 arg2 ...)
 * with "well understood" function names "plus", "difference", "minus",
 * "times", "quotient", "expt" being used to denote use of the main
 * arithmetic connectives. A Lisp fanatic would have named the following
 * two functions PROC_car and PROC_cdr!
 */

extern void* PROC_first(void* p);
extern void* PROC_rest(void* p);

/*
 * If something is an atom then these make it possible to extract details
 * of what it represents. In due course I may support floating point values
 * and big numbers, but release 1 of those code concentrates on the basics.
 */

extern int PROC_integer_value(void* p);
extern double PROC_floating_value(void* p);
extern char *PROC_symbol_name(void* p);
//extern char *PROC_string_data(void* p);

/*
 * I also provide some calls that support a sort of ultimate cop-out in
 * that they maye it possible to call Lisp code directly rather than
 * just invoking the Reduce simplifier. They also allow one to get back a
 * raw Lisp result which will have had gensym-names solidified but which
 * is otherwise unaltered. Note that the way this is achieved means that
 * things will FAIL if the Lisp result were to be a cyclic structure!
 */


/*
 * Replace the top item on the stack with whatever is obtained by using
 * the Lisp EVAL operation on it. Note that this is not intended for
 * casual use - if there is any functionality that you need PLEASE ask
 * me to put in a cleaner abstraction to support it.
 */

extern int PROC_lisp_eval();

/*
 * Return a handle to the top item on the stack, and pop the stack.
 * The value here will be a RAW LISP structure and NOT at all necessarily
 * anything neat.
 */

extern void* PROC_get_raw_value();

/*****************************************************************************/

/* Our own addons and replacements, cf. proc-add.c. -ag */

extern int PROC_make_cons();
extern int PROC_capture_output(int flag);
extern char *PROC_get_output();
extern void PROC_clear_output();
extern int PROC_feed_input(char *s);
extern char *PROC_my_string_data(void* p) = PROC_string_data;
extern int PROC_checksym(char *s) = checksym;

namespace;

/* High-level interface. *****************************************************/

/**************************************************************************
 * Copyright (C) 2012, Albert Graef <Dr.Graef@t-online.de>                *
 *                                                                        *
 * Redistribution and use in source and binary forms, with or without     *
 * modification, are permitted provided that the following conditions are *
 * met:                                                                   *
 *                                                                        *
 *     * Redistributions of source code must retain the relevant          *
 *       copyright notice, this list of conditions and the following      *
 *       disclaimer.                                                      *
 *     * Redistributions in binary form must reproduce the above          *
 *       copyright notice, this list of conditions and the following      *
 *       disclaimer in the documentation and/or other materials provided  *
 *       with the distribution.                                           *
 *                                                                        *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    *
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT      *
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS      *
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE         *
 * COPYRIGHT OWNERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,   *
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,   *
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS  *
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND *
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR  *
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF     *
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
 * DAMAGE.                                                                *
 *************************************************************************/

/* ..

   High-Level Interface
   ====================

   The high-level interface provides a wrapper of the low-level PROC interface
   which makes calling Reduce from Pure easy and convenient. After installing
   the module, it can be imported in your Pure scripts as follows::

     using reduce;

   This starts up Reduce and makes the following variables and functions
   available in Pure:

   .. variable:: REDUCE_PATH

      This variable holds a colon-delimited search path used to locate the
      Reduce image file (see :func:`reduce::start` below). By default this
      includes the current directory and the Pure library directory.

   .. function:: reduce::start image::string args::smatrix

      Initializes the Reduce system. This is done automatically when loading
      this module, so normally you shouldn't have to call this manually,
      unless the default image file wasn't found or you want to restart the
      Reduce system with your own image file or your own set of options. When
      calling this operation manually, you need to specify the name of the
      Reduce image file and any desired extra arguments as a string vector.
      Unless the filename contains a slash, :func:`reduce::start` searches the
      directories in :var:`REDUCE_PATH` for the image file. An exception is
      raised if the image file isn't found.

   .. function:: reduce::finish

      Finalizes the Reduce system. You can call this to release the resources
      of the Reduce system. (:func:`reduce::start` also invokes this
      automatically if a Reduce instance is already running, so it isn't
      necessary to call :func:`reduce::finish` in this case.)

   .. function:: reduce::verbosity n

      Sets the verbosity level; 0 means no messages at all (which is the
      default when using this module), and the following values may be or'ed
      together to pick what you need:

        1: messages whenever garbage collection happens

        2: messages whenever a module of code is loaded

	4: extra details in the garbage collector messages

   .. function:: reduce::capture flag::int
                 reduce::output

      Captures output from Reduce. If ``flag`` is nonzero,
      :func:`reduce::capture` arranges for all output from Reduce to be
      buffered. The contents of the buffer can then be read using the
      :func:`reduce::output` function which returns a string value. If
      ``flag`` is zero, capturing is disabled so that output goes to stdout
      again.

   .. function:: reduce::feed s::string

      Feeds input to Reduce. Reduce will read input from the given string
      ``s``, switching back to stdin after ``s`` has been processed.

   .. function:: reduce::load name::string

      Loads Reduce packages. This works like Reduce's ``load_package``
      command; please check the Reduce documentation for details.

   .. function:: reduce::in name::string

      Sources the given Reduce (.red) file. This works like the Lisp ``in``
      function. Output is captured using :func:`reduce::capture`, see above.

   .. function:: reduce::switch name:string val::int

      Lets you change global Reduce options. This works like Reduce's ``on``
      and ``off`` declarations; please check the Reduce documentation for
      details.

   For convenience, the following operations are in the default namespace:

   .. function:: simplify x

      This is the main entry point. It takes an algebraic expression in Pure
      format and tries to simplify it using Reduce. The result is then
      converted back to Pure format. Note that you need to quote ``x`` if you
      want to prevent it from being evaluated on the Pure side.

   .. function:: lisp x

      This can be used to execute arbitrary Lisp code, which is sometimes
      necessary to perform special functions in the Reduce system. For
      convenience, free symbols are quoted automatically, and Pure lists are
      mapped to corresponding Lisp lists and vice versa. The result is always
      a Pure list or an atomic value. Note that you need to quote ``x`` if you
      want to prevent it from being evaluated on the Pure side. This is to be
      used with care. An orderly exception is raised if you try to execute a
      non-existing Lisp function. But there are some internal functions in
      Reduce which aren't very forgiving if you try to execute them with
      invalid arguments, and will most likely crash the Reduce system in such
      cases. You have been warned!

   .. function:: lispsym s::string

      This function creates a special Pure identifier for any symbol given as
      a string, even symbols which don't conform to Pure syntax. This is
      sometimes needed to specify special Lisp symbols in calls to
      :func:`lisp`, such as ``lisp (lispsym "oem-supervisor")``. (Note that if
      such a special symbol occurs as a literal in a result returned by
      :func:`lisp` or :func:`simplify` then it will get mangled into a form
      which conforms to Pure syntax.)

   .. function:: declare declsym [foo,bar,...]

      Declare symbols and their properties; please see the Declarations
      section in the Reduce manual for details. The second argument can also
      be a singleton symbol. In the present implementation, ``declsym`` must
      be one of:

      * ``operator`` (declares an operator symbol);

      * ``antisymmetric``, ``symmetric``, ``even``, ``odd``, ``linear``,
        ``noncom`` and ``nonzero`` (declares properties of already declared
        operator symbols);

      * ``depend``, ``nodepend``, ``factor``, ``remfac``, ``order``,
        ``korder`` (declares kernel dependencies and orders). These take both
        symbols and "kernels" as arguments (the latter are simple prefix
        expressions which denote irreducible subterms such as ``cos x``;
        Reduce treats these more or less like variables in algebraic
        simplifications).

   .. function:: precision prec::int

      Sets the internal Reduce precision in decimal digits for floating point
      calculations, and returns the previously set precision. This takes
      effect when rounded mode is enabled (``reduce::switch "rounded" 1``).
      Note that at present this only affects Reduce's internal precision,
      floating point values are still returned as double precision numbers in
      Pure land.

   .. function:: plotreset

      This is identical to the ``plotreset`` command provided by Reduce's
      gnuplot_ interface, and is sometimes needed to reset the plot subsystem.

   .. _gnuplot: http://www.gnuplot.info/

   In Pure land, Reduce and Lisp expressions are represented using Pure's
   standard curried notation. Marshalling of numeric data works in a
   straightforward fashion and includes all natively supported Pure data types
   (machine ints, bigints, doubles, rationals and complex numbers). Some
   special conversions are applied to algebraic expressions to make arithmetic
   operations such as ``+``, ``*`` etc. work as expected. In addition, the
   ``==``, ``=>``, ``..`` and ``:=`` infix operators can be used to denote
   equations, replacement rules, ranges and assignments in Reduce,
   respectively. (Note that you may have to quote these in some cases so that
   they don't get evaluated on the Pure side.) Also, Reduce's ``arbconst n``,
   ``arbint n`` and ``arbcomplex n`` terms are mapped to Greek symbols ``αn``,
   ``βn`` and ``ζn`` on the Pure side. For debugging purposes, all these
   automatic conversions can also be turned off on the output side with the
   '``#!  --disable mapped``' compilation pragma; this needs to be placed
   *before* the '``using reduce;``' import clause to take effect. There are a
   number of other conditional compilation options which may be used to
   selectively turn off some of the conversions; please check the module
   source for details. */

// Search path for the Reduce image file. Edit as needed.
let REDUCE_PATH = ".:/usr/lib/pure";

/* Exception constructors. The bad_reduce_image and bad_reduce_file exceptions
   get thrown when reduce::start fails because it cannot find the Reduce image
   file, or if you try to open a non-existing Reduce source file, respectively.
   The other exceptions are raised on inputs and outputs which 'simplify' and
   'lisp' don't understand (yet). */
public bad_reduce_image bad_reduce_file bad_reduce_value bad_lisp_value;

public lisp;

namespace reduce with

public get_started;
let started = ref false;

load name::string = PROC_load_package name if get_started;
switch name::string val::int = PROC_set_switch name val if get_started;
verbosity n::int = PROC_gc_messages n if get_started;

namespace __C with
// We declare these here so that we don't have to pull in the system module.
extern int fclose(FILE*);
extern FILE* fopen(char*, char*);
extern int puts(char*);
// These are in the runtime; used for lispsym below.
extern int pure_sym(void *s);
extern expr *pure_quoted_symbol(int tag);
end;

using namespace __C;

// Perform a search for the image file.
search image::string = () if null image;
= catch id (if index image "/" > 0 then check ()
	    else do check (split ":" REDUCE_PATH)) with
  abspath name = null name || any (==image!0) [".","/"];
  check dir = () when
    image = if null dir then image else join "/" [dir,image];
    fp = fopen image "r";
    null fp || (fclose fp $$ throw image);
  end;
end;

// Initialization and finalization.

finish = put started false $$ cslfinish NULL $$ () if get started;

start image::string args::smatrix = res when
  // Nuke any running instance.
  finish;
  // Look for the image and load it.
  myimage = search image;
  stringp myimage || throw (bad_reduce_image image);
  all (~="-v") args || puts $ "Loading image file "+myimage;
  res = cslstart (#args+3) {"reduce","-i",myimage,args} NULL;
  // Record that we're up and running.
  put started true;
  // Reduce is pretty noisy by default, shut it up. You might want to comment
  // this line for debugging purposes, or call reduce::verbosity yourself.
  verbosity 0;
  // We need this to get matrices working, so always load this module.
  load "matrix";
end if all stringp args;

// Automatic startup. Print an error message if we can't find the image.
get_started = true if get started;
get_started = catch (\_->puts "** Couldn't load image file reduce.img")
  (reduce::start "reduce.img" {}) $$ get started;

// Capture output from Reduce in a string buffer.
capture flag::int = PROC_capture_output flag;
output = PROC_get_output;

// Feed input to Reduce from a string buffer.
feed s::string = PROC_feed_input s;

// Source a Reduce (.red) file. This captures all output, so you may want to
// inspect reduce::output for messages while loading the file.
in name::string = res when
  // 'in' crashes if we try to execute it on a non-existing file, so check for
  // that here. Note that you'll still get in trouble if you try to source
  // invalid Reduce code, so don't!
  fp = fopen name "r";
  ~null fp || throw (bad_reduce_file name);
  fclose fp;
  capture 1; res = lisp ('::in [name]); capture 0;
end;

// Some special symbol lists, defined below.

public variadic_syms nonvariadic_syms reduce_syms pure_syms prop_syms kdec_syms;

// Helper function to return a printable representation for a function
// symbol. This works like 'str', but strips the parens from symbols which are
// actually operators.

opstr x::symbol = tail (init (str x)) if arity x > 0;
opstr x = str x otherwise;

// Helper function to check if a symbol is defined as a function on the
// Lisp/Reduce side.

lispfunp x::symbol = checksym (opstr x);
lispfunp _ = false otherwise;

// Helper function to simplify arithmetic expressions. This basically expands
// an arithmetic term to a sum-of-products form. It is used to evaluate
// unexpanded SQ forms below, but may be useful in its own right.

expand = reduce with
  // associtivity
  a+(b+c) = (a+b)+c; a*(b*c) = (a*b)*c;
  // distributivity
  (a+b)*c = a*c+b*c; a*(b+c) = a*b+a*c;
  // move unary minus outward
  (-a)*b = -(a*b); a*(-b) = -(a*b);
  // handle numeric coefficients (simplify trivial cases and move them to the
  // front)
  a+b::number | b::number+a = a if b==0;
  a*b::number | b::number*a = 0 if b==0;
  a*b::number | b::number*a = a if b==1;
  a*b::number = b*a if ~numberp a;
  a::real*b = -((-a)*b) if a<0;
end;

// Another little helper function to further simplify sums by reducing a+-b ->
// a-b.

pretty = reduce with
  a+-b = a-b; a+b::real = a-(-b) if b<0;
end;

end;

// The following stuff is mostly in the global namespace for convenience.
using namespace reduce;

// Some Reduce symbols. On the Pure side, you can use either these or their
// Pure counterparts in the symbol lists below. XXXTODO: Complete this list.
// NOTES: intg is actually a Pure replacement for Reduce's int which is
// already used as a conversion function in Pure. The ':=' operator is used to
// denote assignment. Reduce's 'infinity' symbol is synonymous to Pure's 'inf'.
infix (=>) := ;
public t infinity;
public arbconst arbint arbcomplex;
public list mat det mateigen tp trace cofactor rank;
public df intg limit solve odesolve sum prod;
public set equal replaceby plus difference minus times quotient expt;
// mathematical functions known to Reduce
public acos acosh acot acoth acsc acsch asec asech asin asinh
  atan atanh atan2 cos cosh cot coth csc csch dilog ei exp
  hypot ln log logb log10 sec sech sin sinh sqrt tan tanh erf;
public factorize remainder resultant decompose nextprime pf deg coeff coeffn
  mainvar part lcof lpower lterm reduct sub showrules;
public taylor implicit_taylor inverse_taylor;
public laplace_transform hankel_transform y_transform k_transform
  struveh_transform fourier_sin fourier_cos;
// gnuplot related
public plot plotreset point points refine xlabel ylabel zlabel title
  terminal output size view contour nocontour surface nosurface hidden3d;
// freeof can be used in algebraic mode ('simplify'), the others are Lisp
// predicates (to be used with 'lisp')
public freeof evenp fixp ordp primep;
// other symbols useful in declarations ('lisp')
public flag operator prop;
public even odd linear symmetric antisymmetric nonzero;
public depend nodepend factor remfac korder order noncom;
public precedence precision integer real scalar scientific_notation share
  tr untr varname;

nonfix _sq _rd_ _gr_ _gi_ _rn_ _mod_;

// A little helper function which lets us create *any* symbol in Pure.
lispsym x::string = __C::pure_quoted_symbol (__C::pure_sym x);

// Variadic symbols in Reduce which may take any number of arguments, together
// with their Pure counterparts. NOTE: list and mat don't need to be listed
// here since they're given special treatment anyway.
// XXXTODO: Complete this list.
let reduce::variadic_syms =
  '{plus=>(+),difference=>(-),times=>(*),min=>min,max=>max};

// Remaining (non-variadic) symbols with their Pure counterparts. Only symbols
// which need to be remapped on the Pure side need to be listed here.
// XXXTODO: Complete this list.
let reduce::nonvariadic_syms =
  '{infinity=>inf,int=>intg,minus=>neg,quotient=>(/),expt=>(^),
    equal=>(==),replaceby=>(=>),set=>(:=),_interval_=>(..),_map=>map} when
      _interval_ = lispsym "*interval*";
      _map = lispsym "~map";
    end;

// All remapped symbols (from above).
let reduce::reduce_syms = {variadic_syms, nonvariadic_syms};

// Reverse mapping (Pure -> Reduce).
let reduce::pure_syms = {y=>x | x=>y = reduce_syms};

// Property symbols.
let reduce::prop_syms =
  '[antisymmetric,symmetric,even,odd,linear,nonzero];

// Symbols used in kernel declarations such as depend, korder etc.
let reduce::kdec_syms = '[depend,nodepend,factor,remfac,order,korder,noncom];

/* Uncomment this to get unmapped output in nested list format straight from
   Reduce (useful for debugging purposes). */
//#! --disable mapped
/* Uncomment this to disable quoting of applications in the output (provided
   that 'mapped' is also enabled, disabling this will force the evaluation of
   reducible Pure subterms in the output). */
//#! --disable quoted
/* Uncomment this to disable the conversion from arbconst et al to Greek
   symbols on the Pure side. */
//#! --disable arbsymbols
/* Uncomment this to disable the automatic conversion of Taylor polynomials to
   standard form. */
//#! --disable taylorsf

simplify x = y when
  // Clear the stack (to be sure).
  PROC_clear_stack;
  // Push x on the Reduce stack. XXXFIXME: We currently wrap this in an extra
  // 'list' application which gives us the result as a singleton list and
  // avoids Reduce errors in cases where the result is non-scalar. This is a
  // temporary workaround until we figure out how to do this properly.
  from_expr ('list x) with
    // These are all the data types natively supported by the interface.
    // Marshalling of list and matrix values is supported as well.
    from_expr x::int = PROC_push_small_integer x;
    from_expr x::bigint = PROC_push_big_integer (init (str x));
    from_expr x::double = from_expr (if x<0 then '-infinity else 'infinity)
      if infp x;
    = PROC_push_floating x otherwise;
    from_expr x::string = PROC_push_string x;
    from_expr x::matrix = from_expr (foldl ($) ('mat) (list2 x));
    from_expr x::rlist = from_expr (foldl ($) ('list) x);
    // Map x%y -> x/y on the fly.
    from_expr (x%y) = from_expr ('quotient x y);
    // Map complex numbers.
    from_expr (x+:y) = from_expr ('(x+i*y));
    from_expr (x<:y) = from_expr ('(x*e^(i*y)));
    from_expr x::appl = () when
      f:xs = a [] x with a xs (x@_ y) = a (y:xs) x; a xs x = x:xs end;
      case 'f () of
	// The mat case needs special treatment here, since we have to eval
	// the embedded list terms. XXXTODO: Are there other cases like this?
	mat _ =
	  do (\x -> if ~listp x then from_expr x
		    else from_expr (mkquoted x) $$ PROC_lisp_eval) xs
	with
	  // We allow a list to be specified either as a plain Pure list or a
	  // Lisp-style (list ...) term.
	  listp x::rlist = true;
	  listp (x@_ y) = listp x;
	  listp x = symbolp x && x==='list otherwise;
	  // Kludge: We need to quote the elements of the list arguments here
	  // in case they're symbolic, so that PROC_lisp_eval doesn't try to
	  // evaluate them (which crashes PROC_lisp_eval).
	  mkquoted x::rlist = map ('quote) x;
	  mkquoted (x@_ y) = 'x y when x = mkquoted x; y = 'quote y end;
	  mkquoted x = x;
	end;
        _::symbol _ = do from_expr xs;
	_ = error x;
      end;
      PROC_make_function_call (from_sym f) (#xs);
#! --if taylorsf
      // Special treatment for Taylor polynomials. We convert these to
      // standard form on the fly by inserting a call to taylortostandard.
      all (~==f) ('[taylor,implicit_taylor,inverse_taylor]) ||
      (load "taylor" $$ PROC_make_function_call "taylortostandard" 1);
#! --endif
    end;
    // Handle special cases of nullary symbols which are actually
    // parameterless function calls. XXXTODO: Are there other cases like this?
    // Note that the case of an empty matrix (mat) isn't really handled by
    // Reduce (it gives a 'Matrix mismatch' error), but we allow this case
    // anyway for consistency.
    from_expr x::symbol =
      PROC_make_function_call (from_sym x) 0 if x === 'list || x === 'mat;
    = case head s, val (tail s) when s = str x end of
	"α",n::int = from_expr (arbconst n);
	"β",n::int = from_expr (arbint n);
	"ζ",n::int = from_expr (arbcomplex n);
	_ = PROC_push_symbol (from_sym x);
      end;
    from_expr x = error x otherwise;
    // Convert symbols, with mapping as needed.
    from_sym x = opstr (catch (cst x) (pure_syms!x));
  end;
  // Run Reduce to simplify the expression.
  PROC_simplify;
  // Convert the stacktop from the internal Reduce format into a format which
  // we can use. NOTE: Apparently this isn't really needed with the toplevel
  // call to 'list', but we keep it in here just in case.
  PROC_make_printable;
  // Convert the stacktop back to a Pure expression.
#! --if mapped
  [y] = to_expr (display PROC_get_value) with
#! --else
  [list,y] = to_expr (display PROC_get_value) with
#! --endif
    display p = [] if PROC_null p;
    = if PROC_symbol p then symval (PROC_symbol_name p)
      else if PROC_fixnum p then PROC_integer_value p
      else if PROC_floatnum p then PROC_floating_value p
      else if PROC_string p then strval (PROC_string_data p)
      else error p if PROC_atom p;
    = display (PROC_first p):display (PROC_rest p) otherwise;
    // Bigints are also returned as strings. We handle that here.
    strval x::string = case val x of
      x::int  = bigint x;
      x::bigint = x;
      _ = x;
    end;
    symval x::string = case val ("("+x+")") of
      x::symbol = x;
      // Some Reduce symbols aren't valid Pure symbols. We mangle them here.
      _ = case val (string (map mangle x)) of
	// If the result still isn't a valid Pure symbol then it's probably a
	// keyword. Mangle it some more.
	val x::string = val ("_"+x);
	x::symbol = x;
	_ = error x;
      end with
	mangle c = c if c=="_" || c>="0" && c<="9" ||
		       c>="a" && c<="z" || c>="A" && c<="Z";
	mangle _ = "_" otherwise;
      end;
    end;
#! --if mapped
#! --if quoted
    // quote applications in the result, to prevent evaluation of reducible
    // Pure subterms in the result
    x$y = 'x y;
#! --endif
    // Empty list, treated as 'false' right now. (Note that proper Reduce
    // lists are handled below.) XXXFIXME: Is this sensible?
    to_expr [] = false;
    // Special coefficient values.
    to_expr (_rd_ : x::double) = x;
    to_expr (_rd_ : mant::integer : exp::integer) = mant*2^exp;
    to_expr (_gr_ : re::double : im::double) = re+:im;
    to_expr (_gr_ :
	     (rmant::integer : rexp::integer) :
	     (imant::integer : iexp::integer)) = rmant*2^rexp +: imant*2^iexp;
    to_expr (_gi_ : re::integer : im::integer) = re+:im;
    to_expr (_rn_ : num::integer : den::integer) = num%den;
    // XXXFIXME: Maybe it's better to not loose the _mod_ symbol here?
    to_expr (_mod_ : num::integer) = num;
#! --if arbsymbols
    to_expr x@[f::symbol,n::int] = to_sym x
      if f === arbconst || f === arbint || f === arbcomplex;
#! --endif
    // Lists are represented with the list symbol in front.
    to_expr (f::symbol:xs::rlist) = map to_expr xs if f === 'list;
    to_expr f::symbol = [] if f === 'list;
    // Matrices generally take the form (mat xs ...) in Reduce's internal
    // representation, where each xs is a row of the matrix represented as a
    // list.
    to_expr (f::symbol:xs::rlist) = matrix (map to_exprs xs) with
      to_exprs (x:xs) = to_expr x : to_exprs xs;
      // Empty list.
      to_exprs [] = [];
      // Not a list. This is presumably a singleton coefficient(?).
      to_exprs x = [to_expr x];
    end if f === 'mat;
    to_expr f::symbol = {} if f === 'mat;
    // List with a variadic symbol in front, map this to the appropriate Pure
    // term (e.g. (plus a b c) -> a+b+c etc.).
    to_expr (f::symbol:xs::rlist) =
      pretty (foldl1 (to_expr f$) (map to_expr xs)) if member variadic_syms f;
    // Other list (with a non-variadic symbol in front). Here we also deal
    // with the case of unevaluated embedded SQ terms (Reduce's internal
    // representation of algebraic terms, cf. Section 3 of the "REDUCE
    // Symbolic Mode Primer").
    to_expr xs@(f::symbol:_::rlist) = case xs of
      // SQ forms. Note that we always assume that t is actually 't' here,
      // denoting a valid SQ form, so that we don't have to reevaluate it
      // (cf. Section 3.2 of the "REDUCE Symbolic Mode Primer").
      [_sq,p:q,t] = if numberp q && q==1 then p else '(p/q) when
	p = expandsf p; q = expandsf q;
      end;
      // Anything else is presumably a value in prefix form, map to a Pure
      // application.
      _ = foldl1 ($) (map to_expr xs);
    end with
      // This expands a Reduce standard form (SF) representation of an
      // algebraic term to the human-readable prefix form. Cf. Section 4 of
      // the "REDUCE Symbolic Mode Primer".
      expandsf x = pretty (expand (expandsf x)) with
	evalsf mvar ldeg lc red = x when
	  // XXXFIXME: It seems that mvar may itself be an SF in some cases,
	  // but according to the manual it should just be a plain kernel?
	  x = expandsf mvar;
	  x = if ldeg==0 then 1 else if ldeg==1 then x else x^ldeg;
	  y = expandsf lc;
	  x = if ~numberp y then x*y else if y==0 then 0
				     else if y==1 then x else y*x;
	  y = expandsf red;
	  x = if ~numberp y || y~=0 then x+y else x;
	end;
	expandsf (((mvar:ldeg::int):lc):red) = evalsf mvar ldeg lc red;
	// At least some of these abbreviated forms also seem to occur.
	expandsf ((mvar:ldeg::int):lc) = evalsf mvar ldeg lc 0;
	expandsf (mvar:ldeg::int) = evalsf mvar ldeg 1 0;
	expandsf [] = 0;
	expandsf mvar = to_expr mvar;
      end;
    end;
    // Symbols.
    to_expr x::symbol = to_sym x;
    // XXXTODO: Any other back conversions that we want to do here?
#! --endif
    // Anything else: leave as is right now.
    to_expr x = x otherwise;
    // Convert symbols, with reverse mapping as needed.
    to_sym [f::symbol,n::int] = val ("α"+str n) if f === arbconst;
    to_sym [f::symbol,n::int] = val ("β"+str n) if f === arbint;
    to_sym [f::symbol,n::int] = val ("ζ"+str n) if f === arbcomplex;
    to_sym x::symbol = true if x === 't;
    to_sym x = catch (cst x) (reduce_syms!x);
  end;
  // Clear the stack once again (clean up).
  PROC_clear_stack;
end with
  // Error handler, this gets invoked if we choke on an input or output x we
  // don't understand (yet).
  error x = PROC_clear_stack $$ throw (bad_reduce_value x);
end if get_started;

// If the argument is neither an application nor a symbol, then it's
// presumably a literal which is simply echoed as is.
lisp x = x if ~applp x && ~symbolp x;
lisp x = y when
  // Clear the stack (to be sure).
  PROC_clear_stack;
  // Push x on the Reduce stack.
  from_expr false x with
    // These are all the data types natively supported by the interface.
    // Marshalling of list values is supported as well.
    from_expr _ x::int = PROC_push_small_integer x;
    from_expr _ x::bigint = PROC_push_big_integer (init (str x));
    from_expr _ x::double = PROC_push_floating x;
    from_expr _ x::string = PROC_push_string x;
    from_expr q [] = from_expr q ('nil);
    from_expr q (x:y) = () when
      do (from_expr q) [x,y];
      if q then PROC_make_cons() else PROC_make_function_call "cons" 2;
    end;
    from_expr q x::appl = () when
      f:xs = a [] x with a xs (x@_ y) = a (y:xs) x; a xs x = x:xs end;
      q || lispfunp f || error x;
      case x of
	quote x = from_expr true x;
	_ = do (from_expr q) xs;
      end;
      PROC_make_function_call (opstr f) (#xs);
    end;
    // Handle special cases of symbols which are actually parameterless
    // function calls.
    from_expr q x::symbol =
      PROC_make_function_call (str x) 0 if ~q && lispfunp x;
    // Other symbols are auto-quoted here if necessary, so that PROC_lisp_eval
    // doesn't try to evaluate them.
    = () when
      PROC_push_symbol (opstr x);
      q || PROC_make_function_call "quote" 1;
    end;
    from_expr _ x = error x otherwise;
  end;
  // Invoke the Lisp evaluator.
  PROC_lisp_eval;
  // Convert the stacktop back to a Pure expression.
  y = display PROC_get_value with
    display p = [] if PROC_null p;
    = if PROC_symbol p then symval (PROC_symbol_name p)
      else if PROC_fixnum p then PROC_integer_value p
      else if PROC_floatnum p then PROC_floating_value p
      else if PROC_string p then strval (PROC_string_data p)
      else error p if PROC_atom p;
    = display (PROC_first p):display (PROC_rest p) otherwise;
    // Bigints are also returned as strings. We handle that here.
    strval x::string = case val x of
      x::int  = bigint x;
      x::bigint = x;
      _ = x;
    end;
    symval x::string = case val ("("+x+")") of
      x::symbol = x;
      // Some Lisp symbols aren't valid Pure symbols. We mangle them here.
      _ = case val (string (map mangle x)) of
	// If the result still isn't a valid Pure symbol then it's probably a
	// keyword. Mangle it some more.
	val x::string = val ("_"+x);
	x::symbol = x;
	_ = error x;
      end with
	mangle c = c if c=="_" || c>="0" && c<="9" ||
		       c>="a" && c<="z" || c>="A" && c<="Z";
	mangle _ = "_" otherwise;
      end;
    end;
  end;
  // Clear the stack once again (clean up).
  PROC_clear_stack;
end with
  // Error handler, this gets invoked if we choke on an input or output x we
  // don't understand (yet).
  error x = PROC_clear_stack $$ throw (bad_lisp_value x);
end if get_started;

declare x::symbol y::symbol = declare x [y];
declare x::symbol ys::rlist = lisp (x ys)
  if x === 'operator && all symbolp ys;
declare x::symbol ys::rlist = lisp (x (map mkquoted ys))
  with
    mkquoted y::appl = 'quote y;
    mkquoted y = y otherwise;
  end if any (x===) kdec_syms;
declare x::symbol ys::rlist = lisp ('flag ys x)
  if any (x===) prop_syms && all symbolp ys;

precision prec::int = lisp ('precision prec);
plotreset = lisp ('plotreset);

reduce::get_started;
