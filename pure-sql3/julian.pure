/* MARCH 27, 2010 - DRAFT FOR DISCUSSIN PURPOSES ONLY */

using system;
using "lib:julianutil";
using math;

namespace julian;

/* julian.pure - functions for dealing with Julian dates */

/* The algorithms used in this module reflect the Gregorian proleptic
   calendar (i.e., the Gregorian calendar extended to cover dates
   before its introduction in 1582.) When expressing Gregorian dates
   as yyyy-mm-dd, astronomical year numbering is used, thus 1 BC is 0,
   2 BC is −1, and 4714 BC is −4713. The months (mm) and days (dd)
   start with 1.
  
   These algorithms are based on algorithms in SQLite's date.c file
   which are implemented based on descriptions in the following text:
  
        Jean Meeus
        Astronomical Algorithms, 2nd Edition, 1998
        ISBM 0-943396-61-1
        Willmann-Bell, Inc
        Richmond, Virginia (USA)

   The date European countries adopted the Gregorian calendar varied
   by country. For the first adopters the last day of the Julian
   calendar was Thursday, 1582-10-4 and this was followed by the first
   day of the Gregorian calendar, Friday, 15 October 1582.  In
   Historians usually use the Julian calendar for dates prior to
   1582-10-15 and for some dates afterwards, depending on locale, as
   opposed to the Gregorian proleptic calendar.  Thus, depending on
   what calendar is being used to express dates before 1582-10-15, you
   will see different values for the same Julian date JD. For example:

   JD 0 for Julian proleptic calendar is noon -4713-01-01
   JD 0 for the Gregorian proleptic calendar is noon -4714-11-24
   JD 0 for these algorithms is noon -4713-11-24

   For dates after the adoption, the date components returned by these
   algoritms conform to the Gregorian calendar. For example:

   JD 2400000 for these algorithms is 1858-11-16 12:00:00.000
   JD 2400000 for the Gregorian calendar is noon 1858-11-16

   Please notice that Julian dates start at noon. Thus the JD for
   1858-11-16 00:00:00 is 2399999.5 (I.e., 2399999.5 days after JD 0,
   noon of -4713-11-24).

   One advantage of using the Gregorian proleptic calendar with
   astronomical year numbering is that if two julian dates differ by 1
   day their yyyy-mm-dd will differ by one day (as were are normally
   accustomed to) without a 13 day or one year gap. E.g., using the
   functions from this module one does not have to worry about the
   when the Gregorian calendar was adopted. For example:

   > let ad1 = greg_to_jd (1582, 10, 10);
   > let ad2 = greg_to_jd (1582, 10, 11);
   > ad2 -ad1;
   1.0

   In contrast, when confronted with 1582-10-10, the julian date
   converter at http://aa.usno.navy.mil/data/docs/JulianDate.php
   responds with: "The dates 5 through 14 October, 1582, do not exist
   in the Gregorian Calendar!". Furthermore, according to that site,
   the calendar dates for the following adjacent Julian dates reflect
   a 13 day gap.

   JD 2299159.50000: 1582-10-04
   JD 2299160.50000: 1582-10-15

   Please bear these factors in mind when using this module.
  
   See http://en.wikipedia.org/wiki/Julian_day for further information.*/

public 
jd_to_unixtime jd_to_greg jd_to_str
unixtime_to_jd greg_to_jd str_to_jd 
current_jd weekday begmonth endmonth;

private extern double ymd_to_jd(int Y, int M, int D);
private extern expr* jd_to_ymd(double jd);
private extern double ymdhms_to_jd(int Y, int M, int D,
               int hr, int mn, double sc);
private extern expr* jd_to_ymdhms(double jd);
private extern double l_ymd_to_jd(int Y, int M, int D);
private extern expr* l_jd_to_ymd(double jd);
private extern double l_ymdhms_to_jd(int Y, int M, int D,
               int hr, int mn, double sc);
private extern expr* l_jd_to_ymdhms(double jd);

extern double local_jd(double jd);
extern double local_offset(double jd);

private aux_str_to_jd scan_str;


/* Get current UTC time as JD, convert to and from unixtime (seconds
   since midnight January 1, 1970). */

extern double current_jd();
extern int jd_to_unixtime(double jd);
extern double unixtime_to_jd(int t);


/* Convert from "Gregorian tuples" of the form (Y,M,D[,h,m,s]) to JDs
   and back. */

greg_to_jd ("loc", Y::int, M::int, D::int, h::int, m::int, s::double) =
           l_ymdhms_to_jd Y M D h m s;
greg_to_jd ("loc", Y::int, M::int, D) = l_ymd_to_jd Y M D;
greg_to_jd (Y::int, M::int, D::int, h::int, m::int, s::double) =
           ymdhms_to_jd Y M D h m s;
greg_to_jd (Y::int, M::int, D) = ymd_to_jd Y M D;

jd_to_greg ("loc", jd,"long") = l_jd_to_ymdhms jd;
jd_to_greg ("loc",jd) = l_jd_to_ymd jd;
jd_to_greg (jd,"long") = jd_to_ymdhms jd;
jd_to_greg jd = jd_to_ymd jd;


/* Convert to and from strings of the form "YYYY-MM-DD[ hh:mm:ss.sss]"
   and back. */

str_to_jd ("loc", s::string) = aux_str_to_jd 1 s;
str_to_jd s::string = aux_str_to_jd 0 s;

jd_to_str ("loc",jd,"long") = 
   sprintf "%04d-%02d-%02d %02d:%02d:%06.3f" (l_jd_to_ymdhms jd);
jd_to_str ("loc",jd) = 
   sprintf "%04d-%02d-%02d" (l_jd_to_ymd jd);
jd_to_str (jd,"long") = 
   sprintf "%04d-%02d-%02d %02d:%02d:%06.3f" (jd_to_ymdhms jd);
jd_to_str jd = 
   sprintf "%04d-%02d-%02d" (jd_to_ymd jd);


/* Convenience functions */

weekday ("loc", jd::double) = ((int (ceil (local_jd jd))) + 1) mod 7;
weekday jd::double = ((int (ceil jd)) + 1) mod 7;

begmonth ("loc", jd::double) = l_ymdhms_to_jd y m 1 0 0 0.0
when y,m,d = jd_to_ymd (local_jd jd); end;

begmonth jd::double = ymdhms_to_jd y m 1 0 0 0.0
when y,m,d = jd_to_ymd jd; end;

endmonth ("loc", jd::double) = l_ymdhms_to_jd y (m+1) 0 0 0 0.0
when y,m,d = jd_to_ymd (local_jd jd); end;

endmonth jd::double = ymdhms_to_jd y (m+1) 0 0 0 0.0
when y,m,d = jd_to_ymd jd; end;


/* Helpers */

scan_str s::string = catch (cst ()) (scan_str_both s)
with
  scan_str_both s = catch (scan_str_short s) (scan_str_long s);
  scan_str_short s _ = if #s<=n then y,m,d else ()
  when
    y,m,d,n = sscanf s "%i-%u-%u%n";
  end;
  scan_str_long s =  if #s<=n then y,m,d,hr,mn,sc else throw 0
  when
    y,m,d,hr,mn,sc,n = sscanf s "%i-%u-%u%u:%u:%f%n";
  end;
end;

aux_str_to_jd locp s::string = res
when
  greg = scan_str s;
  null greg && throw julian_bad_string;
  res = if locp then greg_to_jd ("loc",greg) else greg_to_jd greg;
end;

