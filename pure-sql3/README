
DRAFT FOR DISCUSSION PURPOSES ONLY.
NOT COMPLETED, NOT CURRENT, NOT WORTH READING AT THIS POINT.

=========
Pure-Sql3
=========

This document describes Peter Summerland's Sqlite3_ module, named **Sql3**,
for the Pure_ programming language.

.. _Sqlite3: http://www.sqlite.org/
.. _Pure: http://pure-lang.googlecode.com

.. contents::
.. sectnum::

Introduction
============

SQLite is a software library that implements a self-contained,
serverless, zero-configuration, transactional SQL database engine. It
is small and fast, and is the most widely deployed SQL database engine
in the world. http://www.sqlite.org/mostdeployed.html The source code
for SQLite is in the public domain.

.. http://www.sqlite.org/


http://www.sqlite.org/whentouse.html

Like other database programs SQLite has its quirks and has some very
powerful features that cannot be accessed through the generic OBCD
interface.

Sql3 is a "transparent" wrapper around Sqlite3's C interface that is
designed to give the developer access to all of Sqlite3's features in
a way that is convenient for Pure programmers. It provides a handful
of convenience functions that make the C interface "core" functions
easier to use without impeading the users ability to tap into the rest
of the C interface directly.

Simple Example
--------------

Here is a simple example that opens a database file "abc.db" (creating
it if it does not exist), adds a table, populates the table and
queries it.

::

  pure-sql3$> pure -q
  > 

  > using sql3; using namespace sql3;

  > let dbp = open "readme.db";

  > exec dbp "create table if not exists RM (name text, age integer)";

  > exec dbp "delete from RM";

  > let sp1 = prep dbp "ci" "insert into RM values (?,?)";

  > exec sp1 ("Sam",20);
  > exec sp1 ("Fred",22);

  > let sp2 = prep dbp "ci:i" "select * from RM where age > ?";

  > exec sp2 18;
  [["Sam",20],["Fred",22]]

The Pure statements shown as examples are contained in readme.pure in
the pure-sql3 directory.

These basic functions, `open`, `prep`, `exec` wrap the core
functionality of Sqlite3 and in many cases are all you need to use it
effectively. 

More Examples
-------------

The examples subdirectory contains numerous examples that further
illustrate basic usage as well some of Sql3's more sophisticated
features. These include the ability to implement functions, in Pure,
that can appear in SQL statements, custom binding types and convenient
access to the "raw" SQLite3 C interface.

SQLite3 Documentation and Tools
-------------------------------

SQLite3's home page provides excellent documentation regarding its SQL
dialect as well as its C interface. In the rest of this document, it
is assumed the reader has some familiarity with SQLite3 and its C
interface, and has read `An Introduction To The SQLite C/C++
Interface`_.

.. _An Introduction To The SQLite C/C++ Interface: http://www.sqlite.org/cintro.html


The SQLite library includes a simple command-line utility named
sqlite3 (or sqlite3.exe on windows) that allows the user to manually
enter and execute SQL commands against an SQLite database. 

.. http://www.sqlite.org/sqlite.html

This tool is an invaluable aid when working with SQLite in general and
with Sql3 in the Pure interpreter in particular. Just fire up sqlite3
in a new termial and use it to observe changes to the database
generated by your REPL commands. For example, after entering the Pure
statements from the Simple Example above, you can start a new
terminal, cd to pure-sql3, type sqlite3 readme.db, and start examining
the database:
::

  pure-sql3$> sqlite3 readme.db
  SQLite version 3.6.16
  Enter ".help" for instructions
  Enter SQL statements terminated with a ";"

  sqlite> select * from RM;
  Sam|20
  Fred|22

Of course changes caused by SQL statements are reflected in queries
entered via the Pure interpreter and vis-a-versa. I.e., the Pure
interpreter and sqlite3 can "simultaneously" access the same database
file, which is very handy while developing a Pure program that uses
Sql3.

Copying
=======

Copyright (c) 2010 by Peter Summerland and Albert Graef, all rights
reserved. 

Sql3 is is free software: you can redistribute it and/or modify it
under the terms of the New BSD License, often referred to as the 3
clause BSD license. Please see the COPYING file for the actual
license.

Installation
============

You need to have Pure and SQLite3_ installed, obviously. Run ``make`` to
compile the module, and ``sudo make install`` to install it in the Pure
library directory.

Data Structure
==============

As far as the native SQLite C interface is concerned, the most
important "data structures" are pointers to the following encapsulated
SQLite objects.

  * Database connection object: sqlite3
  * Prepared statement object: sqlite3_stmt

``Sql3::open`` and `Sql3::prep`` return "sentry-guarded" pointers to
these objects referred to herein as ``db_ptr`` and ``stmt_ptr``,
respectively. 

A db_ptr or a stmt_ptr is, as far as SQLite is concerned, the same as
a raw pointer returned by sqlite3_open_v2 (sqlite3*) and
sqlite3_prepare_v2 (sqlite3_stmt*), the native interface functions
corresponding to sql3::open and sql3::prep. While this facility can be
powerful, and avoids a lot of redundant wrapping functions, it can
also be dangerous as is the case with any call to and external C
function.

Sql3 users have to be especially careful in this regard because USING
A DB_PTR OR A STMT_PTR IN CALLS TO CERTAIN NATIVE FUNCTIONS, INCLUDING
IN PARTICULAR SQLITE3_CLOSE, SQLITE_PREPARE AND SQLITE_FINALIZE, WILL
CORRUPT DATA HELD BY THE DB_PTR OR STMT_PTR.

The reason for this restriction is that Sql3 uses sentries to insure
that the resources associated with a db_ptr or a stmt_ptr are
automatically finalized by SQLite when they go out of scope. In
addition, the sentries carry internal information used by Sql3 for
other purposes. Accordingly, native SQLite functions that change the
state of a database connection or a prepared statement behind Sql3's
back can oftern result in undefined behavior. (See Advanced Usage,
Accessing the C Interface for more information.)

Basic Operations
================

The basic operations, the ones that are used 99 percent of the time,
are (a) opening and closing database connections and (b) preparing and
executing SQL statements.

Opening a Database Connection
-----------------------------

In Sql3 ``open filename`` provides a db_ptr that can be used access
specified SQLite database.

* ``open (file_path::string [,access_mode::int,custom_bindings]])``:
  opens a SQLite database file whose name is given by the file_path
  argument and returns a db_ptr for the database connection object
  created by SQlite. The access_mode is what one would expect
  ... readonly, create if not found, etc. plus some very sophisticated
  caching and threading options. The custom_bindings option allows the
  user to prepare statements associated with the returned db_ptr that
  have custom binding types.

If the filename is ":memory:", then a private, temporary in-memory database
is created for the connection. This in-memory database will vanish when the
database connection is closed. The basic access modes are:

* SQLITE_OPEN_READONLY - the database is opened in read-only mode. If the
  database does not already exist, an error is returned.

* SQLITE_OPEN_READWRITE - the database is opened for reading and writing if
  possible, or reading only if the file is write protected by the operating
  system. In either case the database must already exist, otherwise an
  error is returned.

* SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE - the database is opened for
  reading and writing, and is creates it if it does not already exist. This
  is the default value that is used if the flags argument is omitted.

* SQLITE_OPEN - an alias for SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE
  provided by Sql3.

These flags can be combined with SQLITE_OPEN_NOMUTEX SQLITE_OPEN_FULLMUTEX
SQLITE_OPEN_SHAREDCACHE SQLITE_OPEN_PRIVATECACHE to control SQLite's
threading and shared cache features. See ...

The optional ``custom_bindings`` argument allows the user to set up
customized binding and fetching behavior for prepared statements
associated with the returned db_ptr. See Advanced Usage, Custome
Binding Types.

Failure to Open a Database Connection
-------------------------------------

Open a piece of junk -- will suceed. Only when queried will get error.

Seems to be a bug in exec db. Misses the error code. Is this a step thing?
Need to check for error from step.

Even if SQlite cannot open the connection, it still returns a pointer
to a database connection object that must be closed. In this case,
``open`` closes the the connection object and throws an
exception. E.g.,::

  >  let dbp = open "abc.db"; db1;
  #<pointer 0x992dff8>

  > catch error (open ("_RM_zyx.db",SQLITE_OPEN_READONLY));
  error "sqlite3 error 14: unable to open database file [open abcx.db]"


Testing a db_ptr
----------------

* ``is_db_ptr ptr::pointer``: returns 1 if ptr is a db_ptr returned by
  open, and 0 if it is not.

* ``is_open ptr::pointer``: returns 1 if the database connection referenced by
  by ptr is open.




Closing a Database Connection
-----------------------------

When a database connection object is no longer needed, it should be closed
so that SQLite can free the associated resources. 

* ``close dp1::pointer``: - if dp1's database connection is open, calls
  sqlite_close dp1. Otherwise does nothing. Before calling sqlite_close,
  close finalizes all "prepared statements" that associated with the
  connection.::

  > close dbp;
  1
  > close dbp; 
  0

Note that ``close ptr`` only matches when ptr is a db_ptr returned by
open::

  > sqlite3_errmsg dbp; //set ans to a "random" pointer
  #<pointer 0xb644eee4>

  > close ans;          //close does not reduce on a random pointer
  sql3::close #<pointer 0xb644eee4>

If a db_ptr, say dbp, goes out of scope, close dbp, is called
automagically. When debugging, this behavior can be observed by
editing sql3.pure, changing "const SHOW_OPEN_CLOSE = 1;" to "const
SHOW_OPEN_CLOSE = 0;" and running sudo make install in the pure-sql3
directory. This will cause a message to be printed whenever a db_ptr
or stmt_ptr is created or finalized.

Constructing Prepared Statements
--------------------------------

In SQLite3, prepared statement objects are used to execute SQL
statements using the following functions. As explained in An
Introduction  

    * sqlite3_prepare()
    * sqlite3_bind()
    * sqlite3_step()
    * sqlite3_column()
    * sqlite3_finalize()

The basic procedure is to prepare a statement, use the appropriate
sqlite_bind functions to bind its parameters, step it one or more
times until it is done and then finalize it. To The SQLite C/C++
Interface, sqlite3_bind and sqlite3_column represent families of bind
and column functions, with one member for each of the basic data types
recognized by SQLite. Thus, for example, sqlite_bind_double() would be
the function one would use to bind a prepared statement with an
argument of type double.  If a step returns data, use the appropriate
sqlite3_column functions (e.g., sqlite3_column_double) to extract the
data from each column.

Sql3 captures these procedure in four functions: ``prep``, ``exec``
``lexec`` and ``finalize``.


* ``prep dbp::pointer types::string sql::string`` - constructs prepared
  statement object and returns a stmt_ptr that references it. ``dbp`` must
  be a db_ptr or the rule will not match. ``sql`` is a string that
  specifies the sql statement to be executed. It can contain argument
  placeholders, indicated by "?", "?nnn", ":AAA", etc. See
  sqlite3_prepare_v2 for further details. The ``types`` parameter tells
  Sql3 the types of arguments to be used when binding the prepared
  statement as well as the types of objects returned at each step.

In the following two examples, the "c" and "i" int the binding strings
indicate that a string and an int will be used to bind stmp1, an int
will be used to bind stmp2 and that stmp2, when executed, will return
a result set in the form of a list of sublists each of which contains a
string and an int.  
::

  > let sp1 = prep dbp "ci" "insert into RM values (?,?)";

  > let sp2 = prep dbp "ci:i" "select * from RM where age > ?"; stmp;
  #<pointer 0xa4b43c0>

  > exec sp1 ("Tom",30);  //insert Tom
  []

  > exec sp2 19;          //select age > 19
  [["Sam",20],["Tom",30],["Fred",35]]

In general, the characters in the type string before the ":", if any, indicate
the types in the result set. Those that occur after the ":", if any
indicate the types of the arguments used to bind the prepared statement
object. If the type string does not contain a ":", the characters in the type
string, if any, are the types of binding arguments.

Sql3 provides the following set of "core" binding types:

::
  b; raw data; blob
  c; string; text (utf8)
  d; double; float;
  i; int; int64;
  k: int or bigint in int64 range; int64
  l; bigint; blob -- TODO
  n; SQLNULL; NULL
  x; binary serialized pure expression; blob
  v; variant; same as b,c,d,i,n as appropriate 

The "k" type, which converts ints and a subset of bigints into int64,
is useful when dealing with SQLite3's "integer primary keys" and
"rowids" both of which are 64 bit ints. It is also useful for storing
a useful subset fo bigint in a format that can be recognized by SQLite
in SQL math expressions. The "l" type, in contrast maps the bigints
onto blobs, which are generally meaningless in SQL math
expressions. The "n" type can only appear on the binding side of a
type string. A binding argument corresponding to a "v" in the type
string will be treated as bound as if the "v" were a "b", "c", "d",
"i" or "n", based on the type of the binding argument. An object
returned when a prepared statement is stepped that corresponding to a
"v" type will be fetched according to the native SQLite column type of
the corresponding column. The "x" type is used to store and
reconstruct Pure expressions as binary objects, using ``val`` and
``blob``.

As mentioned, users can define custom binding types and pass them as a
third parameter to open. The resulting db_ptr can be used with the
additional binding types to construct prepared statements that can be
executed with customized arguments. See advanced usage.

The examples directory contains a file sql3_types.pure that has an example
for each core binding type.

The stmt_p returned by `prep` is a sentry guarded sqlite3_stmt* that will
automagically be finalized when the stmt_p goes out of scope.

Executing Prepared Statements
-----------------------------

In Sql3, the bind, step, column, step, column ... cyle is encapsulated in
the exec and lexec functions.

* ``exec`` stmp::pointer args - uses args to bind the prepared statement
  referenced by stmp, then steps the prepared statement until it is done,
  collecting the results of the steps in a list. ``args`` is a tuple or
  list of arguments whose number and type correspond to the bind parameter
  types specified in the call to prep that produced stmp. This rule matches
  only if stmp is a stmt_ptr. Throws and error if SQlite returns an error
  code anywhere in the process.

If the statement does not return values, exec returns [];

  > exec sp1 ("Tom",30);  //insert Tom
  []

  > exec sp2 19;          //select age > 19
  [["Sam",20],["Tom",30],["Fred",35]]

 An error is thrown if the args do not correspond to the specified types.

  > catch error (exec stmp "a");
  error "sql3 error: Attempt to bind a \"a\" as a int"

If a prepared statement does not have any binding paramenters,
executed it with ():

  > let sp3 = prep dbp "c:" "select name from RM";

  > exec sp3 ();
  [["Sam"],["Fred"]]

A little extra care is required when executing prepared statements
that take a blob argument.  A blob argument is different than the
other types in that it must be a tuple (n,ptr) where n is the length
of the data in bytes and ptr is its address.  In order to preserve the
tuple as a pair, a blob argument should be passed to exec using the
list form rather than the tuple form. (See ...).

  > let blb = (100,ptr);

  > (a,blb,c);
  a,100,ptr,c

  > [a,blb,c];
  [a,(100,ptr),c]

Thus "exec stpx [a,blb,c]" would work fine, while exec stpx (a,blb,c)
would produce a Sql3 binding exception.

Busy
----

What to do .. in a transaction should roll back. How to do this? Or
disclaim for now.



Lazy Execution
--------------

The ``exec`` function returns result sets as an eager list, which
could be inefficient or simply not feesible for large result sets. In
such cases it is preferable to use ``lexec`` instead.

* ``lexec stmp::pointer args`` - same as ``exec`` except that it returns a
  lazy list.

E.g.,::

  > lexec stmp2 19;
  ["Sam",20]:#<thunk 0xb6475ab0>

Note that no changes to stmp2 were required. In addition, for most purposes
the lazy list returned by lexec can be processed by the same code that
processed the eager list returned by exec (see the "Lazy Evaluation and
Streams" section in the Pure manual)! The examples directory contains the
file sql3_lexec.pure that compares memory usage and time for a moderately
sized result set using ``exec`` and ``lexec``.

Automatically Prepared Statements
---------------------------------

For statements that have no parameters and which do not return results,
`exec` can be applied to a db_ptr.

* ``exec dbp::pointer sql::string`` - constructs a temporary prepared
  statement using the sql string. The sql string cannot contain parameters
  (?, ?nnn, etc.). Throws an error if SQLite indicates an error while exec
  is processing the sql. Otherwise retruns SQLITE_DONE.[TODO - BUG Try
  commit/rollback]::

  > exec db1 "create table if not exists RM (name varchar, age integer)";
  101 //SQLITE_DONE

Testing a stmt_ptr
------------------

For argument checking and other purposes it is sometimes useful to
determine if a given expression is a valid stmt_ptr.

* ``is_stmt_ptr ptr::pointer`` - returns 1 if ptr is a stmt_ptr, otherwise
  returns 0.::

  > is_stmt_ptr sp2;
  1

Finalizing Prepared Statements
------------------------------




Transactions
------------

No changes can be made to a SQLite database except within a
transaction. Any command that changes the database (basically, any SQL
command other than SELECT) will automatically start a transaction if
one is not already in effect. Automatically started transactions are
committed when the last query finishes. The upshot of this is that
unless a transaction is started manually, the database will be updated
(usually on disk) after each exec. For a long series of updates or
inserts this a can be very slow. The way to avoid this problem is to
begin a transaction manually before the first update and manually
ending the transaction after the last update.

Transactions can be started manually using the BEGIN command. Such
transactions persist until the next COMMIT or ROLLBACK
command. Transactions are also ended if an error occurs before the
transaction is manually ended using a COMMIT or ROLLBACK
statement. This behavior provides the means make a series of changes
on an "atomic" or all or nothing basis.

Transactions created using BEGIN...COMMIT do not nest. For nested
transactions, use the SAVEPOINT and RELEASE statements. 

Sql3 provides the following convenience functions all of which simply
exec dbp with the appropriate SQL statement. For example begin dbp is
exactly the same as 'exec dbp "BEGIN"'.

* ``begin dbp``
* ``begin_exclusive``
* ``begin_immediate``
* ``commit dbp``

* ``savepoint dbp``
* ``release dbp``
* ``rollback_to``
* ``rollback dbp``

See the SQLite documentation for further details on the use of these
SQL statements.

Exceptions
----------

Sql3 throws two types of exceptions, one for outright errors and one
for when an exec fails because the database is "busy".

* ``db_error ec msg``: If ec>0, the error was detected by SQLite
  itself. In this case, ec sqlite3 error code, and msg is the
  corresponding error message. If ec==0, the error was detected by
  Sql3 and msg is a Sql3 specific description of the error.

Example: ::

  >db_error_handler (db_error ec msg) = ()
  >when
  >  source = if ec > 0 then "SQLite" else "Sql3";
  >  printf "%s db_error: ec %d, %s\n" (source,ec,msg);
  >db_error_handler x = throw x;

  >catch db_error_handler (exec dbp "select * from NO_TABLE");
  SQLite db_error: ec 1, no such table: NO_TABLE

Here is a list, as of April 2, 2010, of the error codes returned by
the SQLite C interface:

*SQLITE_ERROR        1   /* SQL error or missing database */
*SQLITE_INTERNAL     2   /* Internal logic error in SQLite */
*SQLITE_PERM         3   /* Access permission denied */
*SQLITE_ABORT        4   /* Callback routine requested an abort */
*SQLITE_BUSY         5   /* The database file is locked */
*SQLITE_LOCKED       6   /* A table in the database is locked */
*SQLITE_NOMEM        7   /* A malloc() failed */
*SQLITE_READONLY     8   /* Attempt to write a readonly database */
*SQLITE_INTERRUPT    9   /* Operation terminated by sqlite3_interrupt()*/
*SQLITE_IOERR       10   /* Some kind of disk I/O error occurred */
*SQLITE_CORRUPT     11   /* The database disk image is malformed */
*SQLITE_NOTFOUND    12   /* NOT USED. Table or record not found */
*SQLITE_FULL        13   /* Insertion failed because database is full */
*SQLITE_CANTOPEN    14   /* Unable to open the database file */
*SQLITE_PROTOCOL    15   /* NOT USED. Database lock protocol error */
*SQLITE_EMPTY       16   /* Database is empty */
*SQLITE_SCHEMA      17   /* The database schema changed */
*SQLITE_TOOBIG      18   /* String or BLOB exceeds size limit */
*SQLITE_CONSTRAINT  19   /* Abort due to constraint violation */
*SQLITE_MISMATCH    20   /* Data type mismatch */
*SQLITE_MISUSE      21   /* Library used incorrectly */
*SQLITE_NOLFS       22   /* Uses OS features not supported on host */
*SQLITE_AUTH        23   /* Authorization denied */
*SQLITE_FORMAT      24   /* Auxiliary database format error */
*SQLITE_RANGE       25   /* 2nd parameter to sqlite3_bind out of range */
*SQLITE_NOTADB      26   /* File opened that is not a database file */

New error codes may be added in future versions of SQLite. See
http://www.sqlite.org/c3ref/c_abort.html. Note that the SQLite names
of the error codes are not exported by the Sql3 module.

A database is busy with respect to a call to the SQLite library when
the database engine is unable to acquire the database locks it needs
to do its job. For Sql3, this can occur in calls to ``exec`` and
``lexec``.

*``db_busy dbp::pointer``: dbp is the db_ptr used by Sql3 to access
 the database when the database was busy.

If the statement is a COMMIT or occurs outside of an explicit
transaction, then you can retry the statement. If the statement is not
a COMMIT and occurs within a explicit transaction then you should
rollback the transaction before continuing. ::

TODO - translate to Sql3...
     - example

Advanced Usage
==============


Custom SQL Functions
--------------------

An advanced (and complex) feature of the SQLite C interface is the
ability to add new SQL scalar or aggregate functions. The new
functions can be used in SQL statements the same as the prepackaged
functions and aggregates. Sql3 hides the complexity and seamlessly
integrates all of this functionality, :), into Pure.

*``function dbp::pointer name::string nargs::int fun``: registers the
 Pure function (or tuple of three Pure functions - see next section),
 fun, so that it can be called, as "name", as scalar (or aggregate)
 function of nargs arguments in SQL statements prepared with respect
 to dbp, a db_ptr. If nargs is (-1), the SQL function "name" is
 variadic.

Here is an example of a scalar function that takes two parameter. Note
that any kind of Pure "function" can be passed here; local functions,
global functions, lambdas or partial applications all work. ::

  >function dbp "p_fn" 2 plus with plus x y = x + y; end;

  >let sp4 = prep dbp "cii:" 
  >         "select p_fn('Hi ',name), age, p_fn(age,10) from RM";

  >exec sp4 ();
  [["Hi Sam",20,30],["Hi Fred",22,32]]

A pure function passed to ``function`` to register a variadic SQL
function receive all of its arguments in a single list. E.g., ::

  >function dbp "p_qm" (-1) quasimodo with
  >  quasimodo xs = "quasimodo: "+join ":" [str x | x=xs];
  >end;

If the SQL function takes no arguments, the corresponding Pure
function must, for technical reasons in Pure, take a single dummy
argument. E.g.,

  >function dbp "p_count" 0 counter with
  >  counter () = put r (get r+1);
  >end when r = ref 0 end;

These two registered SQL functions can now be used in SQL statments.

  >let sp5 = prep dbp "ic:" "select p_count(), p_qm(name,age) from RM";

  > exec sp5 ();
  [[1,"quasimodo: \"Sam\":20"],[2,"quasimodo: \"Fred\":22"]]

  > exec sp5 ();
  [[3,"quasimodo: \"Sam\":20"],[4,"quasimodo: \"Fred\":22"]]
  > 

SQL aggregate functions can be defined by passing a tuple consisting
of three Pure functions (step,final,start) as the function argument to
``function``.  In this case the 'step' function is called repeatedly
to accumulate values from the database, starting from the given
'start' value, and finally the 'final' function is applied to the
accumulated result. Note that for a single-argument 'step' function,
this works exactly as if the functions were invoked as 'final (foldl
step start values)', where 'values' is the list of aggregated values
from the database.

  >function dbp "p_avg" 1 (step,final,(0,0.0)) with
  >  step (n,a) x = n+1, a+x;
  >  final (n,a) = a/n;
  >end;

  >let sp6 = prep dbp "id:" "select count(name), p_avg(age) from RM";

  >exec sp6 ();
   [[2,21.0]]

More examples using ``function`` can be found in sql_funs.pure in the
examples subdirectory.

It is permitted to register multiple SQL functions with the same name
if they have differing numbers of arguments. Built-in SQL functions may be
overloaded or replaced by new application-defined functions.

An application-defined function is permitted to call other SQLite
interfaces. However, such calls must not close the database connection
nor finalize or reset the prepared statement in which the function is
running.

Accessing the rest of the SQLite3 C Interface
---------------------------------------------

int sqlite3_busy_timeout(sqlite3*, int ms);

Busy handler 

Example of getting row headers.


Custom Binding Types for Prepared Statements
--------------------------------------------



Threads
-------





TODO
----

db_busy dbp
   --- rollback (unless in a commit).
             --- throw special exception
             --- user can try again or rollback.
             --- need example


THREAD SAFE -- modes, note the multi thread. Using for a desktop or
analysis tool.
